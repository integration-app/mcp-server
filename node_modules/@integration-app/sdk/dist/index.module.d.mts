import { z } from 'zod';
import { AxiosRequestConfig } from 'axios';
import https from 'https';
import { Readable } from 'node:stream';

interface ConfigurationStateResult {
    state: ConfigurationState;
    message?: string;
    errors?: ErrorData[];
}
declare enum ConfigurationState {
    CONFIGURED = "CONFIGURED",
    NOT_CONFIGURED = "NOT_CONFIGURED"
}
declare enum WorkspaceElementType {
    Customer = "customer",
    Connector = "connector",
    Integration = "integration",
    Flow = "flow",
    FlowInstance = "flow-instance",
    FlowRun = "flow-run",
    Action = "action",
    Scenario = "scenario",
    ActionInstance = "action-instance",
    Connection = "connection",
    FieldMapping = "field-mapping",
    FieldMappingInstance = "field-mapping-instance",
    DataSource = "data-source",
    DataSourceInstance = "data-source-instance",
    DataLinkTable = "data-link-table",
    DataLinkTableInstance = "data-link-table-instance",
    AppEventType = "app-event-type",
    AppEventSubscription = "app-event-subscription",
    AppDataSchema = "app-data-schema",
    AppDataSchemaInstance = "app-data-schema-instance",
    ExternalEventSubscription = "external-event-subscription",
    ExternalEventLogRecord = "external-event-log-record",
    ExternalEventPull = "external-event-pull",
    Screen = "screen"
}
declare enum WorkspaceEventType {
    ConnectionCreated = "connection.created",
    ConnectionDeleted = "connection.deleted",
    ConnectionDisconnected = "connection.disconnected",
    ConnectionReconnected = "connection.reconnected",
    FlowRunQueued = "flowRun.queued",
    FlowRunStarted = "flowRun.started",
    FlowRunCompleted = "flowRun.completed",
    FlowRunFailed = "flowRun.failed",
    FlowRunStopped = "flowRun.stopped"
}
declare enum WorkspaceElementState {
    SETTING_UP = "SETTING_UP",
    CONFIGURATION_ERROR = "CONFIGURATION_ERROR",
    SETUP_FAILED = "SETUP_FAILED",
    READY = "READY"
}
declare enum WorkspaceElementDependencyType {
    Configuration = "CONFIGURATION",
    Parent = "PARENT"
}
interface WorkspaceElementCalculateStateResult {
    state: WorkspaceElementState;
    errors?: ErrorData[];
}
interface WorkspaceElement {
    id: string;
    name: string;
    key: string;
    state?: WorkspaceElementState;
    errors?: ErrorData[];
}
interface WorkspaceElementReference {
    type: WorkspaceElementType;
    id: string;
}
interface WorkspaceElementDependency extends WorkspaceElementReference {
    dependencyType: WorkspaceElementDependencyType;
    data?: unknown;
}

declare enum ErrorDoc {
    AuthenticationTokenErrors = "authentication-token-errors",
    DataSourceNoCollectionSelected = "data-source-no-collection-selected",
    FlowInstanceSetupFailed = "flow-instance-setup-failed",
    FlowInstanceSetupTimeout = "flow-instance-setup-timeout",
    WebhookCannotFindUser = "webhook-cannot-find-user"
}

declare enum ErrorType {
    BAD_REQUEST = "bad_request",
    CONNECTION = "connection",
    CONFIGURATION = "configuration",
    DEPENDENCY_ERROR = "dependency_error",
    FLOW_RUN = "flow_run",
    FLOW_INSTANCE_SETUP = "flow_instance_setup",
    CONCURRENCY = "concurrency",
    INTERNAL = "internal",
    ACTION_RUN = "action_run",
    ACTION_INSTANCE_SETUP = "action_instance_setup",
    UNIT_RUN = "unit_run"
}
declare enum BadRequestErrorKey {
    NOT_FOUND = "not_found",
    NOT_AUTHENTICATED = "not_authenticated",
    ACCESS_DENIED = "access_denied",
    ALREADY_EXISTS = "already_exists",
    RATE_LIMIT_EXCEEDED = "rate_limit_exceeded"
}
declare enum ConnectionErrorKey {
    CONNECTION_IS_DEFUNCT = "connection_is_defunct",
    ACCESS_TOKEN_EXPIRED = "access_token_expired",
    RATE_LIMIT_EXCEEDED = "rate_limit_exceeded"
}
declare enum ConcurrencyErrorKey {
    LOCK_TIMEOUT = "lock_timeout"
}
interface ErrorDataFields {
    type?: ErrorType;
    key?: string;
    message: string;
    data?: any;
    doc?: ErrorDoc;
    stack?: any;
    causedByError?: ErrorData;
    logs?: any[];
}
type ErrorConstructorArg = string | ErrorDataFields | Error;
declare function isIntegrationAppError(error: any): any;
declare class ErrorData implements ErrorDataFields {
    constructor(arg: ErrorConstructorArg);
}
interface ErrorData extends ErrorDataFields {
}
declare class IntegrationAppError extends Error {
    isIntegrationAppError: true;
    data: ErrorData;
    constructor(arg: ErrorConstructorArg);
}
declare class InternalError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class BadRequestError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class ConcurrencyError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class ConfigurationError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class DependencyError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg, workspaceElementReference?: WorkspaceElementReference);
}
declare class FlowInstanceSetupError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class FlowRunError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class ActionRunError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class ActionInstanceSetupError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class UnitRunError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class ConnectionError extends IntegrationAppError {
    constructor(arg: ErrorConstructorArg);
}
declare class NotFoundError extends BadRequestError {
    constructor(arg: ErrorConstructorArg);
}
declare class RateLimitExceededError extends BadRequestError {
    constructor(arg: ErrorConstructorArg);
}
declare class NotAuthenticatedError extends BadRequestError {
    constructor(arg: ErrorConstructorArg);
}
declare class AccessDeniedError extends BadRequestError {
    constructor(arg: ErrorConstructorArg);
}
declare function getErrorFromData(data: any): any;
declare function extractIntegrationAppErrorData(error: any): ErrorData;
declare function buildUserFriendlyErrorMessage({ message, doc }: ErrorData): string;

interface IntegrationAppClientOptions {
    token?: string;
    fetchToken?: () => Promise<string>;
    credentials?: any;
    fetchCredentials?: () => Promise<any>;
    apiUri?: string;
    uiUri?: string;
    accessToken?: string;
}
declare class IntegrationAppApiClient {
    apiUri: string;
    uiUri: string;
    token?: string;
    protected fetchToken?: () => Promise<string>;
    constructor({ uiUri, apiUri, accessToken, token, fetchToken, fetchCredentials, credentials, }?: IntegrationAppClientOptions);
    setCredentials(credentials: any): Promise<any>;
    getToken(): Promise<string>;
    get(uri: string, queryParams?: Record<string, any>, options?: AxiosRequestConfig): Promise<any>;
    post(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    put(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    patch(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    delete(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    getEmbedUri(page: string, params?: Record<string, any>): Promise<string>;
    private makeApiRequest;
    private handleRequestError;
}

type CommonListElementsQuery = SearchQuery & PaginationQuery & IncludeArchivedQuery;
type CommonInstancesListQuery = CommonListElementsQuery & {
    userId?: string;
    instanceKey?: string;
};
type CommonIntegrationOrConnectionQuery = {
    connectionId?: string;
    integrationId?: string;
    integrationKey?: string;
};
type IncludeArchivedQuery = {
    includeArchived?: boolean;
};
type SearchQuery = {
    search?: string;
};
type PaginationQuery = {
    limit?: number;
    cursor?: string;
};
declare class PaginationResponse<T> {
    items: T[];
    cursor?: string;
}

interface BaseElementInstance {
    id: string;
}
interface ElementInstanceSelector {
    id?: string;
    autoCreate?: boolean;
    instanceKey?: string;
    userId?: string;
    parentKey?: string;
    parentId?: string;
}
interface IntegrationSpecificElementSelector {
    id?: string;
    key?: string;
    integrationId?: string;
    integrationKey?: string;
}
type SelectorType = {
    id?: string;
} | string;
declare class ElementAccessor<Element, UpdateRequest, Selector extends SelectorType = string> {
    protected options: {
        client: IntegrationAppApiClient;
        path: string;
        selector: string | Selector;
    };
    constructor(options: {
        client: IntegrationAppApiClient;
        path: string;
        selector: string | Selector;
    });
    getUniqueIdentifier(): string;
    get(): Promise<Element>;
    put(data: UpdateRequest): Promise<Element>;
    patch(data: Partial<UpdateRequest>): Promise<Element>;
    archive(): Promise<void>;
    getPath(operation?: string): string;
}
declare class ElementListAccessor<Element, FindQuery, CreateRequest> {
    private client;
    private path;
    constructor(client: IntegrationAppApiClient, path: string);
    find(query?: FindQuery): Promise<PaginationResponse<Element>>;
    findAll(query?: Omit<FindQuery, 'limit'>): Promise<Element[]>;
    create(data: CreateRequest): Promise<Element>;
}
declare class ElementInstanceListAccessor<ElementInstance extends BaseElementInstance, FindQuery> {
    protected client: IntegrationAppApiClient;
    private path;
    constructor(client: IntegrationAppApiClient, path: string);
    find(query?: FindQuery): Promise<PaginationResponse<ElementInstance>>;
}
declare class ElementInstanceAccessor<ElementInstance extends BaseElementInstance, Selector extends {
    id?: string;
}, CreateRequest, UpdateRequest> {
    protected options: {
        client: IntegrationAppApiClient;
        instancePath: string;
        selector: string | Selector;
        type?: WorkspaceElementType;
    };
    private id;
    constructor(options: {
        client: IntegrationAppApiClient;
        instancePath: string;
        selector: string | Selector;
        type?: WorkspaceElementType;
    });
    getUniqueIdentifier(): string;
    get(): Promise<ElementInstance>;
    getId(): Promise<string>;
    create(data?: CreateRequest): Promise<ElementInstance>;
    put(data: CreateRequest): Promise<ElementInstance>;
    patch(data: UpdateRequest): Promise<ElementInstance>;
    archive(): Promise<void>;
    delete(): Promise<void>;
    protected getPath(operation?: string): string;
    private getSelector;
}

interface FindConnectionsQuery extends PaginationQuery {
    userId?: string;
    isTest?: boolean;
    integrationKey?: string;
    integrationId?: string;
    includeArchived?: boolean;
}
declare class CreateConnectionRequest {
    name: string;
    integrationId: string;
    credentials?: string;
}
declare class UpdateConnectionRequest {
    name?: string;
    credentials?: string;
    accessToken?: string;
}
declare class FindConnectionsResponse extends PaginationResponse<Connection> {
}
interface ConnectionSelector {
    id?: string;
    integrationKey?: string;
    integrationId?: string;
    connectionId?: string;
}

declare function createSchema(value: any): any;
declare function createCompoundSchema(values: any[]): any;

interface DataRecord {
    id: string;
    name?: string;
    uri?: string;
    iconUri?: string;
    fields?: Record<string, any>;
    udm?: string;
    unifiedFields?: Record<string, any>;
    rawFields?: Record<string, any>;
    createdTime?: string;
    updatedTime?: string;
    deletedTime?: string;
    createdById?: string;
    updatedById?: string;
}
declare enum DataCollectionEventType {
    CREATED = "created",
    UPDATED = "updated",
    DELETED = "deleted"
}
interface DataCollectionEvent {
    type: DataCollectionEventType;
    record: DataRecord;
}

interface DataSchema {
    title?: string;
    description?: string;
    type?: string | string[];
    format?: string;
    properties?: {
        [key: string]: DataSchema;
    };
    items?: DataSchema;
    additionalProperties?: boolean | DataSchema;
    enum?: string[];
    referenceRecords?: DataRecord[];
    referenceCollection?: {
        key: any;
        parameters?: Record<string, any>;
    };
    referenceUdm?: string;
    default?: any;
    allowCustom?: boolean;
    $ref?: string;
    required?: string[];
    minLength?: number;
    maxLength?: number;
    minimum?: number;
    maximum?: number;
    maxItems?: number;
    readOnly?: boolean;
    writeOnly?: boolean;
    examples?: any[];
    anyOf?: DataSchema[];
    isImplied?: boolean;
    referenceCollectionPath?: string;
    referenceCollectionUri?: string;
}

declare class IDataField {
    key?: string;
    name?: string;
    schema?: DataSchema;
    value?: any;
    isRequired?: boolean;
    subFields?: IDataField[];
}
interface DataField$1 extends IDataField {
}
declare class DataField$1 {
    constructor(data: IDataField);
}

interface PatchSchemaOption {
    readOnly?: boolean;
    writeOnly?: boolean;
}
declare function mergeSchemas(schemas: any[]): any;
declare function patchSchema(source: DataSchema, patch: DataSchema, options?: PatchSchemaOption): any;
declare function unwrapSchema(schema: any): any[];
declare function unwrapSchemas(schemas: any[]): any[];
declare function wrapAnyOfSchema(schema: any): any;

declare function buildDataSchema(value: any, variablesSchema?: any): any;
declare function updateImpliedSchema({ schema, value, variablesSchema, }: {
    schema: DataSchema | undefined;
    value: any;
    variablesSchema?: DataSchema;
}): DataSchema | undefined;
declare function updateImpliedSchema({ schema, value, variablesSchema, }: {
    schema: DataSchema;
    value: any;
    variablesSchema?: DataSchema | undefined;
}): DataSchema;
declare function schemaHasProperties(schema?: DataSchema): boolean;
declare function nonEmptyObjectProperties(properties: Record<string, DataSchema | undefined | null>): Record<string, DataSchema>;
declare function getSchemaFromValue(value: any, variablesSchema: any, ignoreFormulas?: boolean): any;
declare function schemaTypeFromValue(value: any): "object" | "boolean" | "number" | "string" | "array" | undefined;
interface ValueToSchemaOptions {
    addDefaults?: boolean;
    skipUnknownFields?: boolean;
    skipReadOnlyFields?: boolean;
    normalizeValues?: boolean;
    valueHasFormulas?: boolean;
}
declare function valueToSchema(value: any, schema: DataSchema | undefined, options?: ValueToSchemaOptions, field?: string): any;
declare function schemaIsScalar(schema: DataSchema): boolean;
declare function schemaHasFixedValues(schema: DataSchema): boolean;
declare function schemaAllowsCustomValue(schema: DataSchema): boolean | undefined;
declare function schemaIsNumber(schema: DataSchema): boolean;
declare function schemaWithTitle(schema: DataSchema, title: string): DataSchema;
declare function schemaWithTitle(schema: DataSchema | undefined, title: string): DataSchema | undefined;
declare function pickFieldsFromSchema(schema: DataSchema | undefined, fields: string[] | undefined): any;
declare function excludeReadOnlyFieldsFromSchema(schema?: DataSchema): DataSchema | undefined;
declare function excludeWriteOnlyFieldsFromSchema(schema?: DataSchema): DataSchema | undefined;
declare function excludeFieldsFromSchema(schema: DataSchema | undefined, fields: string[] | undefined): any;
declare function getRequiredFieldsFromSchema(schema: DataSchema): string[];
declare function addRequiredFieldsToSchema(schema: DataSchema | undefined, fields: string[] | undefined): any;
declare function removeRequiredFieldsFromSchema(schema: DataSchema): any;
declare function getMissingRequiredFields(schema: DataSchema | undefined, value: any): string[];
declare function populateSchemaTitles(schema: DataSchema | undefined): DataSchema | undefined;
declare function populateSchemaTitles(schema: DataSchema): DataSchema;
declare function generateExampleFromSchema(schema: DataSchema | undefined): any;
declare function isSchemaEmpty(schema: DataSchema): boolean;
declare function compressDataSchema(schema: DataSchema): DataSchema;
declare function getReferenceCollectionPointerForSchema(schema: DataSchema | undefined): DataLocationPointer | undefined;
declare function getReferenceCollectionPathForSchema(schema: DataSchema | undefined): string | undefined;
declare function walkSchema(schema: DataSchema | undefined, callback: (schema: DataSchema, locator: string) => DataSchema | undefined, locator?: string): DataSchema | undefined;

declare enum HttpRequestMethod {
    GET = "GET",
    POST = "POST",
    PATCH = "PATCH",
    PUT = "PUT",
    DELETE = "DELETE"
}
interface HttpRequestSpec {
    method?: HttpRequestMethod;
    uri: any;
    headers?: Record<string, any>;
    query?: Record<string, any>;
    body?: any;
}
declare const HTTP_REQUEST_SCHEMA: {
    type: string;
    properties: {
        uri: {
            type: string;
        };
        method: {
            type: string;
            enum: string[];
        };
        body: {};
        query: {
            type: string;
            section: boolean;
            additionalProperties: boolean;
        };
        headers: {
            type: string;
            section: boolean;
            additionalProperties: boolean;
        };
    };
};

interface GraphqlApiClientInput {
    path: string;
    method: HttpRequestMethod;
    query: string;
}
interface GraphQLApiMapping {
    path: string;
    operationType: 'query' | 'mutation';
    requestMapping: GraphQLFieldMapping[];
    responseMapping?: any;
}
interface GraphQLFieldMapping {
    field: string;
    args?: Record<string, any>;
    subFields?: GraphQLFieldMapping[];
}

interface OperationBase {
    key: string;
    name: string;
    isReadOnly?: boolean;
    description?: string;
    tags?: string[];
}
interface OperationListItem extends OperationBase {
}
interface OperationSpec extends OperationBase {
    inputSchema?: any;
    outputSchema?: any;
    isReadOnly?: boolean;
}
interface OperationRunRequest {
    input: any;
}
interface OperationRunResponse {
    output?: any;
}
interface OperationMapping {
    operationKey: string;
    inputMapping?: any;
    outputMapping?: any;
}

type ConnectorOperationMethod<ImplementationFields extends ConnectorMethodImplementation | ConnectorMethodImplementationBase = ConnectorMethodImplementationBase> = {
    isIncomplete?: boolean;
} & ImplementationFields;
declare const ConnectorOperationMethodImplementationTypes: ConnectorMethodImplementationType[];
interface ConnectorOperationHandler extends OperationSpec {
    methods?: Record<'run', ConnectorOperationMethod>;
}

interface RestApiClientInput {
    path: string;
    method: HttpRequestMethod;
    query?: Record<string, string>;
    data?: any;
    headers?: Record<string, string>;
    responseType?: 'arraybuffer' | 'stream';
    returnFullResponse?: boolean;
}
interface RestApiClientOutput {
    status: number;
    headers?: Record<string, string>;
    data?: any;
}
interface RestApiMapping {
    path: string;
    method: string;
    requestMapping: {
        pathParameters?: any;
        query?: any;
        data?: any;
        headers?: any;
    };
    responseMapping?: any;
}
interface RestApiClientResponseHandler {
    match: any;
    isSuccess: boolean;
    error?: any;
}
interface RestApiClientOverride {
    match: {
        path: string;
        method: string;
    };
    patch?: {
        query?: Record<string, string>;
        data?: any;
        headers?: Record<string, string>;
    };
}
interface RestApiClientOptions {
    baseUri?: any;
    proxyUri?: any;
    headers?: {
        [key: string]: any;
    };
    auth?: {
        username: any;
        password: any;
    };
    query?: {
        [key: string]: any;
    };
    returnFullResponse?: boolean;
    responseHandlers?: Array<RestApiClientResponseHandler>;
    overrides?: RestApiClientOverride[];
    httpsAgent?: https.Agent;
    dynamicOptions?: (input: RestApiClientInput) => RestApiClientOptions;
    binary?: boolean;
    stream?: boolean;
    onError?: (error: any) => any;
}

declare enum ConnectorMethodImplementationType {
    mapping = "mapping",
    operationMapping = "operation-mapping",
    restApiMapping = "rest-api-mapping",
    graphqlApiMapping = "graphql-api-mapping",
    javascript = "javascript",
    notSupported = "not-supported"
}
type ConnectorMethodImplementation = ConnectorMethodImplementationBase | ConnectorMethodImplementationMapping | ConnectorMethodImplementationOperationMapping | ConnectorMethodImplementationRestApiMapping | ConnectorMethodImplementationGraphqlApiMapping | ConnectorMethodImplementationJavascript | ConnectorMethodImplementationNotSupported;
declare const CONNECTOR_METHOD_IMPLEMENTATION_SUFFIXES: Partial<Record<ConnectorMethodImplementationType, string[]>>;
interface ConnectorMethodImplementationBase {
    implementationType?: ConnectorMethodImplementationType;
    filePath?: string;
    inheritedFromPath?: string[];
    isIncomplete?: boolean;
    parametersSchema?: DataSchema;
}
interface ConnectorMethodImplementationMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.mapping;
    mapping: any;
}
interface ConnectorMethodImplementationOperationMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.operationMapping;
    mapping: OperationMapping;
}
interface ConnectorMethodImplementationRestApiMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.restApiMapping;
    mapping: RestApiMapping;
}
interface ConnectorMethodImplementationGraphqlApiMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.graphqlApiMapping;
    mapping: GraphQLApiMapping;
}
interface ConnectorMethodImplementationJavascript extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.javascript;
    code: string;
}
interface ConnectorMethodImplementationNotSupported extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.notSupported;
}

type ConnectorDataLocationMethod<ConfigFields = unknown, ImplementationFields extends ConnectorMethodImplementation | ConnectorMethodImplementationBase = ConnectorMethodImplementationBase> = {
    apiRequests?: ApiRequestSpec[];
} & ImplementationFields & ConfigFields;
declare const DataLocationMethodImplementationTypes: ConnectorMethodImplementationType[];

declare const DataLocationTypeDirectory: {
    spec: ConnectorDataDirectoryMethodType<unknown>;
    methods: {
        list: ConnectorDataDirectoryMethodType<unknown>;
    };
};
interface ConnectorDataDirectory extends ConnectorDataLocationBase {
    type: 'directory';
    spec?: ConnectorDataLocationMethod;
    methods: {
        list: ConnectorDataLocationMethod<any>;
    };
}
declare const ConnectorDataDirectoryMethodKeys: Array<keyof typeof DataLocationTypeDirectory.methods>;

interface ConnectorDataDirectoryMethodType<ConfigType = unknown> {
    name?: string;
    description?: string;
    fileKey?: string;
    getConfigSchema?: (args: ConnectorDataDirectoryMethodTypeArgs<ConfigType>) => DataSchema;
    getInputSchema?: (args: ConnectorDataDirectoryMethodTypeArgs<ConfigType>) => DataSchema;
    getOutputSchema?: (args: ConnectorDataDirectoryMethodTypeArgs<ConfigType>) => DataSchema;
    supportedImplementationTypes: ConnectorMethodImplementationType[];
}
interface ConnectorDataDirectoryMethodTypeArgs<ConfigType = unknown> {
    method: ConnectorDataLocationMethod<ConfigType>;
    directory: ConnectorDataDirectory;
}

interface ConnectorDataCollectionEventMethodTypeArgs<ImplementationFields = unknown> {
    event: ConnectorDataCollectionEvent<ImplementationFields>;
    collection: ConnectorDataCollection;
}
interface ConnectorDataCollectionEventMethodType<ImplementationFields = unknown> {
    fileKey?: string;
    getInputSchema?: (args: ConnectorDataCollectionEventMethodTypeArgs<ImplementationFields>) => DataSchema;
    getOutputSchema?: (args: ConnectorDataCollectionEventMethodTypeArgs<ImplementationFields>) => DataSchema;
    supportedImplementationTypes: ConnectorMethodImplementationType[];
}

interface ConnectorEventImplementationFields {
    implementationType: 'connector-event';
    stateSchema?: DataSchema;
    methods: Record<keyof typeof ConnectorEventImplementationType$1.methods, ConnectorDataLocationMethod>;
}
declare const ConnectorEventImplementationType$1: {
    methods: {
        getEventConfig: ConnectorDataCollectionEventMethodType<ConnectorEventImplementationFields>;
        extractEvents: ConnectorDataCollectionEventMethodType<ConnectorEventImplementationFields>;
    };
};

interface CustomPullEventImplementationFields {
    implementationType: 'custom-pull';
    stateSchema?: DataSchema;
    methods: Record<keyof typeof CustomPullEventImplementationType.methods, ConnectorDataLocationMethod>;
}
declare const CustomPullEventImplementationType: {
    methods: {
        subscribe: ConnectorDataCollectionEventMethodType<CustomPullEventImplementationFields>;
        collectEvents: ConnectorDataCollectionEventMethodType<CustomPullEventImplementationFields>;
    };
};

interface FullScanEventImplementationFields {
    implementationType: 'full-scan';
    ignoredFields?: string[];
}

interface PullLatestRecordsEventImplementationFields {
    implementationType: 'pull-latest-records';
    methods: Record<keyof typeof PullLatestRecordsEventImplementationType.methods, ConnectorDataLocationMethod>;
}
interface PullLatestRecordsEventOutput {
    records: DataRecord[];
    cursor?: string;
    logs?: any[];
}
declare const PullLatestRecordsEventImplementationType: {
    methods: {
        pullLatestRecords: ConnectorDataCollectionEventMethodType<PullLatestRecordsEventImplementationFields>;
    };
};

interface WebhookEventImplementationFields {
    implementationType: 'webhook';
    querySchema?: DataSchema;
    dataSchema?: DataSchema;
    stateSchema?: DataSchema;
    methods: Record<keyof typeof WebhookEventImplementationType.methods, ConnectorDataLocationMethod>;
}
declare const WebhookEventImplementationType: {
    methods: {
        subscribe: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
        unsubscribe: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
        handle: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
        refresh: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
    };
};

interface BaseConnectorDataCollectionEventImplementationFields {
    implementationType: keyof typeof ConnectorDataCollectionEventImplementationType;
}
type ConnectorDataCollectionEvent<ImplementationFields = BaseConnectorDataCollectionEventImplementationFields> = {
    inheritedFromPath?: string[];
    isIdOnly?: boolean;
} & ImplementationFields;
type ConnectorDataCollectionEventWebhook = ConnectorDataCollectionEvent<WebhookEventImplementationFields>;
type ConnectorDataCollectionEventPullLatestRecords = ConnectorDataCollectionEvent<PullLatestRecordsEventImplementationFields>;
type ConnectorDataCollectionEventCustomPull = ConnectorDataCollectionEvent<CustomPullEventImplementationFields>;
type ConnectorDataCollectionEventFullScan = ConnectorDataCollectionEvent<FullScanEventImplementationFields>;
declare const ConnectorDataCollectionEventImplementationType: {
    webhook: {
        methods: {
            subscribe: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
            unsubscribe: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
            handle: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
            refresh: ConnectorDataCollectionEventMethodType<WebhookEventImplementationFields>;
        };
    };
    'pull-latest-records': {
        methods: {
            pullLatestRecords: ConnectorDataCollectionEventMethodType<PullLatestRecordsEventImplementationFields>;
        };
    };
    'custom-pull': {
        methods: {
            subscribe: ConnectorDataCollectionEventMethodType<CustomPullEventImplementationFields>;
            collectEvents: ConnectorDataCollectionEventMethodType<CustomPullEventImplementationFields>;
        };
    };
    'connector-event': {
        methods: {
            getEventConfig: ConnectorDataCollectionEventMethodType<ConnectorEventImplementationFields>;
            extractEvents: ConnectorDataCollectionEventMethodType<ConnectorEventImplementationFields>;
        };
    };
    'full-scan': {
        methods: {};
    };
};
type ConnectorDataCollectionEventType = 'created' | 'updated' | 'deleted';
type ConnectorDataCollectionEventImplementationTypeKey = keyof typeof ConnectorDataCollectionEventImplementationType;
declare function getEventMethodFileKey(eventType: ConnectorDataCollectionEventType, eventImplementationType: ConnectorDataCollectionEventImplementationTypeKey, methodKey: string): string | undefined;
declare function getAllEventMethodFilePaths(eventType: ConnectorDataCollectionEventType | 'all', eventImplementationType: ConnectorDataCollectionEventImplementationTypeKey, methodKey: string): (string | null | undefined)[];

interface DataCollectionCreateConfigType {
    fields?: string[];
    requiredFields?: string[];
    excludedFields?: string[];
}

interface DataCollectionListConfigType {
    filterFields?: string[];
}

interface DataCollectionMatchConfigType {
    fields?: string[];
}

declare const DataLocationTypeCollection: {
    spec: ConnectorDataCollectionMethodType<unknown>;
    recordFromFields: ConnectorDataCollectionMethodType<unknown>;
    customFieldsSchema: ConnectorDataCollectionMethodType<unknown>;
    fieldsFromApi: ConnectorDataCollectionMethodType<unknown>;
    fieldsToApi: ConnectorDataCollectionMethodType<unknown>;
    methods: {
        list: ConnectorDataCollectionMethodType<DataCollectionListConfigType>;
        findById: ConnectorDataCollectionMethodType<unknown>;
        match: ConnectorDataCollectionMethodType<DataCollectionMatchConfigType>;
        search: ConnectorDataCollectionMethodType<unknown>;
        create: ConnectorDataCollectionMethodType<DataCollectionCreateConfigType>;
        update: ConnectorDataCollectionMethodType<DataCollectionUpdateConfigType>;
        delete: ConnectorDataCollectionMethodType<unknown>;
        find: ConnectorDataCollectionMethodType<{
            queryFields: string[];
        }>;
    };
    recordToApi: ConnectorDataCollectionMethodType<unknown>;
    recordFromApi: ConnectorDataCollectionMethodType<unknown>;
    recordFromApiMapping: ConnectorDataCollectionMethodType<unknown>;
    recordFromApiCode: ConnectorDataCollectionMethodType<unknown>;
    fieldsToApiMapping: ConnectorDataCollectionMethodType<unknown>;
    fieldsToApiCode: ConnectorDataCollectionMethodType<unknown>;
};
interface ConnectorDataCollection extends ConnectorDataLocationBase {
    type: 'collection';
    fieldsSchema?: DataSchema;
    isHidden?: boolean;
    customFields?: boolean;
    customFieldsSchema?: ConnectorDataLocationMethod;
    spec?: ConnectorDataLocationMethod;
    recordFromFields?: ConnectorDataLocationMethod;
    fieldsFromApi?: ConnectorDataLocationMethod;
    recordFromApi?: ConnectorDataLocationMethod;
    recordFromApiCode?: ConnectorDataLocationMethod;
    recordFromApiMapping?: ConnectorDataLocationMethod;
    recordToApi?: ConnectorDataLocationMethod;
    fieldsToApi?: ConnectorDataLocationMethod;
    fieldsToApiCode?: ConnectorDataLocationMethod;
    fieldsToApiMapping?: ConnectorDataLocationMethod;
    methods?: {
        list?: ConnectorDataLocationMethod<DataCollectionListConfigType>;
        findById?: ConnectorDataLocationMethod;
        match?: ConnectorDataLocationMethod<DataCollectionMatchConfigType>;
        search?: ConnectorDataLocationMethod;
        create?: ConnectorDataLocationMethod<DataCollectionCreateConfigType>;
        update?: ConnectorDataLocationMethod<DataCollectionUpdateConfigType>;
        delete?: ConnectorDataLocationMethod;
        find?: ConnectorDataLocationMethod<{
            queryFields?: string[];
        }>;
    };
    events?: Partial<Record<'created' | 'updated' | 'deleted', ConnectorDataCollectionEvent>>;
    udm?: Partial<Record<string, {
        extract?: ConnectorDataLocationMethod;
        parse?: ConnectorDataLocationMethod;
    }>>;
}
declare const ConnectorDataCollectionMethodKeys: Array<keyof typeof DataLocationTypeCollection.methods>;

interface ConnectorDataCollectionMethodType<ConfigFields = unknown> {
    name?: string;
    description?: string;
    fileKey?: string;
    getConfigSchema?: (args: ConnectorDataCollectionMethodTypeArgs<ConfigFields>) => DataSchema;
    getInputSchema?: (args: ConnectorDataCollectionMethodTypeArgs<ConfigFields>) => DataSchema;
    getOutputSchema?: (args: ConnectorDataCollectionMethodTypeArgs<ConfigFields>) => DataSchema;
    supportedImplementationTypes: ConnectorMethodImplementationType[];
    isDeprecated?: boolean;
}
interface ConnectorDataCollectionMethodTypeArgs<ConfigFields = unknown> {
    method?: ConnectorDataLocationMethod<ConfigFields>;
    collectionHandler?: ConnectorDataCollection;
    collectionSpec?: DataCollectionSpec;
    connectorSpec?: ConnectorSpec;
    parameters?: any;
}

interface DataCollectionUpdateConfigType {
    fields?: string[];
    excludedFields?: string[];
}

type DataLocationSpec = DataCollectionSpec | DataDirectorySpec;
declare enum DataLocationType {
    directory = "directory",
    collection = "collection"
}
interface DataLocationListItem {
    key: string;
    name: string;
    type: DataLocationType;
    isHidden?: boolean;
}
interface DataLocationPointer {
    key: string;
    parameters?: Record<string, any>;
    type?: DataLocationType;
}
interface DataLocation {
    key?: string;
    parameters?: any;
    path?: string;
    name?: string;
    type?: DataLocationType;
    isDefault?: boolean;
    read?: boolean;
    write?: boolean;
}
interface DataLocationMixin {
    key: string;
    parameters?: any;
}
interface DataLocationSpecBase {
    type: DataLocationType;
    key?: string;
    name: string;
    parametersSchema?: DataSchema;
}
interface DataCollectionSpec extends DataLocationSpecBase {
    fieldsSchema?: DataSchema;
    list?: DataCollectionListSpec;
    search?: DataCollectionSearchSpec;
    match?: DataCollectionMatchSpec;
    findById?: DataCollectionFindByIdSpec;
    create?: DataCollectionCreateSpec;
    update?: DataCollectionUpdateSpec;
    delete?: DataCollectionDeleteSpec;
    events?: DataCollectionEventsSpec;
    customFields?: boolean;
    udm?: DataCollectionUdmsSpec;
    find?: DataCollectionFindSpec;
}
interface ApiRequestSpec {
    path: any;
    method: any;
}
declare enum DataDirectoryOperation {
    list = "list"
}
interface DataDirectorySpec extends DataLocationSpecBase {
    locations?: DataLocation[];
}
interface DataCollectionMethodSpec {
    apiRequests?: ApiRequestSpec[];
}
interface DataCollectionFindSpec extends DataCollectionMethodSpec {
    queryFields?: string[];
}
interface DataCollectionMatchSpec extends DataCollectionMethodSpec {
    fields?: string[];
}
interface DataCollectionListSpec extends DataCollectionMethodSpec {
    filterFields?: string[];
}
interface DataCollectionSearchSpec extends DataCollectionMethodSpec {
}
interface DataCollectionFindByIdSpec extends DataCollectionMethodSpec {
}
interface DataCollectionCreateSpec extends DataCollectionMethodSpec {
    fields?: string[];
    requiredFields?: string[];
    excludedFields?: string[];
}
interface DataCollectionUpdateSpec extends DataCollectionMethodSpec {
    fields?: string[];
    excludedFields?: string[];
}
interface DataCollectionDeleteSpec extends DataCollectionMethodSpec {
}
type DataCollectionUdmSpec = {
    fields?: string[];
    extract?: Record<string, any>;
    parse?: Record<string, any>;
};
type DataCollectionUdmsSpec = Record<string, DataCollectionUdmSpec>;
type DataCollectionEventTypeSpec = {
    type: 'push' | 'pull';
    isFullScan?: boolean;
    isIdOnly?: boolean;
};
type DataCollectionEventsSpec = {
    [value in DataCollectionEventType]: DataCollectionEventTypeSpec;
} & {
    all?: DataCollectionEventTypeSpec;
};
interface DataCollectionMethodRequest {
    parameters?: Record<string, any>;
}
interface DataCollectionFindRequest {
    query?: any;
    cursor?: string;
}
interface DataCollectionFindResponse {
    records: DataRecord[];
    cursor?: string;
}
interface DataCollectionListRequest extends DataCollectionMethodRequest {
    filter?: any;
    unifiedFilter?: any;
    cursor?: string;
}
interface DataCollectionListResponseDrilldown {
    parameters?: Record<string, any>;
    filter?: Record<string, any>;
}
interface DataCollectionListResponse {
    records: DataRecord[];
    drilldowns?: Array<DataCollectionListResponseDrilldown>;
    cursor?: string;
}
interface DataCollectionSearchRequest extends DataCollectionMethodRequest {
    query: string;
    cursor?: string;
}
interface DataCollectionSearchResponse {
    records: DataRecord[];
    cursor?: string;
}
interface DataCollectionFindByIdRequest extends DataCollectionMethodRequest {
    id: string;
    udm?: string;
}
interface DataCollectionFindByIdResponse {
    record: DataRecord;
}
interface DataCollectionMatchRequest extends DataCollectionMethodRequest {
    query: Record<string, any>;
}
interface DataCollectionMatchResponse {
    record?: DataRecord;
}
interface DataCollectionCreateRequest extends DataCollectionMethodRequest {
    fields: Record<string, any>;
}
interface DataCollectionCreateResponse {
    id: string;
}
interface DataCollectionUpdateRequest extends DataCollectionMethodRequest {
    id: string;
    fields: Record<string, any>;
}
interface DataCollectionUpdateResponse {
    id: string;
}
interface DataCollectionDeleteRequest extends DataCollectionMethodRequest {
    id: string;
}
interface DataCollectionDeleteResponse {
}
interface DataCollectionSubscribeRequest extends DataCollectionMethodRequest {
    events?: {
        created?: boolean;
        updated?: boolean;
        deleted?: boolean;
    };
    udm?: string;
    webhookUri: string;
}
interface DataCollectionSubscribeResponse {
    subscriptionId: string;
    pullIntervalSeconds?: number;
    cursor?: string;
}
interface DataCollectionUpdateSubscriptionRequest extends DataCollectionSubscribeRequest {
    subscriptionId: string;
    cursor?: string;
}
interface DataCollectionUpdateSubscriptionResponse extends Omit<DataCollectionSubscribeResponse, 'subscriptionId'> {
}
interface DataCollectionUnsubscribeRequest {
    subscriptionId: string;
}
interface DataCollectionUnsubscribeResponse {
}
interface DataCollectionEventsRequest extends DataCollectionMethodRequest {
    subscriptionId: string;
    cursor: string;
}
interface DataCollectionEventsResponse {
    events: DataCollectionEvent[];
    cursor?: string;
    state?: any;
}
interface DataEventWebhookPayload {
    subscriptionId: string;
    events: DataCollectionEvent[];
}
interface DataCollectionParseUnifiedFieldsRequest {
    udm: string;
    unifiedFields: Record<string, any>;
}
interface DataCollectionParseUnifiedFieldsResponse {
    fields: any;
}
interface DataDirectoryListRequest {
    cursor?: string;
}
interface DataDirectoryListResponse {
    locations: DataLocation[];
    cursor?: string;
}
declare const ConnectorDataLocationTypes: {
    collection: {
        spec: ConnectorDataCollectionMethodType<unknown>;
        recordFromFields: ConnectorDataCollectionMethodType<unknown>;
        customFieldsSchema: ConnectorDataCollectionMethodType<unknown>;
        fieldsFromApi: ConnectorDataCollectionMethodType<unknown>;
        fieldsToApi: ConnectorDataCollectionMethodType<unknown>;
        methods: {
            list: ConnectorDataCollectionMethodType<DataCollectionListConfigType>;
            findById: ConnectorDataCollectionMethodType<unknown>;
            match: ConnectorDataCollectionMethodType<DataCollectionMatchConfigType>;
            search: ConnectorDataCollectionMethodType<unknown>;
            create: ConnectorDataCollectionMethodType<DataCollectionCreateConfigType>;
            update: ConnectorDataCollectionMethodType<DataCollectionUpdateConfigType>;
            delete: ConnectorDataCollectionMethodType<unknown>;
            find: ConnectorDataCollectionMethodType<{
                queryFields: string[];
            }>;
        };
        recordToApi: ConnectorDataCollectionMethodType<unknown>;
        recordFromApi: ConnectorDataCollectionMethodType<unknown>;
        recordFromApiMapping: ConnectorDataCollectionMethodType<unknown>;
        recordFromApiCode: ConnectorDataCollectionMethodType<unknown>;
        fieldsToApiMapping: ConnectorDataCollectionMethodType<unknown>;
        fieldsToApiCode: ConnectorDataCollectionMethodType<unknown>;
    };
    directory: {
        spec: ConnectorDataDirectoryMethodType<unknown>;
        methods: {
            list: ConnectorDataDirectoryMethodType<unknown>;
        };
    };
};
type ConnectorDataLocation = ConnectorDataCollection | ConnectorDataDirectory;

interface ConnectorDataLocationBase {
    type: 'collection' | 'directory';
    key: string;
    name: string;
    parametersSchema?: DataSchema;
    extends?: DataLocationMixin[];
    relatedOperationKeys?: string[];
}

declare function getDataLocationMethodPath(locationKey: any, methodKey: any): string;
declare function dataLocationParametersMatch({ locationParameters, targetParameters, }: {
    locationParameters: Record<string, any>;
    targetParameters: Record<string, any>;
}): boolean;
declare function parseDataLocationPath(path: string): DataLocationPointer;
declare function parseDataLocationPath(path: string | undefined): DataLocationPointer | undefined;
declare function makeDataLocationPath(pointer: DataLocationPointer): string;
declare function makeDataLocationPath(pointer: DataLocationPointer | undefined): string | undefined;
declare function makeDataLocationOperationPath(collectionPath: string, operation: string): string;
declare function isSameDataLocation(location1: DataLocationPointer, location2: DataLocationPointer): boolean;
declare function isDataLocationMethodSupported(location: ConnectorDataLocation, methodKey: string): boolean;
declare function getDataCollectionCreateFields(spec: DataCollectionSpec): DataSchema | undefined;
declare function getDataCollectionUpdateFields(spec: DataCollectionSpec): DataSchema | undefined;
declare function getWritableFieldsSchema(spec: DataCollectionSpec): DataSchema | undefined;

interface UnifiedDataModel {
    singularName: string;
    pluralName: string;
    fieldsSchema: any;
    description?: string;
    categories?: (typeof CONNECTOR_CATEGORIES)[number][];
    normalizeFields?: (fields: Record<string, any>) => Record<string, any>;
    populateFields?: (fields: Record<string, any>) => Record<string, any>;
    list?: DataCollectionListSpec;
    find?: DataCollectionFindSpec;
    match?: DataCollectionMatchSpec;
    create?: DataCollectionCreateSpec;
    update?: DataCollectionUpdateSpec;
    delete?: DataCollectionDeleteSpec;
    udmFallbacks?: Array<UDMFallback>;
    fieldFallbacks?: Record<string, FieldFallbackValues>;
}
interface UDMFallback {
    udm: string;
    importFields?: Record<string, any>;
    exportFields?: Record<string, any>;
}
type FieldFallbackValues = any[];

declare enum UDM {
    ACTIVITIES = "activities",
    BILLS = "bills",
    CAMPAIGN_MEMBERS = "campaign-members",
    CAMPAIGNS = "campaigns",
    COMPANIES = "companies",
    CONTACTS = "contacts",
    CONTACT_LISTS = "contact-lists",
    CREDIT_NOTES = "credit-notes",
    CUSTOMERS = "customers",
    DEAL_PRODUCTS = "deal-products",
    DEALS = "deals",
    DEAL_STAGES = "deal-stages",
    DOCUMENTS = "documents",
    DRIVES = "drives",
    DRIVE_ITEMS = "drive-items",
    EEOCS = "eeocs",
    EMAILS = "emails",
    EMPLOYEES = "employees",
    FILES = "files",
    FOLDERS = "folders",
    INVOICES = "invoices",
    JOB_APPLICATIONS = "job-applications",
    JOB_CANDIDATES = "job-candidates",
    JOB_INTERVIEWS = "job-interviews",
    JOB_OFFERS = "job-offers",
    JOBS = "jobs",
    JOURNAL_ENTRIES = "journal-entries",
    LEADS = "leads",
    LEDGER_ACCOUNTS = "ledger-accounts",
    MEETINGS = "meetings",
    MESSAGES = "messages",
    NOTES = "notes",
    ORDERS = "orders",
    PAYMENTS = "payments",
    PAYROLLS = "payrolls",
    PRODUCTS = "products",
    PROJECTS = "projects",
    SUPPLIERS = "suppliers",
    TASKS = "tasks",
    TAX_RATES = "tax-rates",
    USERS = "users",
    TIMEOFF_BALANCES = "timeoff-balances",
    TIMEOFF_REQUESTS = "timeoff-requests"
}
declare const UNIFIED_DATA_MODELS: Record<UDM, UnifiedDataModel>;
declare function findUdmRootLocation(spec: ConnectorSpec, udm: string, useFallback?: boolean): DataLocationPointer | undefined;
declare function findUdmDefaultCollection(spec: ConnectorSpec, udm: string, useFallback?: boolean): DataLocationPointer | undefined;
declare function addUdmFallbackFields(fields: any, udm: string): any;

interface ConnectorUdmListLitem {
    key: string;
}
interface ConnectorUdmSpec {
    defaultCollection?: DataLocationPointer;
    rootDirectory?: DataLocationPointer;
    collectionMappings: ConnectorUdmCollectionMapping[];
}
interface ConnectorUdmCollectionMapping extends DataLocationPointer {
    fieldsToCollection?: any;
    fieldsFromCollection?: any;
}
declare function findUdmCollectionMapping(udm: ConnectorUdmSpec, collectionKey: string, parameters?: Record<string, any>): ConnectorUdmCollectionMapping | undefined;

declare const CONNECTOR_CATEGORIES: readonly ["Accounting", "Ads", "Analytics", "ATS", "Communication", "CRM", "Customer Success", "Document Management", "E-Commerce", "E-Signature", "ERP", "File Storage", "HRIS", "Legal", "Marketing Automation", "Payments", "Project Management", "Sales", "Ticketing"];
type Connector = ConnectorSpec & {
    id: string;
    key: string;
    name: string;
    categories: string[];
    logoUri: string;
    baseUri: string;
    revision?: string;
    status: ConnectorStatus;
    hasReadme?: boolean;
    hasDefaultParameters?: boolean;
    hasTest?: boolean;
    hasOperations?: boolean;
    hasData?: boolean;
    udms?: string[];
    isReadOnly?: boolean;
    workspaceId?: string;
};
declare enum ConnectorStatus {
    production = "production",
    beta = "beta",
    planned = "planned"
}
interface ConnectorUiSpec {
    schema?: DataSchema;
    description?: string;
    helpUri?: string;
    test?: boolean;
}
type ConnectorDataUdmSpec = {
    rootLocation: DataLocation;
};
type ConnectorDataSpec = {
    rootLocation?: DataLocation;
    locations?: DataLocationSpec[];
    udm?: Partial<Record<UDM, ConnectorDataUdmSpec>>;
    root?: DataLocation;
} & Partial<Record<UDM, DataLocation>>;
type ConnectorApiType = 'openapi' | 'graphql';
interface ConnectorSpec {
    key?: string;
    name?: string;
    appUri?: string;
    logoUri?: string;
    apiDocsUri?: string;
    api?: {
        type: ConnectorApiType;
    };
    ui?: ConnectorUiSpec;
    auth?: ConnectorAuth;
    parametersSchema?: DataSchema;
    data?: ConnectorDataSpec;
    udms?: string[];
    udm?: Record<string, ConnectorUdmSpec>;
    operations?: ConnectorOperationHandler[];
    test?: ConnectorMethodImplementation;
    hasReadme?: boolean;
    appUuid?: string;
    knowledgeBaseUuid?: string;
    workspaceId?: string;
}
type MinimalConnector = {
    id: string;
    key: string;
    name: string;
    logoUri: string;
};

declare const CONNECTOR_AUTH_TYPES: readonly ["integration-app-token", "oauth2", "oauth1", "client-credentials", "proxy"];
type ConnectorAuthType = (typeof CONNECTOR_AUTH_TYPES)[number];
type ConnectorAuthSpec = {
    title?: string;
    description?: string;
    type: ConnectorAuthType;
    ui?: {
        schema?: DataSchema;
        helpUri?: string;
    };
};
interface ConnectorAuthHandlerBase extends ConnectorAuthSpec {
    title?: string;
    type: ConnectorAuthType;
    credentialsSchema?: DataSchema;
    customCredentialsSchema?: DataSchema;
    makeApiClient?: ConnectorMethodImplementationBase;
    refreshCredentials?: ConnectorMethodImplementationBase;
    test?: ConnectorMethodImplementationBase;
    enabled?: any;
}
interface ConnectorAuthMethodArgs {
    connectorSpec?: ConnectorSpec;
    authOptionKey?: string;
}
interface ConnectorAuthMethodType {
    authTypes?: ConnectorAuthType[];
    fileKeys?: string[];
    getInputSchema?: (args: ConnectorAuthMethodArgs) => DataSchema | undefined;
    getOutputSchema?: (args: ConnectorAuthMethodArgs) => DataSchema | undefined;
    supportedImplementationTypes: ConnectorMethodImplementationType[];
    isRequired: boolean;
}
declare const ConnectorAuthMethodTypes: Record<string, ConnectorAuthMethodType>;
interface ConnectorAuthOAuth2 extends ConnectorAuthHandlerBase {
    type: 'oauth2';
    getOAuthConfig?: ConnectorMethodImplementation;
    getTokenData?: ConnectorMethodImplementation;
    getCredentialsFromAccessTokenResponse?: ConnectorMethodImplementation;
    getCredentialsFromRefreshTokenResponse?: ConnectorMethodImplementation;
    oAuthConfig?: ConnectorMethodImplementation;
}
interface ConnectorAuthOAuth1 extends ConnectorAuthHandlerBase {
    type: 'oauth1';
    getOAuthConfig?: ConnectorMethodImplementation;
}
interface ConnectorAuthClientCredentials extends ConnectorAuthHandlerBase {
    type: 'client-credentials';
    getCredentialsFromConnectionParameters?: ConnectorMethodImplementationBase;
}
interface ConnectorAuthProxy extends ConnectorAuthHandlerBase {
    type: 'proxy';
    proxyKey: string;
}
interface ConnectorAuthIntegrationAppToken extends ConnectorAuthHandlerBase {
    type: 'integration-app-token';
}
type ConnectorAuth = (ConnectorAuthOAuth2 | ConnectorAuthOAuth1 | ConnectorAuthClientCredentials | ConnectorAuthIntegrationAppToken | ConnectorAuthProxy) & {
    options?: {
        [key: string]: ConnectorAuthOAuth2 | ConnectorAuthOAuth1 | ConnectorAuthClientCredentials | ConnectorAuthIntegrationAppToken | ConnectorAuthProxy;
    };
};
interface ConnectorAuthOAuth2Config {
    clientId: any;
    clientSecret: any;
    authorizeUri: any;
    tokenUri: any;
    scopes?: any;
    clientAuthLocation?: 'body' | 'headers';
    noRefreshToken?: boolean;
    skipPkce?: boolean;
    skipClientAuthInBody?: boolean;
    skipClientAuthInHeaders?: boolean;
    extra?: Record<string, any>;
}
type ConnectorAuthOAuthConfig = ConnectorAuthOAuth2Config;
interface ConnectorAuthOAuth1Config {
    consumerKey: any;
    consumerSecret: any;
    requestTokenUri: any;
    authorizeUri: any;
    tokenUri: any;
    extra?: Record<string, any>;
}
declare const OAUTH_CONFIG_SCHEMA: {
    type: string;
    properties: {
        clientId: {
            type: string;
        };
        clientSecret: {
            type: string;
        };
        authorizeUri: {
            type: string;
            description: string;
        };
        tokenUri: {
            type: string;
            description: string;
        };
        scopes: {
            type: string;
            items: {
                type: string;
            };
        };
        clientAuthLocation: {
            type: string;
            enum: string[];
            default: string;
            description: string;
        };
        noRefreshToken: {
            type: string;
            description: string;
        };
        skipPkce: {
            type: string;
            description: string;
        };
        extra: {
            type: string;
            additionalProperties: boolean;
            description: string;
        };
        skipClientAuthInBody: {
            type: string;
            description: string;
        };
        skipClientAuthInHeader: {
            type: string;
            description: string;
        };
    };
};
declare const OAUTH1_CONFIG_SCHEMA: {
    type: string;
    properties: {
        consumerKey: {
            type: string;
        };
        consumerSecret: {
            type: string;
        };
        requestTokenUri: {
            type: string;
        };
        authorizeUri: {
            type: string;
        };
        tokenUri: {
            type: string;
        };
        scopes: {
            type: string;
            items: {
                type: string;
            };
        };
        extra: {
            type: string;
            additionalProperties: boolean;
            description: string;
        };
    };
};

declare const CONNECTOR_DATA_DIR = "data";
declare const CONNECTOR_OPERATIONS_DIR = "operations";
declare const CONNECTOR_DOCS_DIR = "docs";
declare const CONNECTOR_GLOBAL_WEBHOOKS_DIR = "global-webhooks";
declare const CONNECTOR_EVENTS_DIR = "events";

declare const DATA_RECORD_SCHEMA: DataSchema;
declare function makeDataRecordSchema({ fieldsSchema, udm, rawFieldsSchema, }: {
    fieldsSchema?: DataSchema;
    udm?: string;
    rawFieldsSchema?: DataSchema;
}): DataSchema;

interface OpenapiMapping {
    path: string;
    method: string;
    requestMapping: {
        pathParameters?: any;
        query?: any;
        data?: any;
        headers?: any;
    };
    responseMapping?: any;
}

interface ConnectorGlobalWebhookHandler {
    key: string;
    methods: {
        handle: ConnectorMethodImplementation;
    };
}
interface ConnectorGlobalWebhookSpec {
    key: string;
}
interface ConnectorGlobalWebhookHandleRequest {
    query: Record<string, string>;
    data: any;
    headers: Record<string, string>;
    parameters: unknown;
}
interface ConnectorGlobalWebhookHandleResponse {
    events: Array<{
        payload: any;
        selector: string;
    }>;
    response: {
        headers: Record<string, string>;
        data: any;
    };
}
interface ConnectorGlobalWebhookListItem {
    key: string;
    name: string;
    description?: string;
    uri?: string;
}

declare enum ConnectorEventImplementationType {
    GlobalWebhook = "global-webhook",
    Webhook = "webhook"
}
interface ConnectorEventHandlerMethodSpec {
    supportedImplementationTypes: ConnectorMethodImplementationType[];
    isRequired: boolean;
}
declare const ConnectorEventHandlerMethods: Record<ConnectorEventImplementationType, Record<string, ConnectorEventHandlerMethodSpec>>;
interface ConnectorEventHandler {
    key: string;
    name: string;
    description?: string;
    parametersSchema?: DataSchema;
    implementationType: ConnectorEventImplementationType;
    schema?: DataSchema;
    methods: Record<string, ConnectorMethodImplementation>;
}
interface ConnectorEventSpec {
    key: string;
    name: string;
    description?: string;
    parametersSchema?: DataSchema;
    schema?: DataSchema;
}
interface ConnectorEventListItem {
    key: string;
    name: string;
}
interface ConnectorEventGlobalWebhookGetEventSelectorResponse {
    globalWebhookKey: string;
    globalWebhookEventSelector: string;
}

interface OpenConfigurationOptions {
    onClose?: () => void;
    showPoweredBy?: boolean;
}

interface Integration {
    id: string;
    name: string;
    key: string;
    state?: WorkspaceElementState;
    errors?: ErrorData[];
    logoUri: string;
    connectorId?: string;
    connectorVersion?: string;
    authOptions?: IntegrationAuthOption[];
    oAuthCallbackUri?: string;
    parametersSchema?: DataSchema;
    parameters?: any;
    baseUri: string;
    connection?: Connection;
    archivedAt?: string;
    areParametersCustomized?: boolean;
    spec?: ConnectorSpec;
    hasMissingParameters?: boolean;
    hasDefaultParameters?: boolean;
    hasDocumentation?: boolean;
    hasOperations?: boolean;
    hasData?: boolean;
    hasEvents?: boolean;
    hasGlobalWebhooks?: boolean;
    hasUdm?: boolean;
    isTest?: boolean;
    appUuid?: string;
    isDeactivated?: boolean;
    authType?: ConnectorAuthType;
}
type IntegrationAuthOption = ConnectorAuthSpec & {
    key: string;
};
type AppliedToIntegrations<Element> = {
    element: Element;
    integration: Integration;
}[];

interface CreateIntegrationRequest {
    name?: string;
    key: string;
    baseUri: string;
    logoUri: string;
}
interface UpdateIntegrationRequest {
    name?: string;
    key?: string;
    baseUri?: string;
    logoUri?: string;
}
interface FindIntegrationsQuery extends PaginationQuery, SearchQuery {
}
interface FindIntegrationsResponse extends PaginationResponse<Integration> {
}
interface OpenNewConnectionOptions extends OpenConfigurationOptions {
    allowMultipleConnections?: boolean;
    name?: string;
}

type CreateCustomerRequest = {
    name?: string;
    internalId: string;
    fields?: any;
    credentials?: any;
};
type UpdateCustomerRequest = {
    name?: string;
    internalId?: string;
    fields?: any;
    credentials?: any;
};
type FindCustomersQuery = PaginationQuery & SearchQuery & {
    isTest?: boolean;
};
type CustomerSelector = {
    id: string;
};
type CreateUserRequest = CreateCustomerRequest;
type UpdateUserRequest = UpdateCustomerRequest;
type FindUsersQuery = FindCustomersQuery;
type UserSelector = CustomerSelector;

declare class CustomersAccessor extends ElementListAccessor<Customer, FindCustomersQuery, CreateCustomerRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class CustomerAccessor extends ElementAccessor<Customer, UpdateCustomerRequest, CustomerSelector> {
    constructor(client: IntegrationAppApiClient, selector: CustomerSelector | string);
}

type Customer = {
    id: string;
    name: string;
    internalId: string;
    fields?: Record<string, any>;
    credentials?: any;
    lastActiveAt?: string;
    isTest?: boolean;
    isBillable?: boolean;
};
type User = Customer;

interface ListFlowsForIntegrationQuery extends CommonListElementsQuery {
    universalFlowId?: string | 'null';
}
interface FindFlowsQuery extends ListFlowsForIntegrationQuery {
    integrationId?: string | 'null';
}
interface CreateFlowNodeRequest {
    type: string;
    config?: any;
    ui?: any;
    links?: FlowNodeLink[];
}
interface CreateFlowRequest {
    key: string;
    name: string;
    integrationId?: string;
    nodes?: Record<string, CreateFlowNodeRequest>;
    parametersSchema?: DataSchema;
    autoCreateInstances?: boolean;
}
interface UpdateFlowRequest extends CreateFlowRequest {
    archivedAt?: string;
}
interface FlowSelector extends IntegrationSpecificElementSelector {
    autoCreate?: boolean;
}
type ListFlowInstancesForConnectionQuery = CommonInstancesListQuery & {
    flowId?: string;
    flowKey?: string;
    enabled?: boolean;
};
type FindFlowInstancesQuery = ListFlowInstancesForConnectionQuery & CommonIntegrationOrConnectionQuery;
interface FlowInstanceSelector extends ConnectionSelector, ElementInstanceSelector {
    flowId?: string;
    flowKey?: string;
    instanceKey?: string;
    autoUpdate?: boolean;
}
interface ResetFlowInstanceOptions {
    name?: boolean;
    nodes?: Record<string, boolean>;
    allNodes?: boolean;
}
interface RunFlowOptions {
    nodeKey?: string;
    input?: any;
    returnImmediately?: boolean;
    onUpdate?: (...args: any) => void;
}

interface ListFieldMappingsForIntegrationQuery extends CommonListElementsQuery {
    universalFieldMappingId?: string | 'null';
}
interface FindFieldMappingsQuery extends ListFieldMappingsForIntegrationQuery {
    integrationId?: string | 'null';
}
type ListFieldMappingInstancesForConnectionQuery = CommonInstancesListQuery & {
    fieldMappingId?: string;
    universalFieldMappingId?: string;
    dataSourceInstanceId?: string;
};
type FindFieldMappingInstancesQuery = ListFieldMappingInstancesForConnectionQuery & CommonIntegrationOrConnectionQuery;
interface UpdateFieldMappingRequest {
    key?: string;
    name?: string;
    dataSourceKey?: string;
    dataSourceId?: string;
    appSchema?: DataSchema;
    direction?: FieldMappingDirection;
    defaultImportValue?: any;
    exportValue?: any;
    importValue?: any;
    defaultExportValue?: any;
    frozenImportFields?: any;
    frozenExportFields?: any;
    frozenUnifiedExportFields?: any;
    archivedAt?: string;
}
interface CreateFieldMappingRequest extends UpdateFieldMappingRequest {
    key: string;
    name: string;
    integrationId?: string;
}
interface CreateFieldMappingInstanceRequest {
    connectionId: string;
    fieldMappingId?: string;
    instanceKey?: string;
    importValue?: any;
    exportValue?: any;
}
interface UpdateFieldMappingInstanceRequest {
    importValue?: any;
    exportValue?: any;
}
interface FieldMappingInstanceSelector extends ConnectionSelector, FlowInstanceSelector, ElementInstanceSelector {
    fieldMappingKey?: string;
    fieldMappingId?: string;
    instanceKey?: string;
    nodeKey?: string;
}
interface FieldMappingSelector extends IntegrationSpecificElementSelector {
}

type InstanceKeyQuery = {
    instanceKey?: string;
};

declare class ConnectionLevelElementAccessor<Element, UpdateElement> {
    protected client: IntegrationAppApiClient;
    protected connectionSelector: string;
    protected selector: string;
    protected elementKey: string;
    protected query: Record<string, any>;
    protected endpoint: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, selector: string, elementKey: string, query: Record<string, any>);
    protected uri(path?: string, query?: {}): string;
    getUniqueIdentifier(): string;
    get(query?: {
        autoCreate?: boolean;
    }): Promise<Element>;
    create(): Promise<Element>;
    patch(data: Partial<UpdateElement>): Promise<Element>;
    put(data: UpdateElement): Promise<Element>;
    archive(): Promise<void>;
    reset(): Promise<Element>;
    setup(): Promise<Element>;
}
declare class ConnectionLevelElementsListAccessor<Element, Query> {
    protected client: IntegrationAppApiClient;
    protected connectionSelector: string;
    protected elementKey: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, elementKey: string);
    list(query?: Query): Promise<PaginationResponse<Element[]>>;
}

declare class IntegrationLevelElementAccessor<Element, UpdateElementData> {
    protected client: IntegrationAppApiClient;
    protected integrationSelector: string;
    protected elementSelector: string;
    protected elementKey: string;
    protected endpoint: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, elementSelector: string, elementKey: string);
    getUniqueIdentifier(): string;
    get(): Promise<Element>;
    patch(data: Partial<UpdateElementData>): Promise<Element>;
    put(data: UpdateElementData): Promise<Element>;
    archive(): Promise<void>;
    reset(): Promise<Element>;
}
declare class IntegrationLevelElementsListAccessor<Element, Query, CreateElementData> {
    protected client: IntegrationAppApiClient;
    protected integrationSelector: string;
    protected elementKey: string;
    protected endpoint: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, elementKey: string);
    list(query?: Query): Promise<Element[]>;
    create(data: CreateElementData): Promise<Element>;
}

interface OpenFieldMappingInstanceConfigurationOptions extends OpenConfigurationOptions {
}
declare class FieldMappingsAccessor extends ElementListAccessor<FieldMapping, FindFieldMappingsQuery, CreateFieldMappingRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class FieldMappingAccessor extends ElementAccessor<FieldMapping, UpdateFieldMappingRequest, FieldMappingSelector> {
    constructor(client: IntegrationAppApiClient, selector: string | FieldMappingSelector);
    getAppSchema(): Promise<any>;
    apply(integrationKeys: string[]): Promise<FieldMapping[]>;
    reset(): Promise<any>;
}
declare class FieldMappingInstancesAccessor extends ElementInstanceListAccessor<FieldMappingInstance, FindFieldMappingInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class FieldMappingInstanceAccessor extends ElementInstanceAccessor<FieldMappingInstance, FieldMappingInstanceSelector, CreateFieldMappingInstanceRequest, UpdateFieldMappingInstanceRequest> {
    private client;
    constructor(client: IntegrationAppApiClient, selector: string | FieldMappingInstanceSelector);
    setup(): Promise<void>;
    reset(): Promise<void>;
    openConfiguration({ onClose, }?: OpenFieldMappingInstanceConfigurationOptions): Promise<void>;
}
declare class IntegrationLevelFieldMappingAccessor extends IntegrationLevelElementAccessor<FieldMapping, UpdateFieldMappingRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    fieldMappingSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, fieldMappingSelector: string);
}
declare class IntegrationLevelFieldMappingsListAccessor extends IntegrationLevelElementsListAccessor<FieldMapping, ListFieldMappingsForIntegrationQuery, Omit<CreateFieldMappingRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelFieldMappingAccessor extends ConnectionLevelElementAccessor<FieldMappingInstance, UpdateFieldMappingInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    fieldMappingSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, fieldMappingSelector: string, query: InstanceKeyQuery);
    openConfiguration({ onClose, }?: OpenFieldMappingInstanceConfigurationOptions): Promise<void>;
}
declare class ConnectionLevelFieldMappingsAccessor extends ConnectionLevelElementsListAccessor<FieldMapping, ListFieldMappingInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

declare function mergeWithFormulas(a: any, b: any): any;
declare function isObject(value: any): boolean;

interface FieldMappingUnitConfig {
    key?: string;
    input?: any;
    includeRawFields?: any;
    importValue?: any;
    exportValue?: any;
    default?: any;
    defaultUnifiedValue?: any;
    defaultValue?: any;
    appSchema?: DataSchema;
}

declare enum FieldMappingDirection {
    IMPORT = "import",
    EXPORT = "export",
    BOTH = "both"
}
interface FieldMapping {
    id: string;
    name: string;
    key: string;
    revision: string;
    publishedRevision?: string;
    universalFieldMappingId?: string;
    universalFieldMappingRevision?: string;
    integrationId?: string;
    integration?: Integration;
    dataSourceId: string;
    dataSourceKey: string;
    appSchema: DataSchema;
    direction: FieldMappingDirection;
    defaultImportValue?: any;
    defaultExportValue?: any;
    importValue?: any;
    exportValue?: any;
    frozenImportFields?: any;
    frozenExportFields?: any;
    frozenUnifiedExportFields?: any;
    archivedAt?: string;
    customized?: boolean;
    appliedToIntegrations?: AppliedToIntegrations<FieldMapping>;
}
interface FieldMappingInstance {
    id: string;
    name?: string;
    userId: string;
    revision: string;
    user?: User;
    connectionId: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    fieldMappingRevision?: string;
    fieldMappingId?: string;
    fieldMapping?: FieldMapping;
    instanceKey?: string;
    dataSourceInstanceId?: string;
    dataSourceInstance?: DataSourceInstance;
    dataSourceSchema?: DataSchema;
    direction?: FieldMappingDirection;
    appSchema?: DataSchema;
    importValue?: any;
    exportValue?: any;
    isCustomized?: boolean;
    unifiedExportValue?: any;
    unifiedImportValue?: any;
    frozenImportFields?: string[];
    frozenExportFields?: string[];
    error?: ErrorData;
    externalSchema?: any;
}

interface OpenIntegrationUIIntegrationConfigurationOptions extends OpenConfigurationOptions {
}
declare class IntegrationsAccessor extends ElementListAccessor<Integration, FindIntegrationsQuery, CreateIntegrationRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class IntegrationAccessor extends ElementAccessor<Integration, UpdateIntegrationRequest> {
    private client;
    private integrationSelector;
    baseUri: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
    get actions(): IntegrationLevelActionsListAccessor;
    action(actionSelector: string): IntegrationLevelActionAccessor;
    get flows(): IntegrationLevelFlowsListAccessor;
    flow(flowSelector: string): IntegrationLevelFlowAccessor;
    get dataSources(): IntegrationLevelDataSourcesListAccessor;
    dataSource(dataSourceSelector: string): IntegrationLevelDataSourceAccessor;
    get fieldMappings(): IntegrationLevelFieldMappingsListAccessor;
    fieldMapping(fieldMappingSelector: string): IntegrationLevelFieldMappingAccessor;
    setup(): Promise<Integration>;
    resetParameters(): Promise<Integration>;
    getConnectorSpec(): Promise<ConnectionSpec>;
    open({ onClose, }?: OpenIntegrationUIIntegrationConfigurationOptions): Promise<void>;
    openNewConnection({ allowMultipleConnections, name, }?: OpenNewConnectionOptions): Promise<Connection>;
    connect({ name, parameters, authOptionKey, allowMultipleConnections, redirectUri, sameWindow, }?: {
        name?: string;
        parameters?: any;
        authOptionKey?: string;
        allowMultipleConnections?: boolean;
    } & ({
        sameWindow: true;
        redirectUri: string;
    } | {
        sameWindow?: false;
        redirectUri?: never;
    })): Promise<Connection | undefined>;
    createConnection({ parameters, name, }: {
        parameters?: any;
        name?: string;
    }): Promise<Connection | undefined>;
    disconnect(): Promise<void>;
    getOperations(): Promise<OperationListItem[]>;
    getOperation(key: string): Promise<OperationSpec>;
    getDataCollections(): Promise<DataLocationListItem[]>;
    getDataCollection(key: string): Promise<DataLocationSpec>;
    getDataLocations(): Promise<DataLocationListItem[]>;
    getDataLocation(key: string): Promise<DataLocationSpec>;
}

declare enum FlowNodeRunStatus {
    COMPLETED = "completed",
    FAILED = "failed",
    SKIPPED = "skipped"
}
interface FlowNodeHandlerRunResponse {
    status?: FlowNodeRunStatus;
    output?: any;
    outputFileUri?: string;
    errors?: ErrorData[];
}
interface UpstreamFlowNodeRun {
    nodeKey: string;
    runId: string;
    outputId: string;
}
interface DownstreamFlowNodeRun {
    runId: string;
    nodeKey: string;
}
interface FlowNodeRunParameters {
    id: string;
    upstreamRuns: UpstreamFlowNodeRun[];
    input: any;
}
interface FlowNodeRunOutput {
    id: string;
    data: string;
    downstreamRuns: DownstreamFlowNodeRun[];
}
interface FlowNodeRunResult {
    status: FlowNodeRunStatus;
    logs: any[];
    outputs: FlowNodeRunOutput[];
    outputFileUri?: string;
    errors: ErrorData[];
}
interface FlowNodeRunRecord extends FlowNodeRunParameters, FlowNodeRunResult {
}
type FlowNodeRunRecordWithoutOutputsData = FlowNodeRunRecord & {
    outputs: Omit<FlowNodeRunOutput, 'data'>[];
};
type FlowNodeRunOutputWithoutDownstreamRuns = Omit<FlowNodeRunOutput, 'downstreamRuns'>;

declare class FlowRunsAccessor {
    private readonly client;
    constructor(client: IntegrationAppApiClient);
    find(query: FindFlowRunsQuery): Promise<FindFlowRunsResponse>;
    create(request: CreateFlowRunRequest): Promise<FlowRun>;
}
declare class FlowRunAccessor {
    private readonly client;
    id: string;
    private baseUri;
    constructor(client: IntegrationAppApiClient, id: string);
    get(): Promise<FlowRun>;
    stop(): Promise<void>;
    getOutput(): Promise<any>;
    getNodeRuns(nodeKey: string, parameters?: {
        cursor?: string;
    }): Promise<any>;
    getNodeRun(nodeKey: string, runId: string): Promise<any>;
    getNodeOutputs(nodeKey: string, parameters?: {
        cursor?: string;
    }): Promise<any>;
    getNodeOutput(nodeKey: string, outputId: string): Promise<any>;
    repeat(): Promise<FlowRun>;
}

declare enum FlowRunState {
    QUEUED = "queued",
    RUNNING = "running",
    COMPLETED = "completed",
    STOPPED = "stopped",
    FAILED = "failed"
}
declare enum FlowRunNodeState {
    RUNNING = "running",
    COMPLETED = "completed",
    STOPPED = "stopped",
    FAILED = "failed"
}
declare enum FlowRunLaunchedByTrigger {
    ApiTrigger = "api-trigger",
    ScheduleTrigger = "schedule-trigger",
    AppEventTrigger = "app-event-trigger",
    DataSourceTrigger = "data-source-trigger",
    ExternalEvent = "external-event"
}
interface FlowRun {
    id: string;
    flowInstanceId: string;
    flowInstance?: FlowInstance;
    universalFlowId?: string;
    connectionId?: string;
    connection?: Connection;
    integrationId?: string;
    integration?: Integration;
    startNodeKey: string;
    userId: string;
    user?: Customer;
    input?: any;
    state: FlowRunState;
    startTime: string;
    endTime?: string;
    errors?: ErrorData[];
    nodes?: Record<string, FlowRunNode>;
    launchedBy?: FlowRunLaunchedBy;
}
interface FlowRunNode {
    state: FlowRunNodeState;
    runs?: number;
    erroredRuns?: number;
    outputs?: number;
}
interface FlowRunLaunchedBy {
    type: FlowRunLaunchedByTrigger;
    ids?: string[];
}
interface CreateFlowRunRequest {
    flowInstanceId: string;
    nodeKey?: string;
    input?: any;
}
interface FindFlowRunsQuery extends PaginationQuery {
    id?: string;
    flowInstanceId?: string;
    startNodeKey?: string;
    flowId?: string;
    universalFlowId?: string;
    userId?: string;
    state?: FlowRunState;
    integrationId?: string;
    connectionId?: string;
    startedAfter?: string;
}
interface FindFlowRunsResponse extends PaginationResponse<FlowRun> {
}

declare const createFlowInstanceSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    userId: z.ZodOptional<z.ZodString>;
    flowId: z.ZodOptional<z.ZodString>;
    connectionId: z.ZodOptional<z.ZodString>;
    integrationId: z.ZodOptional<z.ZodString>;
    instanceKey: z.ZodOptional<z.ZodString>;
    parameters: z.ZodOptional<z.ZodAny>;
    nodes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        name: z.ZodOptional<z.ZodString>;
        type: z.ZodOptional<z.ZodString>;
        userConfig: z.ZodOptional<z.ZodAny>;
        config: z.ZodOptional<z.ZodAny>;
        onError: z.ZodOptional<z.ZodEnum<["stop", "continue"]>>;
        concurrency: z.ZodOptional<z.ZodNumber>;
        ui: z.ZodOptional<z.ZodAny>;
        links: z.ZodOptional<z.ZodArray<z.ZodObject<{
            key: z.ZodOptional<z.ZodString>;
            filter: z.ZodOptional<z.ZodAny>;
            name: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }>, "many">>;
        isCustomized: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }>>>;
    enabled: z.ZodOptional<z.ZodBoolean>;
    customized: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodBoolean>;
        nodes: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    name?: string | undefined;
    userId?: string | undefined;
    integrationId?: string | undefined;
    connectionId?: string | undefined;
    parameters?: any;
    flowId?: string | undefined;
    instanceKey?: string | undefined;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
}, {
    name?: string | undefined;
    userId?: string | undefined;
    integrationId?: string | undefined;
    connectionId?: string | undefined;
    parameters?: any;
    flowId?: string | undefined;
    instanceKey?: string | undefined;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
}>;
declare const updateFlowInstanceSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    enabled: z.ZodOptional<z.ZodBoolean>;
    parameters: z.ZodOptional<z.ZodAny>;
    nodes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        name: z.ZodOptional<z.ZodString>;
        type: z.ZodOptional<z.ZodString>;
        userConfig: z.ZodOptional<z.ZodAny>;
        config: z.ZodOptional<z.ZodAny>;
        onError: z.ZodOptional<z.ZodEnum<["stop", "continue"]>>;
        links: z.ZodOptional<z.ZodArray<z.ZodObject<{
            key: z.ZodOptional<z.ZodString>;
            filter: z.ZodOptional<z.ZodAny>;
            name: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }>, "many">>;
        concurrency: z.ZodOptional<z.ZodNumber>;
        isCustomized: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }>>>;
    archivedAt: z.ZodOptional<z.ZodString>;
    customized: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodBoolean>;
        nodes: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    name?: string | undefined;
    parameters?: any;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
    archivedAt?: string | undefined;
}, {
    name?: string | undefined;
    parameters?: any;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
    archivedAt?: string | undefined;
}>;
type CreateFlowInstanceRequest = z.infer<typeof createFlowInstanceSchema>;
type UpdateFlowInstanceRequest = z.infer<typeof updateFlowInstanceSchema>;

declare enum IntegrationElementLevel {
    UNIVERSAL = "universal",
    CONNECTOR = "connector",
    CONNECTION = "connection"
}
declare enum IntegrationElementType {
    APP_DATA_SCHEMA = "app-data-schema",
    APP_EVENT_TYPE = "app-event-type",
    DATA_SOURCE = "data-source",
    SCHEMA = "schema",
    FIELD_MAPPING = "field-mapping",
    FLOW = "flow",
    INTEGRATION = "integration",
    ACTION = "action",
    DATA_LINK_TABLE = "data-link-table",
    EXTERNAL_EVENT = "external-event"
}
interface ElementTemplateFields {
    id: string;
    key: string;
    name: string;
    revision: string;
    integrationId?: string;
    integration?: Integration;
    parentId?: string;
    parentRevision?: string;
    isCustomized?: boolean;
    createdAt?: string;
    updatedAt?: string;
    archivedAt?: string;
}
interface ElementInstanceFields {
    id: string;
    name: string;
    revision: string;
    parentId?: string;
    parentRevision?: string;
    universalParentId?: string;
    userId: string;
    user?: Customer;
    instanceKey?: string;
    isCustomized?: boolean;
    connectionId: string;
    connection?: Connection;
    integrationId?: string;
    integration?: Integration;
    dependencies?: IntegrationElementInstance[];
    errors?: ErrorData[];
    createdAt?: string;
    updatedAt?: string;
    archivedAt?: string;
}
interface IntegrationElement {
    type: IntegrationElementType;
    key?: string;
    id?: string;
    config?: any;
}
interface IntegrationElementInstance {
    type: IntegrationElementType;
    instanceId?: string;
    data?: any;
}
interface IntegrationElementInstanceDependency {
    fromType: IntegrationElementType;
    fromInstanceId: string;
    toType: IntegrationElementType;
    toInstanceId: string;
    data?: any;
}

interface FlowNode {
    type?: string;
    version?: number;
    name?: string;
    description?: string;
    config?: any;
    concurrency?: number;
    onError?: 'stop' | 'continue';
    ui?: any;
    inputSchema?: any;
    outputSchema?: any;
    outputExample?: any;
    links?: FlowNodeLink[];
    isCustomized?: boolean;
}
interface Flow {
    id: string;
    name: string;
    key: string;
    integrationId?: string;
    integration?: Integration;
    universalFlowId?: string;
    universalFlowRevision?: string;
    parametersSchema?: DataSchema;
    nodes?: Record<string, FlowNode>;
    autoCreateInstances?: boolean;
    archivedAt?: string;
    revision: string;
    customized?: boolean;
    appliedToIntegrations?: AppliedToIntegrations<Flow>;
    isDeployed?: boolean;
}
interface FlowInstance {
    id: string;
    userId: string;
    user?: User;
    connectionId?: string;
    connection?: Connection;
    flow?: Flow;
    flowId?: string;
    universalFlowId?: string;
    integrationId: string;
    integration?: Integration;
    instanceKey?: string;
    name: string;
    parameters?: any;
    parametersSchema?: DataSchema;
    nodes?: Record<string, FlowInstanceNode>;
    enabled: boolean;
    createdAt: string;
    updatedAt: string;
    dependencies?: IntegrationElementInstance[];
    state?: WorkspaceElementState;
    outdated?: boolean;
    customized?: {
        name?: boolean;
        nodes?: boolean;
    };
}
declare enum FlowInstanceNodeState {
    SETTING_UP = "SETTING_UP",
    SETUP_FAILED = "SETUP_FAILED",
    READY = "READY"
}
interface FlowInstanceNode extends FlowNode {
    state?: FlowInstanceNodeState;
    errors?: ErrorData[];
    userConfig?: any;
    testInput?: any;
    dependencies?: IntegrationElementInstance[];
}
interface FlowNodeLink {
    key?: string;
    filter?: any;
    name?: string;
}

interface OpenFlowInstanceConfigurationOptions extends OpenConfigurationOptions {
    nodeKey?: string;
}
interface OpenFlowInstanceEditorOptions extends OpenConfigurationOptions {
}
declare class FlowsAccessor extends ElementListAccessor<Flow, FindFlowsQuery, CreateFlowRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class FlowAccessor extends ElementAccessor<Flow, UpdateFlowRequest, FlowSelector> {
    constructor(client: IntegrationAppApiClient, selector: FlowSelector | string);
    apply(integrationKeys: string[]): Promise<Flow[]>;
    reset(): Promise<Flow>;
}
declare class FlowInstancesAccessor extends ElementInstanceListAccessor<FlowInstance, FindFlowInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
    create(data: CreateFlowInstanceRequest): Promise<FlowInstance>;
}
declare class FlowInstanceAccessor extends ElementInstanceAccessor<FlowInstance, FlowInstanceSelector, CreateFlowInstanceRequest, UpdateFlowInstanceRequest> {
    protected client: IntegrationAppApiClient;
    protected selector: FlowInstanceSelector | string;
    constructor(client: IntegrationAppApiClient, selector: FlowInstanceSelector | string);
    enable(): Promise<FlowInstance>;
    disable(): Promise<FlowInstance>;
    updateToLatestFlow(): Promise<FlowInstance>;
    setup(): Promise<FlowInstance>;
    reset(options?: ResetFlowInstanceOptions): Promise<FlowInstance>;
    openConfiguration({ nodeKey, onClose, }?: OpenFlowInstanceConfigurationOptions): Promise<void>;
    openEditor({ onClose }?: OpenFlowInstanceEditorOptions): Promise<void>;
    startRun(options?: RunFlowOptions): Promise<FlowRun>;
    run(options?: RunFlowOptions): Promise<FlowRun>;
}
declare class IntegrationLevelFlowAccessor extends IntegrationLevelElementAccessor<Flow, UpdateFlowRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    flowSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, flowSelector: string);
}
declare class IntegrationLevelFlowsListAccessor extends IntegrationLevelElementsListAccessor<Flow, ListFlowsForIntegrationQuery, Omit<CreateFlowRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelFlowAccessor extends ConnectionLevelElementAccessor<FlowInstance, UpdateFlowInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    flowSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, flowSelector: string, query: InstanceKeyQuery);
    enable(): Promise<FlowInstance>;
    disable(): Promise<FlowInstance>;
    run(options: {
        nodeKey?: string;
        input?: any;
    }): Promise<FlowRun>;
    openConfiguration(options?: OpenFlowInstanceConfigurationOptions): Promise<void>;
    openEditor(options?: OpenFlowInstanceEditorOptions): Promise<void>;
}
declare class ConnectionLevelFlowsAccessor extends ConnectionLevelElementsListAccessor<Flow, ListFlowInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

interface FlowNodeSpec {
    name: string;
    description: string;
    isTrigger?: boolean;
    requiresIntegration?: boolean;
    requiresDataSpec?: boolean;
    isDeprecated?: boolean;
    isHidden?: boolean;
    direction?: FieldMappingDirection;
    version?: number;
    getSubFlowRootNodeKey?: (node: FlowNode) => string;
}
declare class FlowNodeSpec implements FlowNodeSpec {
    constructor(args: FlowNodeSpec);
}

declare enum FlowNodeType {
    ApiTrigger = "api-trigger",
    ScheduleTrigger = "schedule-trigger",
    AppEventTrigger = "app-event-trigger",
    DataRecordCreatedTrigger = "data-record-created-trigger",
    DataRecordUpdatedTrigger = "data-record-updated-trigger",
    DataRecordDeletedTrigger = "data-record-deleted-trigger",
    ConnectorEventTrigger = "connector-event-trigger",
    SearchDataRecords = "search-data-records",
    ListDataRecords = "list-data-records",
    FindOrCreateDataRecord = "find-or-create-data-record",
    LookupDataRecord = "lookup-data-record",
    FindDataRecordById = "find-data-record-by-id",
    CreateDataRecord = "create-data-record",
    UpdateDataRecord = "update-data-record",
    DeleteDataRecord = "delete-data-record",
    CreateDataLink = "create-data-link",
    FindDataLink = "find-data-link",
    DeleteDataLink = "delete-data-link",
    TransformData = "transform-data",
    Filter = "filter",
    ForEachV2 = "for-each-v2",
    RunJavascript = "run-javascript",
    IntegrationSpecificOperation = "integration-specific-operation",
    ApiRequestToYourApp = "api-request-to-your-app",
    ApiRequestToExernalApp = "api-request-to-external-app",
    CustomHttpRequest = "custom-http-request",
    RunAction = "run-action",
    ApiRequest = "api-request",
    CustomApiRequest = "custom-api-request",
    HttpRequest = "http-request",
    ForEach = "for-each",
    FindDataRecords = "find-data-records"
}
declare const FLOW_NODE_SPECS: Record<FlowNodeType, FlowNodeSpec>;

declare function getFlowNode(flow: Flow | FlowInstance, nodeKey: string): FlowNode;
declare function getFlowNodeTitle(flow: Flow | FlowInstance, nodeKey: string): string | undefined;
declare function getFlowNodeDescription(flow: Flow | FlowInstance, nodeKey: string): string | undefined;
declare function getFlowNodeSpec(node: FlowNode): FlowNodeSpec;
declare function getFlowInstanceNodeDependency({ dependencies }: Omit<FlowInstanceNode, 'errors'>, type: IntegrationElementType): IntegrationElementInstance | undefined;
declare function getRootNodeKeys({ nodes, }: {
    nodes?: Record<string, FlowNode>;
}): string[];
declare function getChildNodeKeys(flow: Flow | FlowInstance, nodeKey: string): string[];
declare function getDownstreamNodeKeys(flow: Flow | FlowInstance, nodeKey: string): string[];
declare function getParentNodeKeys(flow: Flow | FlowInstance, nodeKey: string): string[];
declare function getUpstreamNodeKeys(flow: Flow | FlowInstance, nodeKey: string): string[];
declare function hasCycles(nodes?: Record<string, FlowNode>): boolean;

interface ListDataSourcesForIntegrationQuery extends PaginationQuery {
    universalDataSourceId?: string | 'null';
}
interface FindDataSourcesQuery extends ListDataSourcesForIntegrationQuery {
    integrationId?: string | 'null';
}
type CreateDataSourceRequest = {
    key: string;
    name: string;
    integrationId?: string;
    udm?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    rootPath?: string;
    defaultPath?: string;
    collectionKey?: string;
    collectionParameters?: any;
};
type UpdateDataSourceRequest = {
    key?: string;
    name?: string;
    archivedAt?: string;
    udm?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    rootPath?: string;
    defaultPath?: string;
};
interface DataSourceInstanceSelector extends ConnectionSelector, FlowInstanceSelector, ElementInstanceSelector {
    dataSourceKey?: string;
    dataSourceId?: string;
    instanceKey?: string;
    nodeKey?: string;
    udm?: string;
}
interface FindDataSourceInstancesQuery extends PaginationQuery {
    userId?: string;
    dataSourceId?: string;
    universalDataSourceId?: string;
    connectionId?: string;
    integrationKey?: string;
    integrationId?: string;
}
type FindDataSourceInstancesResponse = PaginationResponse<DataSourceInstance>;
interface CreateDataSourceInstanceRequest {
    dataSourceId: string;
    connectionId: string;
    path?: string;
}
interface UpdateDataSourceInstanceRequest {
    path?: string;
    collectionKey?: string;
    collectionParameters?: any;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    subscribedTo?: {
        created?: boolean;
        updated?: boolean;
        deleted?: boolean;
    };
}
interface FindDataSourceEventsQuery extends PaginationQuery {
    userId?: string;
    udm?: string;
    dataSourceInstanceId?: string;
    startDatetime?: string;
    endDatetime?: string;
}
interface FindDataSourceSyncsQuery extends PaginationQuery {
    userId?: string;
    dataSourceId?: string;
    dataSourceInstanceId?: string;
    integrationId?: string;
    connectionId?: string;
    startedAfter?: string;
}
type ListDataSourceInstancesForConnectionQuery = PaginationQuery & {
    dataSourceId?: string;
};
interface FindDataSourceInstanceSyncsQuery extends ListDataSourceInstancesForConnectionQuery {
    userId?: string;
    connectionId?: string;
    integrationId?: string;
    dataSourceInstanceId?: string;
}

interface OpenDataSourceConfigurationOptions extends OpenConfigurationOptions {
}
declare class DataSourcesAccessor extends ElementListAccessor<DataSource, FindDataSourcesQuery, CreateDataSourceRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataSourceAccessor extends ElementAccessor<DataSource, UpdateDataSourceRequest, DataSourceSelector> {
    constructor(client: IntegrationAppApiClient, selector: DataSourceSelector | string);
    apply(integrationKeys: string[]): Promise<DataSource[]>;
    reset(): Promise<any>;
}
declare class DataSourceInstancesAccessor extends ElementInstanceListAccessor<DataSourceInstance, FindDataSourceInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataSourceInstanceAccessor extends ElementInstanceAccessor<DataSourceInstance, DataSourceInstanceSelector, CreateDataSourceInstanceRequest, UpdateDataSourceInstanceRequest> {
    client: IntegrationAppApiClient;
    constructor(client: IntegrationAppApiClient, selector: string | DataSourceInstanceSelector);
    setup(): Promise<void>;
    reset(): Promise<void>;
    openConfiguration({ onClose, }?: OpenDataSourceConfigurationOptions): Promise<void>;
    unifiedFieldsToNative(unifiedFields: any): Promise<any>;
    getCollection(): Promise<DataCollectionSpec>;
    listRecords(request?: DataCollectionListRequest): Promise<DataCollectionListResponse>;
    matchRecord(request: DataCollectionMatchRequest): Promise<DataCollectionMatchResponse>;
    searchRecords(request: DataCollectionSearchRequest): Promise<DataCollectionSearchResponse>;
    findRecordById(request: string | DataCollectionFindByIdRequest): Promise<DataCollectionFindByIdResponse>;
    createRecord(request: DataCollectionCreateRequest): Promise<DataCollectionCreateResponse>;
    updateRecord(request: DataCollectionUpdateRequest): Promise<DataCollectionUpdateResponse>;
    deleteRecord(request: string | DataCollectionFindByIdRequest): Promise<DataCollectionDeleteResponse>;
    findRecords(request?: DataCollectionFindRequest): Promise<DataCollectionFindResponse>;
}
declare class IntegrationLevelDataSourceAccessor extends IntegrationLevelElementAccessor<DataSource, UpdateDataSourceRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    dataSourceSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, dataSourceSelector: string);
}
declare class IntegrationLevelDataSourcesListAccessor extends IntegrationLevelElementsListAccessor<DataSource, ListDataSourcesForIntegrationQuery, Omit<CreateDataSourceRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelDataSourceAccessor extends ConnectionLevelElementAccessor<DataSourceInstance, UpdateDataSourceInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    dataSourceSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, dataSourceSelector: string, query: InstanceKeyQuery);
    openConfiguration(options?: OpenDataSourceConfigurationOptions): Promise<void>;
}
declare class ConnectionLevelDataSourcesAccessor extends ConnectionLevelElementsListAccessor<DataSource, ListDataSourceInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

declare const DEFAULT_PULL_UPDATES_INTERVAL_SECONDS: number;
declare const DEFAULT_FULL_SYNC_INTERVAL_SECONDS: number;
declare const MIN_FULL_SYNC_INTERVAL_SECONDS: number;
declare const MIN_PULL_UPDATES_INTERVAL_SECONDS: number;

interface DataSourceUnitConfig {
    key?: string;
    collectionKey?: any;
    collectionParameters?: any;
    udm?: any;
    path?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
}
interface DataSource {
    id: string;
    key: string;
    name: string;
    revision: string;
    publishedRevision?: string;
    integrationId?: string;
    integration?: Integration;
    universalDataSourceId?: string;
    universalDataSourceRevision?: string;
    udm?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    collectionKey?: string;
    collectionParameters?: any;
    archivedAt?: string;
    createdAt?: string;
    updatedAt?: string;
    customized?: boolean;
    appliedToIntegrations?: AppliedToIntegrations<DataSource>;
    defaultPath?: string;
}
interface DataSourceInstance {
    id: string;
    userId: string;
    revision: string;
    user?: User;
    dataSourceRevision?: string;
    dataSourceId?: string;
    universalDataSourceId?: string;
    dataSource?: DataSource;
    udm?: string;
    connectionId: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    instanceKey?: string;
    collectionKey?: string;
    collectionParameters?: any;
    defaultCollectionKey?: string;
    defaultCollectionParameters?: any;
    collectionSpec?: DataCollectionSpec;
    isCustomized?: boolean;
    errors?: ErrorData[];
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    path?: string;
    defaultPath?: string;
}
interface DataSourceSelector extends IntegrationSpecificElementSelector {
}

declare class ConnectionsAccessor extends ElementInstanceListAccessor<Connection, FindConnectionsQuery> {
    constructor(client: IntegrationAppApiClient);
    create(data: CreateConnectionRequest): Promise<Connection>;
}
declare class ConnectionAccessor {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
    get actions(): ConnectionLevelActionsAccessor;
    action(actionSelector: string, query?: InstanceKeyQuery): ConnectionLevelActionAccessor;
    get flows(): ConnectionLevelFlowsAccessor;
    flow(flowSelector: string, query?: InstanceKeyQuery): ConnectionLevelFlowAccessor;
    get dataSources(): ConnectionLevelDataSourcesAccessor;
    dataSource(dataSourceSelector: string, query?: InstanceKeyQuery): ConnectionLevelDataSourceAccessor;
    get fieldMappings(): ConnectionLevelFieldMappingsAccessor;
    fieldMapping(fieldMappingSelector: string, query?: InstanceKeyQuery): ConnectionLevelFieldMappingAccessor;
    get(query?: {
        includeSecrets?: boolean;
    }): Promise<Connection>;
    patch(data: UpdateConnectionRequest): Promise<Connection>;
    put(data: UpdateConnectionRequest): Promise<Connection>;
    archive(): Promise<void>;
    request(path: string, data?: any): Promise<any>;
    get proxy(): ConnectionProxy;
    operation(key: string): ConnectionOperationAccessor;
    dataCollection(key: string, parameters?: Record<string, any>): ConnectionDataCollectionAccessor;
    dataDirectory(key: string, parameters?: Record<string, any>): ConnectionDataDirectoryAccessor;
    reconnect({ parameters, authOptionKey, }?: {
        parameters?: any;
        authOptionKey?: string;
    }): Promise<Connection | undefined>;
    openReconnectUI({}?: OpenConfigurationOptions): Promise<void>;
    refreshCredentials(): Promise<void>;
    getPath(subpath?: string, query?: Record<string, any>): string;
}
declare class ConnectionOperationAccessor {
    client: IntegrationAppApiClient;
    connectionAccessor: ConnectionAccessor;
    key: string;
    constructor(client: IntegrationAppApiClient, connectionAccessor: ConnectionAccessor, key: string);
    get(): Promise<OperationSpec>;
    run(request?: OperationRunRequest): Promise<OperationRunResponse>;
}
declare class ConnectionDataDirectoryAccessor {
    client: IntegrationAppApiClient;
    connectionAccessor: ConnectionAccessor;
    key: string;
    parameters: Record<string, any>;
    constructor(client: IntegrationAppApiClient, connectionAccessor: ConnectionAccessor, key: string, parameters: Record<string, any>);
    list(request?: DataDirectoryListRequest): Promise<DataDirectoryListResponse>;
}
declare class ConnectionDataCollectionAccessor {
    client: IntegrationAppApiClient;
    connectionAccessor: ConnectionAccessor;
    key: string;
    parameters: Record<string, any>;
    constructor(client: IntegrationAppApiClient, connectionAccessor: ConnectionAccessor, key: string, parameters: Record<string, any>);
    get(): Promise<DataCollectionSpec>;
    findById(request?: DataCollectionFindByIdRequest): Promise<DataCollectionFindByIdResponse>;
    list(request?: DataCollectionListRequest): Promise<DataCollectionListResponse>;
    search(request?: DataCollectionSearchRequest): Promise<DataCollectionSearchResponse>;
    match(request?: DataCollectionMatchRequest): Promise<DataCollectionMatchResponse>;
    create(request?: DataCollectionCreateRequest): Promise<DataCollectionCreateResponse>;
    update(request?: DataCollectionUpdateRequest): Promise<DataCollectionUpdateResponse>;
    delete(request?: DataCollectionDeleteRequest): Promise<DataCollectionDeleteResponse>;
}
declare class ConnectionProxy {
    private connection;
    constructor(connection: ConnectionAccessor);
    get(path: string): Promise<any>;
    post(path: string, data?: any): Promise<any>;
    put(path: string, data?: any): Promise<any>;
    patch(path: string, data?: any): Promise<any>;
    delete(path: string): Promise<any>;
    private getProxyPath;
}

interface ConnectionRequest {
    path: any;
    method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    pathParameters?: Record<string, string>;
    headers?: Record<string, string>;
    query?: Record<string, string>;
    data?: any;
}
declare class Connection {
    id: string;
    name: string;
    userId: string;
    user?: User;
    disconnected?: boolean;
    error?: ErrorData;
    integrationId: string;
    integration?: Integration;
    credentials?: unknown;
    parameters?: unknown;
    connectorParameters?: unknown;
    accessToken?: string;
    refreshToken?: string;
    createdAt: string;
    updatedAt: string;
    archivedAt?: string;
}
type ConnectionUiSpec = ConnectorUiSpec;
type ConnectionUdmSpec = ConnectorDataUdmSpec;
type ConnectionDataSpec = ConnectorDataSpec;
interface ConnectionSpec extends ConnectorSpec {
}
declare class ConnectionSpec {
    constructor(opts: ConnectionSpec);
}

declare enum ActionType {
    ListDataRecords = "list-data-records",
    FindDataRecordById = "find-data-record-by-id",
    MatchDataRecord = "match-data-record",
    CreateDataRecord = "create-data-record",
    FindOrCreateDataRecord = "find-or-create-data-record",
    UpdateDataRecord = "update-data-record",
    DeleteDataRecord = "delete-data-record",
    SearchDataRecords = "search-data-record",
    ConnectorOperation = "connector-operation",
    ApiRequestToExternalApp = "api-request-to-external-app",
    ApiRequestToYourApp = "api-request-to-your-app",
    HttpRequest = "http-request",
    RunJavascript = "run-javascript",
    ApiRequest = "api-request"
}
interface ActionSpec {
    name: string;
    description: string;
    direction?: FieldMappingDirection;
    isDataAction?: boolean;
    isDeprecated?: boolean;
}
declare function isDataActionType(type: string | ActionType): any;
declare const ACTIONS: Record<ActionType, ActionSpec>;

declare enum ActionDependencyType {
    FieldMapping = "FieldMapping",
    DataSource = "DataSource"
}
interface ActionDependency {
    type: ActionDependencyType;
    key: string;
    element?: any;
}
interface Action extends ElementTemplateFields {
    type: ActionType;
    inputSchema?: DataSchema;
    config?: any;
    outputMapping?: any;
    customOutputSchema?: DataSchema;
    defaultOutputSchema?: DataSchema;
    transformedOutputSchema?: DataSchema;
    outputSchema?: DataSchema;
    appliedToIntegrations?: AppliedToIntegrations<Action>;
    dependencies?: WorkspaceElementDependency[];
    isDeployed?: boolean;
}
interface ActionInstance extends ElementInstanceFields {
    type: ActionType;
    parent?: Action;
    instanceKey?: string;
    inputSchema?: any;
    config?: any;
    outputSchema?: any;
    isOutdated?: boolean;
    state: WorkspaceElementState;
}
interface ListActionsForIntegrationQuery extends PaginationQuery {
    parentId?: string | 'null';
}
interface FindActionsQuery extends ListActionsForIntegrationQuery {
    integrationId?: string | 'null';
}
type CreateActionRequest = {
    key: string;
    name: string;
    type?: ActionType;
    inputSchema?: any;
    config?: any;
    integrationId?: string;
};
type UpdateActionRequest = {
    key?: string;
    type?: ActionType;
    name?: string;
    inputSchema?: any;
    config?: any;
    archivedAt?: string;
};
interface ActionSelector extends IntegrationSpecificElementSelector {
}
interface ActionInstanceSelector extends ConnectionSelector, ElementInstanceSelector {
}
type ListActionInstancesForConnectionQuery = PaginationQuery & {
    parentId?: string;
    universalParentId?: string;
};
interface FindActionInstancesQuery extends ListActionInstancesForConnectionQuery {
    integrationKey?: string;
    integrationId?: string;
    userId?: string;
    connectionId?: string;
}
interface CreateActionInstanceRequest {
    parentId: string;
    connectionId: string;
    config?: any;
}
interface UpdateActionInstanceRequest {
    config?: any;
}
interface OpenActionConfigurationOptions extends OpenConfigurationOptions {
}
interface ActionRunResponse {
    output?: any;
    logs?: any[];
}

declare class ActionsAccessor extends ElementListAccessor<Action, FindActionsQuery, CreateActionRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class ActionAccessor extends ElementAccessor<Action, UpdateActionRequest, ActionSelector> {
    constructor(client: IntegrationAppApiClient, selector: ActionSelector | string);
    apply(integrationKeys: string[]): Promise<Action[]>;
    reset(): Promise<any>;
}
declare class ActionInstancesAccessor extends ElementInstanceListAccessor<ActionInstance, FindActionInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class ActionInstanceAccessor extends ElementInstanceAccessor<ActionInstance, ActionInstanceSelector, CreateActionInstanceRequest, UpdateActionInstanceRequest> {
    client: IntegrationAppApiClient;
    constructor(client: IntegrationAppApiClient, selector: string | ActionInstanceSelector);
    setup(): Promise<void>;
    reset(): Promise<void>;
    run(input?: any): Promise<ActionRunResponse>;
    open({ onClose, }?: OpenActionConfigurationOptions): Promise<void>;
}
declare class IntegrationLevelActionAccessor extends IntegrationLevelElementAccessor<Action, UpdateActionRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    actionSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, actionSelector: string);
}
declare class IntegrationLevelActionsListAccessor extends IntegrationLevelElementsListAccessor<Action, ListActionsForIntegrationQuery, Omit<CreateActionRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelActionAccessor extends ConnectionLevelElementAccessor<ActionInstance, UpdateActionInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    actionSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, actionSelector: string, query: InstanceKeyQuery);
    run(input?: any): Promise<ActionRunResponse>;
}
declare class ConnectionLevelActionsAccessor extends ConnectionLevelElementsListAccessor<Action, ListActionInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

type CreateAppDataSchemaRequest = {
    key: string;
    name: string;
    schema?: any;
    code?: string;
};
type UpdateAppDataSchemaRequest = {
    key?: string;
    name?: string;
    schema?: any;
    code?: string;
    archivedAt?: string;
};
interface FindAppDataSchemasQuery extends PaginationQuery {
}
interface AppDataSchemaInstanceSelector {
    id?: string;
    appDataSchemaKey?: string;
    appDataSchemaId?: string;
    instanceKey?: string;
    autoCreate?: boolean;
}
interface UpdateAppDataSchemaInstanceRequest {
}
interface CreateAppDataSchemaInstanceRequest {
}
interface FindAppDataSchemaInstancesQuery extends PaginationQuery {
    id?: string;
    userId?: string;
    appDataSchemaId?: string;
    instanceKey?: string;
}

declare class AppDataSchemasAccessor extends ElementListAccessor<AppDataSchema, FindAppDataSchemasQuery, CreateAppDataSchemaRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppDataSchemaAccessor extends ElementAccessor<AppDataSchema, UpdateAppDataSchemaRequest> {
    constructor(client: IntegrationAppApiClient, idOrKey: string);
}
declare class AppDataSchemaInstancesAccessor extends ElementInstanceListAccessor<AppDataSchemaInstance, FindAppDataSchemaInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppDataSchemaInstanceAccessor extends ElementInstanceAccessor<AppDataSchemaInstance, AppDataSchemaInstanceSelector, UpdateAppDataSchemaInstanceRequest, CreateAppDataSchemaInstanceRequest> {
    private client;
    constructor(client: IntegrationAppApiClient, selector: string | AppDataSchemaInstanceSelector);
    setup(): Promise<void>;
}

interface AppDataSchema {
    id: string;
    key: string;
    name: string;
    schema: any;
    code?: string;
    archivedAt?: string;
    revision?: string;
}
interface AppDataSchemaInstance {
    id: string;
    appId: string;
    userId: string;
    user?: User;
    appDataSchemaId: string;
    appDataSchemaRevision: string;
    appDataSchema?: AppDataSchema;
    instanceKey?: string;
    schema?: any;
    error?: ErrorData;
    archivedAt?: string;
}

interface UpdateAppEventTypeRequest {
    key?: string;
    name?: string;
    subscribeRequest?: HttpRequestSpec;
    example?: any;
    schema?: DataSchema;
    userIdFormula?: any;
}
interface CreateAppEventTypeRequest extends UpdateAppEventTypeRequest {
    key: string;
    name: string;
}
interface AppEventSubscriptionSelector extends Omit<ElementInstanceSelector, 'parentKey' | 'parentId'> {
    appEventTypeKey?: string;
    appEventTypeId?: string;
    instanceKey?: string;
}
interface AppEventSubscriptionCreateRequest {
}
interface AppEventSubscriptionUpdateRequest {
}
interface FindAppEventTypesQuery extends PaginationQuery {
    includeArchived?: boolean;
}
interface FindAppEventSubscriptionsQuery extends PaginationQuery {
    id?: string;
    userId?: string;
    instanceKey?: string;
    appEventTypeId?: string;
    isSubscribed?: boolean;
}
interface FindAppEventsQuery extends PaginationQuery {
    id?: string;
    userId?: string;
    instanceKey?: string;
    appEventTypeId?: string;
    appEventSubscriptionId?: string;
    startDatetime?: string;
    endDatetime?: string;
}

declare class AppEventTypesAccessor extends ElementListAccessor<AppEventType, FindAppEventTypesQuery, CreateAppEventTypeRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppEventTypeAccessor extends ElementAccessor<AppEventType, UpdateAppEventTypeRequest> {
    constructor(client: IntegrationAppApiClient, idOrKey: string);
}
declare class AppEventSubscriptionsAccessor extends ElementInstanceListAccessor<AppEventSubscription, FindAppEventSubscriptionsQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppEventSubscriptionAccessor extends ElementInstanceAccessor<AppEventSubscription, AppEventSubscriptionSelector, AppEventSubscriptionUpdateRequest, AppEventSubscriptionUpdateRequest> {
    constructor(client: IntegrationAppApiClient, selector: string | AppEventSubscriptionSelector);
    subscribe(): Promise<void>;
}
declare class AppEventsAccessor extends ElementInstanceListAccessor<AppEvent, FindAppEventsQuery> {
    constructor(client: IntegrationAppApiClient);
}

interface AppEventType {
    id: string;
    key: string;
    name: string;
    revision: string;
    archivedAt?: string;
    subscribeRequest?: HttpRequestSpec;
    example?: any;
    schema?: DataSchema;
    globalWebhookUri: string;
    userIdFormula?: any;
}
interface AppEventSubscription {
    id: string;
    revision: string;
    appEventTypeId: string;
    appEventType?: AppEventType;
    userId: string;
    user?: User;
    instanceKey?: string;
    isSubscribed: boolean;
    schema?: DataSchema;
    webhookUri: string;
    subscriptionRequest: HttpRequestSpec;
    subscriptionResponse?: any;
    archivedAt?: string;
}
interface AppEvent {
    id: string;
    userId: string;
    user?: User;
    appEventTypeId: string;
    appEventType?: AppEventType;
    appEventSubscriptionId: string;
    appEventSubscription?: AppEventSubscription;
    event: any;
    datetime: string;
    launchedFlowRunIds: string[];
}

type CreateDataLinkTableRequest = Omit<DataLinkTable, 'id' | 'userId'>;
type UpdateDataLinkTableRequest = CreateDataLinkTableRequest;
interface FindDataLinkTablesQuery extends PaginationQuery {
}
interface FindDataLinkTableInstancesQuery extends PaginationQuery {
    connectionId?: string;
    integrationId?: string;
    dataLinkTableId?: string;
}
interface DataLinkTableInstanceSelector extends ConnectionSelector, ElementInstanceSelector {
    dataLinkTableId?: string;
    dataLinkTableKey?: string;
    instanceKey?: string;
}
interface UpdateDataLinkTableInstanceRequest {
}
interface CreateDataLinkTableInstanceRequest {
}
interface FindDataLinksInTableQuery extends PaginationQuery {
    direction?: DataLinkDirection;
    appRecordId?: string;
    externalRecordId?: string;
}
interface CreateDataLinkRequest {
    direction?: DataLinkDirection;
    appRecordId: string;
    externalRecordId: string;
}
interface DeleteDataLinkRequest {
    direction?: DataLinkDirection;
    appRecordId: string;
    externalRecordId: string;
}
interface FindDataLinksQuery extends PaginationQuery, FindDataLinksInTableQuery {
    dataLinkTableInstanceId: string;
}
interface FindDataLinksResponse extends PaginationResponse<DataLink> {
}
interface FindDataLinkQuery extends PaginationQuery {
    dataLinkTableInstanceId: string;
    externalRecordId: string;
    appRecordId: string;
    direction: DataLinkDirection;
}
interface DataLinkInTableSelector {
    appRecordId: string;
    externalRecordId: string;
    direction: DataLinkDirection;
}
interface DataLinkSelector extends DataLinkInTableSelector {
    dataLinkTableInstanceId: string;
}

declare class DataLinkTablesAccessor extends ElementListAccessor<DataLinkTable, FindDataLinkTablesQuery, CreateDataLinkTableRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataLinkTableAccessor extends ElementAccessor<DataLinkTable, UpdateDataLinkTableRequest> {
    constructor(client: IntegrationAppApiClient, idOrKey: string);
}
declare class DataLinkTableInstancesAccessor extends ElementInstanceListAccessor<DataLinkTableInstance, FindDataLinkTableInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataLinkTableInstanceAccessor extends ElementInstanceAccessor<DataLinkTableInstance, DataLinkTableInstanceSelector, UpdateDataLinkTableInstanceRequest, UpdateDataLinkTableInstanceRequest> {
    private client;
    constructor(client: IntegrationAppApiClient, selector: string | DataLinkTableInstanceSelector);
    findLinks(query?: FindDataLinksInTableQuery): Promise<FindDataLinksResponse>;
    createLink(data: CreateDataLinkRequest): Promise<void>;
    deleteLink(data: DeleteDataLinkRequest): Promise<void>;
}

declare enum DataLinkDirection {
    IMPORT = "import",
    EXPORT = "export",
    BOTH = "both"
}
interface DataLinkTable {
    id: string;
    key: string;
    name: string;
    archivedAt?: string;
}
interface DataLinkTableInstance {
    id: string;
    dataLinkTableId?: string;
    dataLinkTable?: DataLinkTable;
    connectionId?: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    instanceKey?: string;
    userId: string;
    user?: User;
    name: string;
    archivedAt?: string;
}
interface DataLink {
    id: string;
    dataLinkTableInstanceId: string;
    externalRecordId: string;
    appRecordId: string;
    direction: DataLinkDirection;
}
interface DataLinkTableConfig {
    key: string;
}

interface WorkspaceElementSpec {
    type: WorkspaceElementType;
    createSchema?: z.ZodObject<any>;
    updateSchema?: z.ZodObject<any>;
}
interface WorkspaceElements {
    flows?: Record<string, CreateFlowRequest>;
    actions?: Record<string, CreateActionRequest>;
    fieldMappings?: Record<string, CreateFieldMappingRequest>;
    dataSources?: Record<string, CreateDataSourceRequest>;
    dataLinkTables?: Record<string, CreateDataLinkTableRequest>;
    appEventTypes?: Record<string, CreateAppEventTypeRequest>;
    appDataSchemas?: Record<string, CreateAppDataSchemaRequest>;
}
declare const WorkspaceElementSpecs: Record<WorkspaceElementType, WorkspaceElementSpec>;

interface IWorkspaceUpdate {
    apiBaseUri?: string;
    apiRequestHeaders: Record<string, any>;
    apiRequestQuery: Record<string, any>;
}

declare enum WorkspaceOnboardingStep {
    AddConnectors = "add-connectors",
    ConnectYourApp = "connect-your-app",
    BuildIntegrations = "build-integrations",
    Completed = "completed"
}
interface Workspace {
    id: string;
    key: string;
    secret: string;
    name: string;
    orgId: string;
    engineAccessToken?: string;
    createdAt: Date;
    updatedAt: Date;
    onboardingStep?: WorkspaceOnboardingStep;
    isGettingStartedCompleted?: boolean;
    trialEndDate?: string;
}
interface EngineWorkspaceSettings {
    enableApiLogs?: boolean;
    enableWebhookLogs?: boolean;
    disableSecretKeyAuth?: boolean;
}
interface EngineWorkspace {
    id: string;
    key: string;
    logoUri?: string;
    webhookUri?: string;
    publicKey?: string;
    enabledWebhookEvents?: string[];
    userFieldsSchema?: DataSchema;
    auth?: ConnectorAuth;
    credentialsSchema?: DataSchema;
    apiClient?: RestApiClientOptions;
    apiBaseUri?: string;
    apiRequestHeaders: Record<string, any>;
    apiRequestQuery: Record<string, any>;
    isOnPrem?: boolean;
    connectorBaseUri?: string;
    limits: WorkspaceLimits;
    settings?: EngineWorkspaceSettings;
    type?: WorkspaceType;
}
interface WorkspaceUser {
    id: string;
    workspaceId: string;
    testCustomerId: string;
    userId: string;
    user: User;
    role: string;
}
interface UserWorkspaceSettings {
    id: string;
    userId: string;
    workspaceId: string;
    testCustomerId: string;
}
declare enum WorkspaceNotificationType {
    WorkspaceUpdate = "workspace-update",
    CopilotActivity = "copilot-activity"
}
interface WorkspaceNotification<DataType = unknown> {
    type: WorkspaceNotificationType;
    workspaceId: string;
    data: DataType;
}
interface CopilotActivityNotificationData {
    scopes: string[];
}
declare const enum ParallelExecutionLimits {
    ParallelEventPulls = "parallelEventPulls",
    ParallelIncrementalEventPullsPerConnection = "parallelIncrementalEventPullsPerConnection",
    ParallelFullSyncEventPullsPerConnection = "parallelFullSyncEventPullsPerConnection",
    ParallelFlowRuns = "parallelFlowRuns",
    ParallelFlowRunsPerConnection = "parallelFlowRunsPerConnection",
    ParallelApiRequests = "parallelApiRequests",
    ParallelBackgroundJobs = "parallelBackgroundJobs",
    ParallelEventLogs = "parallelEventLogs",
    ParallelEventLogsPerConnection = "parallelEventLogsPerConnection"
}
declare const enum RateLimits {
    fileUploadsMbPerHour = "fileUploadsMbPerHour",
    ApiRequestsPerSecond = "apiRequestsPerSecond",
    ApiRequestsPerHour = "apiRequestsPerHour",
    WebhookRequestsPerSecond = "webhookRequestsPerSecond",
    WebhookRequestsPerHour = "webhookRequestsPerHour",
    WorkspaceElementCreationsPerSecond = "workspaceElementCreationsPerSecond",
    WorkspaceElementCreationsPerHour = "workspaceElementCreationsPerHour",
    ExternalEventsPerCustomerPerDay = "externalEventsPerCustomerPerDay"
}
declare const enum WorkspaceSizeLimits {
    TotalNumberOfCustomers = "totalNumberOfCustomers",
    TotalNumberOfConnections = "totalNumberOfConnections",
    TotalNumberOfWorkspaceElements = "totalNumberOfWorkspaceElements"
}
declare const enum CustomerLimits {
    ParallelApiRequestsPerCustomer = "parallelApiRequestsPerCustomer",
    ParallelBackgroundJobsPerCustomer = "parallelBackgroundJobsPerCustomer",
    ApiRequestsPerCustomerPerSecond = "apiRequestsPerCustomerPerSecond",
    ApiRequestsPerCustomerPerHour = "apiRequestsPerCustomerPerHour",
    WebhookRequestsPerCustomerPerSecond = "webhookRequestsPerCustomerPerSecond",
    WebhookRequestsPerCustomerPerHour = "webhookRequestsPerCustomerPerHour"
}
declare const enum LimitUnits {
    Number = "number",
    Msec = "msec",
    Mb = "Mb"
}
interface WorkspaceLimit {
    value?: number;
    defaultValue?: number;
    unit: LimitUnits;
}
interface WorkspaceLimits {
    [ParallelExecutionLimits.ParallelEventPulls]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelIncrementalEventPullsPerConnection]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelFullSyncEventPullsPerConnection]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelFlowRuns]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelFlowRunsPerConnection]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelApiRequests]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelBackgroundJobs]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelEventLogs]?: WorkspaceLimit;
    [ParallelExecutionLimits.ParallelEventLogsPerConnection]?: WorkspaceLimit;
    [RateLimits.fileUploadsMbPerHour]?: WorkspaceLimit;
    [RateLimits.ApiRequestsPerSecond]?: WorkspaceLimit;
    [RateLimits.ApiRequestsPerHour]?: WorkspaceLimit;
    [RateLimits.WebhookRequestsPerSecond]?: WorkspaceLimit;
    [RateLimits.WebhookRequestsPerHour]?: WorkspaceLimit;
    [RateLimits.WorkspaceElementCreationsPerSecond]?: WorkspaceLimit;
    [RateLimits.WorkspaceElementCreationsPerHour]?: WorkspaceLimit;
    [RateLimits.ExternalEventsPerCustomerPerDay]?: WorkspaceLimit;
    [WorkspaceSizeLimits.TotalNumberOfCustomers]?: WorkspaceLimit;
    [WorkspaceSizeLimits.TotalNumberOfConnections]?: WorkspaceLimit;
    [WorkspaceSizeLimits.TotalNumberOfWorkspaceElements]?: WorkspaceLimit;
    [CustomerLimits.ParallelApiRequestsPerCustomer]?: WorkspaceLimit;
    [CustomerLimits.ParallelBackgroundJobsPerCustomer]?: WorkspaceLimit;
    [CustomerLimits.ApiRequestsPerCustomerPerSecond]?: WorkspaceLimit;
    [CustomerLimits.ApiRequestsPerCustomerPerHour]?: WorkspaceLimit;
    [CustomerLimits.WebhookRequestsPerCustomerPerSecond]?: WorkspaceLimit;
    [CustomerLimits.WebhookRequestsPerCustomerPerHour]?: WorkspaceLimit;
}
interface EngineWorkspaceWithOrgData {
    id: string;
    key: string;
    limits: WorkspaceLimits;
    workspaceId: string;
    workspaceName: string;
    orgId: string;
    orgName: string;
    type?: WorkspaceType;
    isTrial: string;
}
declare enum WorkspaceType {
    PRODUCTION = "production",
    DEVELOPMENT = "development"
}

declare const PARALLEL_EXECUTION_LIMITS: string[];
declare const RATE_LIMITS: string[];
declare const WORKSPACE_SIZE_LIMITS: string[];
declare const EDITABLE_LIMITS: string[];

declare class SelfAccessor {
    private client;
    constructor(client: IntegrationAppApiClient);
    get(): Promise<Customer>;
    patch(data: Partial<{
        credentials: any;
    }>): Promise<Customer>;
}

interface Self {
    user: User;
    workspace: Workspace;
}

declare enum ConnectorCopilotSuggestionType {
    AuthType = "auth-type",
    AuthImplementation = "auth-implementation",
    AuthConnectionParameters = "auth-connection-parameters",
    AuthApiClient = "auth-api-client",
    DataCollection = "data-collection",
    DataCollectionOperationApiRequests = "data-location-operation-api-requests",
    DataCollectionOperationApiRequestMapping = "data-location-operation-api-request-mapping",
    DataCollectionFieldsSchema = "data-location-fields-schema",
    UdmList = "udm-list",
    UdmFieldsMapping = "udm-fields-mapping",
    UdmFieldsMappingToCollection = "udm-fields-mapping-to-collection",
    UdmFieldsMappingFromCollection = "udm-fields-mapping-from-collection"
}
interface ConnectorCopilotSuggestion {
    id?: string;
    type: ConnectorCopilotSuggestionType;
    dataCollectionKey?: string;
    title?: string;
    description?: string;
    parameters?: Record<string, any>;
    hash?: string;
    action?: ConnectorCopilotSuggestionAction;
    actions?: ConnectorCopilotSuggestionAction[];
}
type ConnectorCopilotSuggestionActionType = 'patch' | 'put' | 'patch-data-schema' | 'patch-field-mapping';
interface ConnectorCopilotSuggestionAction {
    type: ConnectorCopilotSuggestionActionType;
    path: string;
    locator?: string;
    data: any;
    format?: 'value' | 'fields' | 'schema';
    schema?: any;
    variablesSchema?: any;
    parameters?: any;
}
declare enum ConnectorCopilotFileChunkTopicKey {
    AuthType = "auth-type",
    AuthImplementation = "auth-implementation",
    AuthConnectionParameters = "auth-connection-parameters",
    AuthApiClient = "auth-api-client"
}
declare enum CopilotTaskType {
    GenerateAuthType = "generate-auth-type",
    GenerateOAuthConfiguration = "generate-oauth-configuration",
    GenerateAuthConnectionParameters = "generate-auth-connection-parameters",
    GenerateAuthApiClient = "generate-auth-api-client",
    GenerateDataCollections = "generate-data-collections",
    GenerateDataCollectionRecordFromFields = "generate-data-collection-record-from-fields",
    GenerateDataCollectionOperationApiRequests = "generate-data-collection-operation-api-requests",
    GenerateDataCollectionOperationApiRequestMapping = "generate-data-collection-operation-api-request-mapping",
    GenerateDataCollectionFieldsSchema = "generate-data-collection-fields-schema",
    GenerateUdmList = "generate-udm-list",
    GenerateUdmFieldsMapping = "generate-udm-fields-mapping"
}
declare enum CopilotTaskStatus {
    Pending = "pending",
    Running = "running",
    Completed = "completed",
    Failed = "failed"
}
interface CopilotTask<ParameterClass = unknown> {
    id: string;
    name: string;
    type: CopilotTaskType;
    parameters: ParameterClass;
    status: CopilotTaskStatus;
    startedTimestamp: number;
    endedTimestamp: number;
    error: ErrorData;
}
declare enum CopilotActionType {
    PatchConnectorFile = "patch",
    PutConnectorFile = "put",
    PatchConnectorDataSchema = "patch-data-schema",
    PatchConnectorFieldMapping = "patch-field-mapping",
    SetConnectorAuthType = "set-connector-auth-type"
}
declare enum CopilotActionStatus {
    Suggested = "suggested",
    Executed = "executed",
    Rejected = "rejected"
}
interface CopilotAction {
    id: string;
    copilotTaskId: string;
    type: CopilotActionType;
    status: CopilotActionStatus;
    name: string;
    description?: string;
    parameters?: unknown;
    hash?: string;
    references?: CopilotActionReference[];
}
declare enum CopilotActivityType {
    Task = "task"
}
interface CopilotActivityDataTask {
    taskId: string;
}
interface CopilotActivity<DataClass = unknown> {
    type: CopilotActivityType;
    text: string;
    data: DataClass;
    scopes: string[];
    timestamp: number;
}
interface CopilotActionReference {
    id: string;
    snippet: string;
    quotes?: string[];
    file: {
        name: string;
        sourceUri?: string;
    };
}
declare const CopilotActivityScope: {
    connector: (connectorId: string) => CopilotActivityScopeConnector;
};
declare class CopilotActivityScopeConnector {
    private connectorId;
    constructor(connectorId: string);
    auth: () => CopilotActivityScopeConnectorAuth;
    data: (key?: string) => CopilotActivityScopeConnectorData;
    udm: (key?: string) => CopilotActivityScopeConnectorUdm;
    toString(): string;
}
declare class CopilotActivityScopeConnectorAuth {
    private connectorScope;
    constructor(connectorScope: CopilotActivityScopeConnector);
    toString(): string;
}
declare class CopilotActivityScopeConnectorData {
    private connectorScope;
    private dataCollectionKey;
    constructor(connectorScope: CopilotActivityScopeConnector, dataCollectionKey: string | undefined);
    method: (key: string) => CopilotActivityScopeConnectorDataMethod;
    toString(): string;
}
declare class CopilotActivityScopeConnectorDataMethod {
    private collectionScope;
    private methodKey;
    constructor(collectionScope: CopilotActivityScopeConnectorData, methodKey: string);
    toString(): string;
}
declare class CopilotActivityScopeConnectorUdm {
    private connectorScope;
    private key?;
    constructor(connectorScope: CopilotActivityScopeConnector, key?: string | undefined);
    collection: (key: string) => CopilotActivityScopeConnectorUdmCollection;
    toString(): string;
}
declare class CopilotActivityScopeConnectorUdmCollection {
    private udmScope;
    private key;
    constructor(udmScope: CopilotActivityScopeConnectorUdm, key: string);
    toString(): string;
}

declare enum DataBuilderFormulaType {
    VAR = "var",
    COPY = "copy",
    TPL = "tpl",
    RECORD = "record",
    LOOKUP = "lookup",
    PLAIN = "plain",
    MAP = "map",
    CONCAT = "concat",
    FIRST_NAME = "firstName",
    LAST_NAME = "lastName",
    ITERATE = "iterate",
    CASE = "case",
    EXTRACT_DATE = "extractDate",
    EXTRACT_TIME = "extractTime",
    FIND_EXTERNAL_RECORD_ID = "findExternalRecordId",
    FIND_APP_RECORD_ID = "findAppRecordId",
    EVAL = "eval",
    AND = "and",
    OR = "or",
    MERGE_OBJECTS = "mergeObjects",
    FIRST_NOT_EMPTY = "firstNotEmpty",
    DOMAIN_FROM_EMAIL = "domainFromEmail",
    FORMULA = "formula",
    JSONATA = "jsonata",
    DATA_SCHEMA_REF = "dataSchemaRef"
}

interface DataBuilderFormula {
    resolveValue(params: ResolveFormulaParams): Promise<unknown>;
    getValue(variables: any): any;
    getSchema(variablesSchema: any): any;
    toObject(): any;
    toString(variablesSchema?: any): string;
}
interface ResolveFormulaParams {
    variables?: unknown;
    schema?: DataSchema | undefined;
    getDataCollection?: (key: string, parameters?: Record<string, unknown>) => Promise<DataCollectionSpec>;
    getInternalDataSchema?: (key: string) => Promise<DataSchema>;
}
declare abstract class DataBuilderFormulaBase<ArgsType = any> implements DataBuilderFormula {
    type: DataBuilderFormulaType;
    args: ArgsType;
    constructor(type: DataBuilderFormulaType, args: ArgsType);
    resolveValue(params: ResolveFormulaParams): Promise<any>;
    abstract getSchema(variablesSchema: any): any;
    toObject(): any;
    toString(_variablesSchema?: any): string;
    getVariableLocators(): string[];
    transformVars(transformations: any): any;
    abstract getValue(variables: any): any;
}

declare enum DataLocatorStepType {
    OBJECT_PROPERTY = "object_property",
    ARRAY_ITEM = "array_item"
}
declare class DataLocatorStep {
    type: DataLocatorStepType;
}
declare class DataLocatorStepObjectProperty extends DataLocatorStep {
    propertyName: string;
    constructor(propertyName: string);
}
declare class DataLocatorStepArrayItem extends DataLocatorStep {
    index: number;
    constructor(index: number);
}
type DataLocator = DataLocatorStep[] | string;
declare class InvalidLocatorError extends Error {
}
declare function locatorToField(locator: string): string;
declare function makeObjectPropertyLocator(objectLocator: string | undefined, propertyName: string): string;
declare function getLocatorsFromSchema(schema?: DataSchema, rootLocator?: string): string[];
declare function getSchemaByLocator(schema: any, locator: DataLocator): any;
declare function findValueLocators(data: any, value: any): string[];
declare function getValueAtLocator(data: any, locator: DataLocator): any;
declare function setValueAtLocator(obj: any, locator: string, value: any): any;
declare function pickFieldsFromValue(value: any, fields: string[]): any;
declare function excludeFieldsFromValue(value: any, fields: string[]): any;
declare function setSchemaAtLocator(schema: any, locator: DataLocator, schemaAtLocator: any): any;
declare function extractFieldLocator(locator: string): string;
declare function makeSchemaForLocator(locator: DataLocator, locatorSchema: any): any;
declare function getNameForLocator(schema: any, locator: DataLocator): string | null | undefined;
declare function getNameComponentsForLocator(schema: any, locator: DataLocator): string[] | undefined;
declare function getFullNameForLocator(schema: any, locator: DataLocator): string | undefined;
declare function getIconUriForLocator(schema: any, locator: DataLocator): string;
declare function getLocatorsFromData(data: any, parentLocator?: string): any;
declare const getFullTitleForLocator: typeof getFullNameForLocator;
declare function isValidLocator(locator: DataLocator): boolean;
declare function locatorToSteps(sourceLocator: DataLocator): DataLocatorStep[];
declare function locatorToString(locator: DataLocator): string;
declare function stepsToLocator(steps: DataLocatorStep[]): string;
declare function createObjectFromLocators(locators?: string[], placeholderValue?: string): {};
declare function getFormulaLocators(formulaType: string, data: any): string[];
declare function transformVariablesWith(data: any, transformFunction: (locator: string) => string): any;

declare function buildData(value: any, variables?: any): any;
declare function resolveFormulas<T = unknown>(value: any, params: ResolveFormulaParams): Promise<T>;
declare function resolveValue<T = unknown>(value: unknown, params: ResolveFormulaParams): Promise<T>;
declare function valueToString(value: any, variablesSchema: any): string;
declare function processValue(value: any, variables: any): any;
declare function processCopy(data: any): any;
declare function getVariableLocators(data: any): string[];
declare function transformVars(value: any, transformations: Record<string, any>): any;
declare function removeNonExistentVars(value: any, schema: DataSchema): any;
declare function getValueByLocator(variables: any, locator: DataLocator): any;

declare function isFormula(value: any): boolean;
declare function hasFormulas(value: any): any;
declare function getFormula(value: any): DataBuilderFormulaBase;

declare class And extends DataBuilderFormulaBase {
    constructor(args: any[]);
    getValue(variables: any): boolean | undefined;
    getSchema(): {
        type: string;
    };
}

interface CaseFormulaValueItem {
    filter?: any;
    value?: any;
}
type CaseFormulaValue = {
    cases: CaseFormulaValueItem[];
    default?: any;
};
declare class DataBuilderFormulaCase extends DataBuilderFormulaBase {
    value: CaseFormulaValue;
    constructor(value: CaseFormulaValueItem[] | CaseFormulaValue);
    getValue(variables: any): any;
    getSchema(variablesSchema: any): any;
    isValueValid(): boolean;
    transformVars(transformations: any): any;
}

type AnyValue = any;
type ConcatFormulaOptions = {
    delimiter?: AnyValue;
    values?: AnyValue[];
};
declare class DataBuilderFormulaConcat extends DataBuilderFormulaBase {
    options: ConcatFormulaOptions | null;
    delimiter: AnyValue;
    values: AnyValue[];
    constructor(options: ConcatFormulaOptions | null);
    getValue(variables: any): string | undefined;
    getSchema(): {
        type: string;
    };
    toString(variablesSchema: any): string;
}

declare class DataBuilderFormulaCopy extends DataBuilderFormulaBase {
    locator: string;
    constructor(locator: string);
    getValue(variables: any): {
        $copy: any;
    };
    getSchema(): null;
}

declare class DomainFromEmail extends DataBuilderFormulaBase {
    value: any;
    constructor(value: any);
    getValue(variables: any): string | undefined;
    getSchema(): {
        type: string;
    };
}

interface EvalOperator {
    key: string;
    name: string;
    operandSchema: any;
    hasOperand: boolean;
}
declare class Eval extends DataBuilderFormulaBase {
    value: any;
    operatorKey: string;
    operand: any;
    constructor(args: any, formulaValue: any);
    getAvailableOperators(variablesSchema: DataSchema): EvalOperator[];
    getOperator(variablesSchema: any): EvalOperator;
    getValue(variables: any): boolean;
    getSchema(): {
        type: string;
    };
    toObject(): {
        $eval: any;
    };
    transformVars(transformations: any): {
        [x: string]: any;
        $eval: any;
    } | undefined;
}

declare class DataBuilderFormulaExtractDate extends DataBuilderFormulaBase {
    value: any;
    constructor(value: any);
    getValue(variables: any): string | undefined;
    getSchema(): {
        type: string;
        format: string;
    };
}

declare class DataBuilderFormulaExtractTime extends DataBuilderFormulaBase {
    value: any;
    constructor(value: any);
    getValue(variables: any): string;
    getSchema(): {
        type: string;
        format: string;
    };
}

interface FindAppRecordIdArgs {
    dataLinkTable: DataLinkTableConfig;
    recordId: string;
}
declare class DataBuilderFormulaFindAppRecordId extends DataBuilderFormulaBase {
    args: FindAppRecordIdArgs;
    constructor(args: FindAppRecordIdArgs);
    getValue(variables: any): {
        $findAppRecordId: any;
    };
    getSchema(): {
        type: string;
    };
}

interface FindExternalRecordIdArgs {
    dataLinkTable: DataLinkTableConfig;
    recordId: string;
}
declare class DataBuilderFormulaFindExternalRecordId extends DataBuilderFormulaBase {
    args: FindExternalRecordIdArgs;
    constructor(args: FindExternalRecordIdArgs);
    getValue(variables: any): {
        $findExternalRecordId: any;
    };
    getSchema(): {
        type: string;
    };
}

declare class DataBuilderFormulaFirstName extends DataBuilderFormulaBase {
    value: any;
    constructor(value: any);
    getValue(variables: any): any;
    getSchema(): {
        type: string;
    };
}

declare class FirstNotEmpty extends DataBuilderFormulaBase {
    constructor(args: any[]);
    getValue(variables: any): any;
    getSchema(variablesSchema: any): any;
}

declare class FormulaFormula extends DataBuilderFormulaBase {
    constructor(args: any);
    getValue(variables: any): any;
    getSchema(): undefined;
    transformVars(transformations: any): any;
}

interface IterateArguments {
    source: any;
    item?: any;
}
declare class DataBuilderFormulaIterate extends DataBuilderFormulaBase {
    args: IterateArguments;
    source: any;
    item: any;
    constructor(args: IterateArguments);
    getValue(variables: any): never[] | undefined;
    getSchema(variablesSchema: any): {
        type: string;
        items: any;
    };
    getVariableLocators(): string[];
    transformVars(transformations: any): any;
}

declare class JsonataFormula extends DataBuilderFormulaBase {
    expression: any;
    constructor(expression: any);
    getValue(variables: any): any;
    getSchema(): any;
}

declare class DataBuilderFormulaLastName extends DataBuilderFormulaBase {
    value: any;
    constructor(value: any);
    getValue(variables: any): any;
    getSchema(): {
        type: string;
    };
    toString(variablesSchema: any): string;
}

interface LookupValue {
    collectionPath?: string;
    query: Record<string, any>;
    createIfNotFound?: boolean;
    create?: {
        fields: any;
    };
}
declare class DataBuilderFormulaLookup extends DataBuilderFormulaBase {
    value: LookupValue;
    constructor(value: LookupValue);
    getValue(variables: any): {
        $lookup: any;
    };
    getSchema(): {
        type: string;
    };
}

interface MappingItem {
    from: any;
    to?: any;
}
interface MapFormulaValue {
    value: any;
    mapping: MappingItem[];
    default?: any;
}
declare class DataBuilderFormulaMap extends DataBuilderFormulaBase {
    args: MapFormulaValue;
    constructor(args: MapFormulaValue);
    getValue(variables: any): any;
    getSchema(variablesSchema: any): any;
}

declare class MergeObjects extends DataBuilderFormulaBase {
    constructor(args: any[]);
    getValue(variables: any): {} | undefined;
    getSchema(variablesSchema: any): {
        type: string;
        properties: {};
    } | {
        type: string;
    };
}

declare class Or extends DataBuilderFormulaBase {
    constructor(args: any[]);
    getValue(variables: any): boolean | undefined;
    getSchema(): {
        type: string;
    };
}

declare class DataBuilderFormulaPlain extends DataBuilderFormulaBase {
    value: any;
    constructor(value: any);
    getValue(): any;
    getSchema(): any;
}

declare class DataBuilderFormulaRecord extends DataBuilderFormulaBase {
    record: DataRecord;
    constructor(record: DataRecord);
    getValue(): string;
    getSchema(): {
        type: string;
    };
}

type TplFormulaArgs = {
    template: string;
    values: Record<string, any>;
};
declare class DataBuilderFormulaTpl extends DataBuilderFormulaBase {
    args: TplFormulaArgs;
    constructor(args: TplFormulaArgs);
    getValue(variables: any): string;
    getSchema(): {
        type: string;
    };
}

declare class DataBuilderFormulaVar extends DataBuilderFormulaBase {
    locator: string;
    constructor(locator: string);
    getValue(variables: any): any;
    getSchema(variablesSchema: any): any;
    toString(variablesSchema: any): string;
    getVariableLocators(): string[];
    transformVars(transformations: any): any;
}

interface DataSchemaRegArgsDataCollection {
    type: 'data-collection';
    key: unknown;
    parameters?: unknown;
}
interface DataSchemaRegArgsInternalDataSchema {
    type: 'internal-data-schema';
    key: unknown;
}
type DataSchemaRefArgs = DataSchemaRegArgsDataCollection | DataSchemaRegArgsInternalDataSchema;
declare class DataSchemaRef extends DataBuilderFormulaBase<DataSchemaRefArgs> {
    value: any;
    constructor(value: any);
    getValue(): undefined;
    resolveValue(params: ResolveFormulaParams): Promise<DataSchema | undefined>;
    resolveDataCollection(args: DataSchemaRegArgsDataCollection, params: ResolveFormulaParams): Promise<DataSchema | undefined>;
    resolveInternalDataSchema(args: DataSchemaRegArgsInternalDataSchema, params: ResolveFormulaParams): Promise<DataSchema | undefined>;
    getSchema(): {
        type: string;
    };
}

type index_d_And = And;
declare const index_d_And: typeof And;
type index_d_DataSchemaRef = DataSchemaRef;
declare const index_d_DataSchemaRef: typeof DataSchemaRef;
type index_d_DomainFromEmail = DomainFromEmail;
declare const index_d_DomainFromEmail: typeof DomainFromEmail;
type index_d_Eval = Eval;
declare const index_d_Eval: typeof Eval;
type index_d_FirstNotEmpty = FirstNotEmpty;
declare const index_d_FirstNotEmpty: typeof FirstNotEmpty;
type index_d_MergeObjects = MergeObjects;
declare const index_d_MergeObjects: typeof MergeObjects;
type index_d_Or = Or;
declare const index_d_Or: typeof Or;
declare namespace index_d {
  export {
    index_d_And as And,
    DataBuilderFormulaBase as Base,
    DataBuilderFormulaCase as Case,
    DataBuilderFormulaConcat as Concat,
    DataBuilderFormulaCopy as Copy,
    index_d_DataSchemaRef as DataSchemaRef,
    index_d_DomainFromEmail as DomainFromEmail,
    index_d_Eval as Eval,
    DataBuilderFormulaExtractDate as ExtractDate,
    DataBuilderFormulaExtractTime as ExtractTime,
    DataBuilderFormulaFindAppRecordId as FindAppRecordId,
    DataBuilderFormulaFindExternalRecordId as FindExternalRecordId,
    DataBuilderFormulaFirstName as FirstName,
    index_d_FirstNotEmpty as FirstNotEmpty,
    FormulaFormula as Formula,
    DataBuilderFormulaIterate as Iterate,
    JsonataFormula as Jsonata,
    DataBuilderFormulaLastName as LastName,
    DataBuilderFormulaLookup as Lookup,
    DataBuilderFormulaMap as Map,
    index_d_MergeObjects as MergeObjects,
    index_d_Or as Or,
    DataBuilderFormulaPlain as Plain,
    DataBuilderFormulaRecord as Record,
    DataBuilderFormulaTpl as Tpl,
    DataBuilderFormulaVar as Var,
  };
}

interface DataFilterOperator {
    type: string;
    name: string;
    operandSchema: any;
}

declare function backwardCompatibleFilterMatch(filter: any, variables: any): any;
declare function doesMatchFilter(data: any, filter: DataFilter): boolean;
declare class DataFilterCondition {
    field: string;
    operator: string;
    value?: any;
    constructor(field: string, operator: string, value?: any);
}
type DataFilter = DataFilterCondition[];
declare function getOperatorsBySchema(schema: any): DataFilterOperator[];
declare function getFilterFieldValuesByLocator(data: any, locator: DataLocator): any[];

interface DataField {
    name: string;
    locator: string;
    schema: DataSchema;
    value: any;
}

interface DataFormArgs {
    schema: DataSchema;
    value: any;
    variablesSchema?: DataSchema;
}
interface FieldValueOption {
    name: string;
    value: any;
    selected?: boolean;
}
interface DataForm extends DataFormArgs {
}
declare class DataForm {
    constructor(args: DataFormArgs);
    getFields(): DataField[];
    getFieldValueOptions(field: DataField): FieldValueOption[];
    setFieldValue(field: DataField, value: any): any;
    private makeDataField;
}

declare function parseDate(value: any): Date | undefined;

declare enum ExternalEventType {
    DataRecordCreated = "data-record-created",
    DataRecordUpdated = "data-record-updated",
    DataRecordDeleted = "data-record-deleted",
    ConnectorEvent = "connector-event"
}
declare enum ExternalEventSubscriptionStatus {
    Subscribed = "subscribed",
    Unsubscribed = "unsubscribed",
    Error = "error"
}
declare enum ExternalEventPullStatus {
    RUNNING = "running",
    SUCCESS = "success",
    ERROR = "error",
    QUEUED = "queued"
}
declare enum IncomingWebhooksState {
    QUEUED = "queued",
    RUNNING = "running",
    SUCCESS = "success",
    ERROR = "error"
}
interface ExternalEventUnitConfig {
    type: ExternalEventType;
    dataSource?: DataSourceUnitConfig;
    eventKey?: string;
    eventParameters?: any;
}
declare enum ExternalEventSubscriptionType {
    DataRecordCreated = "data-record-created",
    DataRecordUpdated = "data-record-updated",
    DataRecordDeleted = "data-record-deleted",
    ConnectorEvent = "connector-event"
}
interface ExternalEventSubscriptionConfig {
    type: ExternalEventSubscriptionType;
    dataSource?: DataSourceUnitConfig;
    eventKey?: string;
    eventParameters?: any;
}
interface ExternalEvent {
    config?: ExternalEventUnitConfig;
    appliedToIntegrations?: AppliedToIntegrations<ExternalEvent>;
}
interface ExternalEventSubscription {
    id: string;
    name?: string;
    userId: string;
    user?: Customer;
    connectionId: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    uuid: string;
    config?: ExternalEventSubscriptionConfig;
    status?: ExternalEventSubscriptionStatus;
    isRealTime?: boolean;
    requiresPull?: boolean;
    requiresFullSync?: boolean;
    error?: ErrorData;
    createdAt?: string;
    archivedAt?: string;
    stateData?: any;
    nextPullEventsTimestamp?: number;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    nextRefreshTimestamp?: number;
    globalWebhookKey?: string;
    globalWebhookEventSelector?: string;
}
interface ExternalEventLogRecord {
    id: string;
    userId: string;
    user?: Customer;
    externalEventSubscriptionId: string;
    externalEventSubscription?: ExternalEventSubscription;
    integrationId: string;
    integration?: Integration;
    connectionId: string;
    connection?: Connection;
    payload?: any;
    launchedFlowRunIds?: string[];
}
interface ExternalEventCustomPullSubscribeResponse {
    state: Record<string, any>;
}
interface ExternalEventCustomPullCollectEventsRequest {
    state: Record<string, any>;
}
interface ExternalEventCustomPullCollectEventsResponse<EventPayload = any> {
    events: EventPayload[];
    state: Record<string, any>;
}
interface ExternalEventWebhookSubscribeRequest {
    webhookUri: string;
}
interface ExternalEventWebhookSubscribeResponse {
    state?: Record<string, any>;
    nextRefreshTimestamp?: number;
}
interface ExternalEventWebhookUnsubscribeRequest {
    state: Record<string, any>;
}
interface ExternalEventWebhookHandleRequest {
    state: Record<string, any>;
    query: Record<string, string>;
    data: any;
    headers: any;
}
interface ExternalEventWebhookHandleResponse<EventPayload = any> {
    events?: EventPayload[];
    response?: {
        headers?: Record<string, string>;
        data?: any;
    };
    state?: Record<string, any>;
}
interface ExternalEventWebhookRefreshRequest {
    state: Record<string, any>;
    webhookUri: string;
}
interface ExternalEventWebhookRefreshResponse {
    state?: Record<string, any>;
    nextRefreshTimestamp?: number;
}
interface ExternalEventPull {
    id: string;
    userId: string;
    user?: Customer;
    externalEventSubscriptionId: string;
    externalEventSubscription?: ExternalEventSubscription;
    integrationId: string;
    integration?: Integration;
    connectionId: string;
    connection?: Connection;
    startDatetime: string;
    endDatetime: string;
    isFullScan?: boolean;
    status: ExternalEventPullStatus;
    collectedEventIds: string[];
    error?: ErrorData;
}

interface FindExternalEventSubscriptionsQuery extends PaginationQuery {
    userId?: string;
    connectionId?: string;
    integrationId?: string;
}
interface FindExternalEventLogsQuery extends PaginationQuery {
    userId?: string;
    externalEventSubscriptionId?: string;
    connectionId?: string;
    integrationId?: string;
    startDatetime?: string;
}
interface FindExternalEventPullsQuery extends PaginationQuery {
    userId?: string;
    externalEventSubscriptionId?: string;
    integrationId?: string;
    connectionId?: string;
    startedAfter?: string;
}

declare class ExternalEventSubscriptionsAccessor extends ElementInstanceListAccessor<ExternalEventSubscription, FindExternalEventSubscriptionsQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class ExternalEventSubscriptionAccessor {
    private client;
    private id;
    constructor(client: IntegrationAppApiClient, id: string);
    get(): Promise<ExternalEventSubscription>;
    setup(): Promise<void>;
    subscribe(): Promise<void>;
    unsubscribe(): Promise<void>;
    resubscribe(): Promise<void>;
    pullEvents(): Promise<void>;
    private getPath;
}

declare function externalEventTypeToDataCollectionEventType(type: ExternalEventType): DataCollectionEventType;
declare function dataCollectionEventTypeToExternalEventType(type: DataCollectionEventType): ExternalEventType;
declare function externalEventTypeToSubscriptionType(type: ExternalEventType): ExternalEventSubscriptionType;

declare enum LogRecordType {
    MSG = "message",
    TEXT = "text",
    ERR = "error",
    DATA = "data",
    COMP = "compare",
    API = "api-request"
}
interface LogRecord {
    type?: LogRecordType;
    msg?: string;
    data?: any;
}

type WithExecutionLogs<T extends Record<string, any>> = T & {
    logs?: any[];
};
declare function isStream(obj: any): boolean;
declare function streamToString(stream: Readable): Promise<string>;
declare function truncateData(data: any, depth?: number): any;

declare enum ScreenType {
    Integration = "integration"
}
declare enum ScreenBlockType {
    Flow = "flow",
    FieldMapping = "field-mapping",
    DataSource = "data-source",
    Action = "action"
}
interface ScreenBlock {
    type: ScreenBlockType;
    [key: string]: any;
}
interface ScreenSelector {
    id?: string;
    type?: ScreenType;
    key?: string;
    autoCreate?: boolean;
    connectionId?: string;
}
interface UpdateScreenRequest {
    blocks?: ScreenBlock[];
    key?: string;
}
interface CreateScreenRequest extends UpdateScreenRequest {
    type: ScreenType;
}
interface FindScreensQuery extends PaginationQuery {
    type?: ScreenType;
}
interface Screen {
    id: string;
    type: ScreenType;
    key?: string;
    blocks: ScreenBlock[];
}

declare class ScreensAccessor extends ElementListAccessor<Screen, FindScreensQuery, CreateScreenRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class ScreenAccessor extends ElementAccessor<Screen, UpdateScreenRequest, ScreenSelector> {
    constructor(client: IntegrationAppApiClient, selector: ScreenSelector | string);
}

declare enum UsageType {
    FLOW_RUNS_DURATION = "flow-runs-duration",
    FLOW_RUNS_NUMBER = "flow-runs-number",
    FLOW_RUNS_LOG_SIZE = "flow-runs-log-size",
    API_LOGS_NUMBER = "api-logs-number",
    API_LOGS_SIZE = "api-logs-size",
    WEBHOOK_LOGS_NUMBER = "webhook-logs-number",
    WEBHOOK_LOGS_SIZE = "webhook-logs-size",
    EVENT_LOGS_NUMBER = "event-logs-number",
    EVENT_LOGS_SIZE = "event-logs-size",
    EVENT_LOGS_DURATION = "event-logs-duration",
    EXTERNAL_EVENTS_PULL_DURATION = "external-events-pull-duration",
    EXTERNAL_EVENT_PULL_NUMBER = "external-event-pull-number",
    EXTERNAL_EVENT_PULL_LOG_SIZE = "external-event-pull-log-size",
    APP_EVENTS_NUMBER = "app-events-number",
    APP_EVENTS_SIZE = "app-events-size",
    FILES_UPLOAD_NUMBER = "files-upload-number",
    FILES_UPLOAD_SIZE = "files-upload-size",
    CUSTOM_CODE_RUNTIME_DURATION = "custom-code-runtime-duration"
}
interface UsageWithCredits {
    key: UsageType;
    value: number;
    credits: number;
}
interface UsageEntry {
    workspaceId: string;
    customerId?: string;
    connectionId?: string;
    key: UsageType;
    time: string;
    value: number;
}

interface Scenario {
    id: string;
    appId: string;
    name: string;
    key: string;
    scenarioTemplateId?: string;
    elements?: ScenarioElement[];
    connectors?: MinimalConnector[];
    todos?: ScenarioToDo[];
    appliedToIntegrations?: Integration[];
    archivedAt?: string;
}
type ScenarioToDo = {
    name: string;
    description: string;
    isComplete: boolean;
};
type ScenarioElement = {
    id: string;
    type: IntegrationElementType;
    element?: any;
};
interface FindScenariosQuery extends SearchQuery, PaginationQuery {
}
interface CreateScenarioRequest {
    name: string;
    key: string;
    elements?: ScenarioElement[];
    todos?: ScenarioToDo[];
}
interface UpdateScenarioRequest {
    name?: string;
    key?: string;
    elements?: ScenarioElement[];
    todos?: ScenarioToDo[];
}
interface ScenarioTemplate {
    id: string;
    name: string;
    key: string;
    shortDescription?: string;
    description?: string;
    demoWorkspaceKey?: string;
    demoAppUri?: string;
    demoGithubRepo?: string;
    demoVideoYoutubeUri?: string;
    tags?: string[];
    elements?: ScenarioTemplateElements;
    todos?: Omit<ScenarioToDo, 'isComplete'>[];
    connectors?: MinimalConnector[];
    handyElements?: HandyScenarioTemplateElement[];
}
interface FindScenarioTemplatesQuery extends SearchQuery, PaginationQuery {
}
interface CreateScenarioTemplateRequest {
    name: string;
    shortDescription?: string;
    description?: string;
    demoWorkspaceKey?: string;
    demoAppUri?: string;
    demoGithubRepo?: string;
    demoVideoYoutubeUri?: string;
    tags?: string[];
    elements?: ScenarioTemplateElements;
    todos?: Omit<ScenarioToDo, 'isComplete'>[];
}
interface UpdateScenarioTemplateRequest {
    name?: string;
    key?: string;
    shortDescription?: string;
    description?: string;
    demoWorkspaceKey?: string;
    demoAppUri?: string;
    demoGithubRepo?: string;
    demoVideoYoutubeUri?: string;
    tags?: string[];
    elements?: ScenarioTemplateElements;
    todos?: Omit<ScenarioToDo, 'isComplete'>[];
}
type ScenarioTemplateElementOverride = {
    type: IntegrationElementType;
    originalKey: string;
    name: string;
    key: string;
};
type ScenarioTemplateKeyCollision = {
    type: IntegrationElementType;
    key: string;
};
type ScenarioTemplateIntegration = {
    id?: string;
    connectorId: string;
    key: string;
    name: string;
    logoUri: string;
};
type WithIntegrationKeys<T> = T & {
    integrationKeys?: string[];
};
type ElementsExportFeilds = {
    flows?: Record<string, WithIntegrationKeys<CreateFlowRequest>>;
    actions?: Record<string, WithIntegrationKeys<CreateActionRequest>>;
    fieldMappings?: Record<string, WithIntegrationKeys<CreateFieldMappingRequest>>;
    dataSources?: Record<string, WithIntegrationKeys<CreateDataSourceRequest>>;
    dataLinkTables?: Record<string, CreateDataLinkTableRequest>;
    appEventTypes?: Record<string, CreateAppEventTypeRequest>;
    appDataSchemas?: Record<string, CreateAppDataSchemaRequest>;
};
type ScenarioTemplateElements = ElementsExportFeilds & {
    integrations?: Record<string, ElementsExportFeilds & {
        connectorId: string;
    }>;
};
interface HandyScenarioTemplateElement {
    type: IntegrationElementType;
    integration?: {
        key: string;
        connectorId: string;
    };
    integrations?: {
        key: string;
        connectorId: string;
    }[];
    fields: {
        key: string;
        name: string;
    } & Record<string, any>;
}

declare class ScenariosAccessor extends ElementListAccessor<Scenario, FindScenariosQuery, CreateScenarioRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class ScenarioAccessor extends ElementAccessor<Scenario, UpdateScenarioRequest> {
    constructor(client: IntegrationAppApiClient, selector: string);
}

declare function getNodeInputSchema(flow: FlowInstance, nodeKey: string): any;
declare function getFlowNodeConfigTimeVariablesSchema({ parametersSchema, userSchema, }: {
    parametersSchema: DataSchema;
    userSchema: DataSchema;
}): DataSchema;
declare function getActionRunTimeVariablesSchema({ inputSchema, userSchema, }: {
    inputSchema: any;
    userSchema: any;
}): DataSchema;
declare function getActionInstanceVariableSchema(): {
    type: string;
    properties: {
        id: {
            type: string;
        };
        instanceKey: {
            type: string;
        };
    };
};
declare function getFlowNodeRunTimeVariablesSchema({ parametersSchema, inputSchema, userSchema, }: {
    parametersSchema: DataSchema;
    inputSchema: DataSchema;
    userSchema: DataSchema;
}): DataSchema;

interface App {
    id: string;
    apiDocsUri: string;
    appUri: string;
    canIntegrate: boolean;
    categories: string[];
    defaultConnectorId: string;
    key: string;
    logoUri: string;
    name: string;
    popularity: number;
    uuid: string;
    knowledgeBaseUuid?: string;
}
interface AppCategory {
    count: number;
    category: string;
}

interface WorkspaceUpdate {
    id: string;
    path: string;
    before?: unknown;
    after?: unknown;
}

declare enum OrgLimitsType {
    NUMBER_OF_WORKSPACES = "numberOfWorkspaces",
    TODAY_USAGE = "todayUsage",
    LAST_THIRTY_DAY_USAGE = "lastThirtyDayUsage"
}
interface OrgLimits {
    [OrgLimitsType.NUMBER_OF_WORKSPACES]?: number;
    [OrgLimitsType.TODAY_USAGE]?: number;
    [OrgLimitsType.LAST_THIRTY_DAY_USAGE]?: number;
}
interface Org {
    id: string;
    key: string;
    secret?: string;
    name: string;
    createdAt: Date;
    updatedAt: Date;
    trialEndDate?: string;
    limits?: OrgLimits;
    lastThirtyDayUsagePercent?: number;
    todayUsagePercent?: number;
}
declare enum OrgUserRole {
    Admin = "admin",
    Member = "member"
}
declare enum OrgUserStatus {
    Invited = "invited",
    Active = "active"
}
interface PlatformUser {
    id: string;
    email: string;
    name: string;
    trialRequested: boolean;
}
interface OrgUser {
    id: string;
    orgId: string;
    userId: string;
    role: OrgUserRole;
    status: OrgUserStatus;
    workspaces: string[];
    user: PlatformUser;
}
interface OrgWorkspace {
    id: string;
    key: string;
    name: string;
    orgId: string;
    logoUri?: string;
    secret: string;
    createdAt: Date;
    updatedAt: Date;
    archivedAt?: Date;
    trialEndDate?: string;
    featureFlags?: string[];
}

declare enum WebhookTypeEnum {
    USER_INVITED_TO_ORG = "user-invited-to-org"
}
type WebhookType = WebhookTypeEnum.USER_INVITED_TO_ORG;
interface Webhook {
    type: WebhookType;
    url: string;
    secret?: string;
}

interface OpenIntegrationAppConfigurationOptions extends OpenConfigurationOptions {
}
declare class IntegrationAppClient extends IntegrationAppApiClient {
    constructor(options: IntegrationAppClientOptions);
    get self(): SelfAccessor;
    get flows(): FlowsAccessor;
    open({ onClose, }?: OpenIntegrationAppConfigurationOptions): Promise<void>;
    action(selector: string | ActionSelector): ActionAccessor;
    get actions(): ActionsAccessor;
    screen(selector: string | ScreenSelector): ScreenAccessor;
    get screens(): ScreensAccessor;
    actionInstance(selector: string | ActionInstanceSelector): ActionInstanceAccessor;
    get actionInstances(): ActionInstancesAccessor;
    flow(selector: string | FlowSelector): FlowAccessor;
    get flowInstances(): FlowInstancesAccessor;
    flowInstance(selector: string | FlowInstanceSelector): FlowInstanceAccessor;
    get dataSourceInstances(): DataSourceInstancesAccessor;
    get dataSources(): DataSourcesAccessor;
    dataSource(selector: string | DataSourceSelector): DataSourceAccessor;
    dataSourceInstance(selector: string | DataSourceInstanceSelector): DataSourceInstanceAccessor;
    get fieldMappings(): FieldMappingsAccessor;
    fieldMapping(selector: string | FieldMappingSelector): FieldMappingAccessor;
    get fieldMappingInstances(): FieldMappingInstancesAccessor;
    fieldMappingInstance(selector: string | FieldMappingInstanceSelector): FieldMappingInstanceAccessor;
    get dataLinkTables(): DataLinkTablesAccessor;
    dataLinkTable(idOrKey: string): DataLinkTableAccessor;
    get dataLinkTableInstances(): DataLinkTableInstancesAccessor;
    dataLinkTableInstance(selector: string | DataLinkTableInstanceSelector): DataLinkTableInstanceAccessor;
    get integrations(): IntegrationsAccessor;
    externalEventSubscriptions(): ExternalEventSubscriptionsAccessor;
    externalEventSubscription(id: string): ExternalEventSubscriptionAccessor;
    integration(identifier: string): IntegrationAccessor;
    get connections(): ConnectionsAccessor;
    connection(connectionSelector: string): ConnectionAccessor;
    get appEventTypes(): AppEventTypesAccessor;
    appEventType(id: string): AppEventTypeAccessor;
    get appEventSubscriptions(): AppEventSubscriptionsAccessor;
    appEventSubscription(selector: string | AppEventSubscriptionSelector): AppEventSubscriptionAccessor;
    get appEvents(): AppEventsAccessor;
    get flowRuns(): FlowRunsAccessor;
    flowRun(id: string): FlowRunAccessor;
    get appDataSchemas(): AppDataSchemasAccessor;
    appDataSchema(id: string): AppDataSchemaAccessor;
    get appDataSchemaInstances(): AppDataSchemaInstancesAccessor;
    appDataSchemaInstance(selector: string | AppDataSchemaInstanceSelector): AppDataSchemaInstanceAccessor;
    customer(selector: string | CustomerSelector): CustomerAccessor;
    get customers(): CustomersAccessor;
    scenario(selector: string): ScenarioAccessor;
    get scenarios(): ScenariosAccessor;
    connectionRequest(connectionId: string, uri: string, data?: any): Promise<any>;
}

export { ACTIONS, AccessDeniedError, ActionAccessor, ActionDependencyType, ActionInstanceAccessor, ActionInstanceSetupError, ActionInstancesAccessor, ActionRunError, ActionType, ActionsAccessor, AppDataSchemaAccessor, AppDataSchemaInstanceAccessor, AppDataSchemaInstancesAccessor, AppDataSchemasAccessor, AppEventSubscriptionAccessor, AppEventSubscriptionsAccessor, AppEventTypeAccessor, AppEventTypesAccessor, AppEventsAccessor, BadRequestError, BadRequestErrorKey, CONNECTOR_AUTH_TYPES, CONNECTOR_CATEGORIES, CONNECTOR_DATA_DIR, CONNECTOR_DOCS_DIR, CONNECTOR_EVENTS_DIR, CONNECTOR_GLOBAL_WEBHOOKS_DIR, CONNECTOR_METHOD_IMPLEMENTATION_SUFFIXES, CONNECTOR_OPERATIONS_DIR, ConcurrencyError, ConcurrencyErrorKey, ConfigurationError, ConfigurationState, Connection, ConnectionAccessor, ConnectionDataCollectionAccessor, ConnectionDataDirectoryAccessor, ConnectionError, ConnectionErrorKey, ConnectionLevelActionAccessor, ConnectionLevelActionsAccessor, ConnectionLevelDataSourceAccessor, ConnectionLevelDataSourcesAccessor, ConnectionLevelFieldMappingAccessor, ConnectionLevelFieldMappingsAccessor, ConnectionLevelFlowAccessor, ConnectionLevelFlowsAccessor, ConnectionOperationAccessor, ConnectionProxy, ConnectionSpec, ConnectionsAccessor, ConnectorAuthMethodTypes, ConnectorCopilotFileChunkTopicKey, ConnectorCopilotSuggestionType, ConnectorDataCollectionEventImplementationType, ConnectorDataCollectionMethodKeys, ConnectorDataDirectoryMethodKeys, ConnectorDataLocationTypes, ConnectorEventHandlerMethods, ConnectorEventImplementationType, ConnectorMethodImplementationType, ConnectorOperationMethodImplementationTypes, ConnectorStatus, CopilotActionStatus, CopilotActionType, CopilotActivityScope, CopilotActivityType, CopilotTaskStatus, CopilotTaskType, CreateConnectionRequest, CustomerAccessor, CustomerLimits, CustomersAccessor, DATA_RECORD_SCHEMA, DEFAULT_FULL_SYNC_INTERVAL_SECONDS, DEFAULT_PULL_UPDATES_INTERVAL_SECONDS, DataBuilderFormulaType, DataCollectionEventType, DataDirectoryOperation, DataField$1 as DataField, DataFilterCondition, DataForm, DataLinkDirection, DataLinkTableAccessor, DataLinkTableInstanceAccessor, DataLinkTableInstancesAccessor, DataLinkTablesAccessor, DataLocationMethodImplementationTypes, DataLocationType, DataLocationTypeCollection, DataLocationTypeDirectory, DataLocatorStep, DataLocatorStepArrayItem, DataLocatorStepObjectProperty, DataLocatorStepType, DataSourceAccessor, DataSourceInstanceAccessor, DataSourceInstancesAccessor, DataSourcesAccessor, DependencyError, EDITABLE_LIMITS, ElementAccessor, ElementInstanceAccessor, ElementInstanceListAccessor, ElementListAccessor, ErrorData, ErrorDoc, ErrorType, ExternalEventPullStatus, ExternalEventSubscriptionAccessor, ExternalEventSubscriptionStatus, ExternalEventSubscriptionType, ExternalEventSubscriptionsAccessor, ExternalEventType, FLOW_NODE_SPECS, FieldMappingAccessor, FieldMappingDirection, FieldMappingInstanceAccessor, FieldMappingInstancesAccessor, FieldMappingsAccessor, FindConnectionsResponse, FlowAccessor, FlowInstanceAccessor, FlowInstanceNodeState, FlowInstanceSetupError, FlowInstancesAccessor, FlowNodeRunStatus, FlowNodeSpec, FlowNodeType, FlowRunAccessor, FlowRunError, FlowRunLaunchedByTrigger, FlowRunNodeState, FlowRunState, FlowRunsAccessor, FlowsAccessor, index_d as Formula, HTTP_REQUEST_SCHEMA, HttpRequestMethod, IDataField, IncomingWebhooksState, IntegrationAccessor, IntegrationAppClient, IntegrationAppError, IntegrationElementLevel, IntegrationElementType, IntegrationLevelActionAccessor, IntegrationLevelActionsListAccessor, IntegrationLevelDataSourceAccessor, IntegrationLevelDataSourcesListAccessor, IntegrationLevelFieldMappingAccessor, IntegrationLevelFieldMappingsListAccessor, IntegrationLevelFlowAccessor, IntegrationLevelFlowsListAccessor, IntegrationsAccessor, InternalError, InvalidLocatorError, LimitUnits, LogRecordType, MIN_FULL_SYNC_INTERVAL_SECONDS, MIN_PULL_UPDATES_INTERVAL_SECONDS, NotAuthenticatedError, NotFoundError, OAUTH1_CONFIG_SCHEMA, OAUTH_CONFIG_SCHEMA, OrgLimitsType, OrgUserRole, OrgUserStatus, PARALLEL_EXECUTION_LIMITS, PaginationResponse, ParallelExecutionLimits, RATE_LIMITS, RateLimitExceededError, RateLimits, ScenarioAccessor, ScenariosAccessor, ScreenAccessor, ScreenBlockType, ScreenType, ScreensAccessor, SelfAccessor, UDM, UNIFIED_DATA_MODELS, UnitRunError, UpdateConnectionRequest, UsageType, WORKSPACE_SIZE_LIMITS, WebhookTypeEnum, WorkspaceElementDependencyType, WorkspaceElementSpecs, WorkspaceElementState, WorkspaceElementType, WorkspaceEventType, WorkspaceNotificationType, WorkspaceOnboardingStep, WorkspaceSizeLimits, WorkspaceType, addRequiredFieldsToSchema, addUdmFallbackFields, backwardCompatibleFilterMatch, buildData, buildDataSchema, buildUserFriendlyErrorMessage, compressDataSchema, createCompoundSchema, createFlowInstanceSchema, createObjectFromLocators, createSchema, dataCollectionEventTypeToExternalEventType, dataLocationParametersMatch, doesMatchFilter, excludeFieldsFromSchema, excludeFieldsFromValue, excludeReadOnlyFieldsFromSchema, excludeWriteOnlyFieldsFromSchema, externalEventTypeToDataCollectionEventType, externalEventTypeToSubscriptionType, extractFieldLocator, extractIntegrationAppErrorData, findUdmCollectionMapping, findUdmDefaultCollection, findUdmRootLocation, findValueLocators, generateExampleFromSchema, getActionInstanceVariableSchema, getActionRunTimeVariablesSchema, getAllEventMethodFilePaths, getChildNodeKeys, getDataCollectionCreateFields, getDataCollectionUpdateFields, getDataLocationMethodPath, getDownstreamNodeKeys, getErrorFromData, getEventMethodFileKey, getFilterFieldValuesByLocator, getFlowInstanceNodeDependency, getFlowNode, getFlowNodeConfigTimeVariablesSchema, getFlowNodeDescription, getFlowNodeRunTimeVariablesSchema, getFlowNodeSpec, getFlowNodeTitle, getFormula, getFormulaLocators, getFullNameForLocator, getFullTitleForLocator, getIconUriForLocator, getLocatorsFromData, getLocatorsFromSchema, getMissingRequiredFields, getNameComponentsForLocator, getNameForLocator, getNodeInputSchema, getOperatorsBySchema, getParentNodeKeys, getReferenceCollectionPathForSchema, getReferenceCollectionPointerForSchema, getRequiredFieldsFromSchema, getRootNodeKeys, getSchemaByLocator, getSchemaFromValue, getUpstreamNodeKeys, getValueAtLocator, getValueByLocator, getVariableLocators, getWritableFieldsSchema, hasCycles, hasFormulas, isDataActionType, isDataLocationMethodSupported, isFormula, isIntegrationAppError, isObject, isSameDataLocation, isSchemaEmpty, isStream, isValidLocator, locatorToField, locatorToSteps, locatorToString, makeDataLocationOperationPath, makeDataLocationPath, makeDataRecordSchema, makeObjectPropertyLocator, makeSchemaForLocator, mergeSchemas, mergeWithFormulas, nonEmptyObjectProperties, parseDataLocationPath, parseDate, patchSchema, pickFieldsFromSchema, pickFieldsFromValue, populateSchemaTitles, processCopy, processValue, removeNonExistentVars, removeRequiredFieldsFromSchema, resolveFormulas, resolveValue, schemaAllowsCustomValue, schemaHasFixedValues, schemaHasProperties, schemaIsNumber, schemaIsScalar, schemaTypeFromValue, schemaWithTitle, setSchemaAtLocator, setValueAtLocator, stepsToLocator, streamToString, transformVariablesWith, transformVars, truncateData, unwrapSchema, unwrapSchemas, updateFlowInstanceSchema, updateImpliedSchema, valueToSchema, valueToString, walkSchema, wrapAnyOfSchema };
export type { Action, ActionDependency, ActionInstance, ActionInstanceSelector, ActionRunResponse, ActionSelector, ActionSpec, ApiRequestSpec, App, AppCategory, AppDataSchema, AppDataSchemaInstance, AppDataSchemaInstanceSelector, AppEvent, AppEventSubscription, AppEventSubscriptionCreateRequest, AppEventSubscriptionSelector, AppEventSubscriptionUpdateRequest, AppEventType, AppliedToIntegrations, BaseElementInstance, CaseFormulaValue, CaseFormulaValueItem, CommonInstancesListQuery, CommonIntegrationOrConnectionQuery, CommonListElementsQuery, ConfigurationStateResult, ConnectionDataSpec, ConnectionRequest, ConnectionSelector, ConnectionUdmSpec, ConnectionUiSpec, Connector, ConnectorApiType, ConnectorAuth, ConnectorAuthClientCredentials, ConnectorAuthHandlerBase, ConnectorAuthIntegrationAppToken, ConnectorAuthOAuth1, ConnectorAuthOAuth1Config, ConnectorAuthOAuth2, ConnectorAuthOAuth2Config, ConnectorAuthOAuthConfig, ConnectorAuthProxy, ConnectorAuthSpec, ConnectorAuthType, ConnectorCopilotSuggestion, ConnectorCopilotSuggestionAction, ConnectorDataCollection, ConnectorDataCollectionEvent, ConnectorDataCollectionEventCustomPull, ConnectorDataCollectionEventFullScan, ConnectorDataCollectionEventImplementationTypeKey, ConnectorDataCollectionEventPullLatestRecords, ConnectorDataCollectionEventType, ConnectorDataCollectionEventWebhook, ConnectorDataDirectory, ConnectorDataLocation, ConnectorDataLocationBase, ConnectorDataLocationMethod, ConnectorDataSpec, ConnectorDataUdmSpec, ConnectorEventGlobalWebhookGetEventSelectorResponse, ConnectorEventHandler, ConnectorEventListItem, ConnectorEventSpec, ConnectorGlobalWebhookHandleRequest, ConnectorGlobalWebhookHandleResponse, ConnectorGlobalWebhookHandler, ConnectorGlobalWebhookListItem, ConnectorGlobalWebhookSpec, ConnectorMethodImplementation, ConnectorMethodImplementationBase, ConnectorMethodImplementationGraphqlApiMapping, ConnectorMethodImplementationJavascript, ConnectorMethodImplementationMapping, ConnectorMethodImplementationNotSupported, ConnectorMethodImplementationOperationMapping, ConnectorMethodImplementationRestApiMapping, ConnectorOperationHandler, ConnectorOperationMethod, ConnectorSpec, ConnectorUdmCollectionMapping, ConnectorUdmListLitem, ConnectorUdmSpec, ConnectorUiSpec, CopilotAction, CopilotActionReference, CopilotActivity, CopilotActivityDataTask, CopilotActivityNotificationData, CopilotTask, CreateActionInstanceRequest, CreateActionRequest, CreateAppDataSchemaInstanceRequest, CreateAppDataSchemaRequest, CreateAppEventTypeRequest, CreateCustomerRequest, CreateDataLinkRequest, CreateDataLinkTableInstanceRequest, CreateDataLinkTableRequest, CreateDataSourceInstanceRequest, CreateDataSourceRequest, CreateFieldMappingInstanceRequest, CreateFieldMappingRequest, CreateFlowInstanceRequest, CreateFlowNodeRequest, CreateFlowRequest, CreateFlowRunRequest, CreateIntegrationRequest, CreateScenarioRequest, CreateScenarioTemplateRequest, CreateScreenRequest, CreateUserRequest, Customer, CustomerSelector, DataCollectionCreateRequest, DataCollectionCreateResponse, DataCollectionCreateSpec, DataCollectionDeleteRequest, DataCollectionDeleteResponse, DataCollectionDeleteSpec, DataCollectionEvent, DataCollectionEventTypeSpec, DataCollectionEventsRequest, DataCollectionEventsResponse, DataCollectionEventsSpec, DataCollectionFindByIdRequest, DataCollectionFindByIdResponse, DataCollectionFindByIdSpec, DataCollectionFindRequest, DataCollectionFindResponse, DataCollectionFindSpec, DataCollectionListRequest, DataCollectionListResponse, DataCollectionListResponseDrilldown, DataCollectionListSpec, DataCollectionMatchRequest, DataCollectionMatchResponse, DataCollectionMatchSpec, DataCollectionMethodRequest, DataCollectionMethodSpec, DataCollectionParseUnifiedFieldsRequest, DataCollectionParseUnifiedFieldsResponse, DataCollectionSearchRequest, DataCollectionSearchResponse, DataCollectionSearchSpec, DataCollectionSpec, DataCollectionSubscribeRequest, DataCollectionSubscribeResponse, DataCollectionUdmSpec, DataCollectionUdmsSpec, DataCollectionUnsubscribeRequest, DataCollectionUnsubscribeResponse, DataCollectionUpdateRequest, DataCollectionUpdateResponse, DataCollectionUpdateSpec, DataCollectionUpdateSubscriptionRequest, DataCollectionUpdateSubscriptionResponse, DataDirectoryListRequest, DataDirectoryListResponse, DataDirectorySpec, DataEventWebhookPayload, DataFilter, DataFormArgs, DataLink, DataLinkInTableSelector, DataLinkSelector, DataLinkTable, DataLinkTableConfig, DataLinkTableInstance, DataLinkTableInstanceSelector, DataLocation, DataLocationListItem, DataLocationMixin, DataLocationPointer, DataLocationSpec, DataLocator, DataRecord, DataSchema, DataSource, DataSourceInstance, DataSourceInstanceSelector, DataSourceSelector, DataSourceUnitConfig, DeleteDataLinkRequest, DownstreamFlowNodeRun, ElementInstanceFields, ElementInstanceSelector, ElementTemplateFields, EngineWorkspace, EngineWorkspaceSettings, EngineWorkspaceWithOrgData, EvalOperator, ExternalEvent, ExternalEventCustomPullCollectEventsRequest, ExternalEventCustomPullCollectEventsResponse, ExternalEventCustomPullSubscribeResponse, ExternalEventLogRecord, ExternalEventPull, ExternalEventSubscription, ExternalEventSubscriptionConfig, ExternalEventUnitConfig, ExternalEventWebhookHandleRequest, ExternalEventWebhookHandleResponse, ExternalEventWebhookRefreshRequest, ExternalEventWebhookRefreshResponse, ExternalEventWebhookSubscribeRequest, ExternalEventWebhookSubscribeResponse, ExternalEventWebhookUnsubscribeRequest, FieldMapping, FieldMappingInstance, FieldMappingInstanceSelector, FieldMappingSelector, FieldMappingUnitConfig, FieldValueOption, FindActionInstancesQuery, FindActionsQuery, FindAppDataSchemaInstancesQuery, FindAppDataSchemasQuery, FindAppEventSubscriptionsQuery, FindAppEventTypesQuery, FindAppEventsQuery, FindConnectionsQuery, FindCustomersQuery, FindDataLinkQuery, FindDataLinkTableInstancesQuery, FindDataLinkTablesQuery, FindDataLinksInTableQuery, FindDataLinksQuery, FindDataLinksResponse, FindDataSourceEventsQuery, FindDataSourceInstanceSyncsQuery, FindDataSourceInstancesQuery, FindDataSourceInstancesResponse, FindDataSourceSyncsQuery, FindDataSourcesQuery, FindExternalEventLogsQuery, FindExternalEventPullsQuery, FindExternalEventSubscriptionsQuery, FindFieldMappingInstancesQuery, FindFieldMappingsQuery, FindFlowInstancesQuery, FindFlowRunsQuery, FindFlowRunsResponse, FindFlowsQuery, FindIntegrationsQuery, FindIntegrationsResponse, FindScenarioTemplatesQuery, FindScenariosQuery, FindScreensQuery, FindUsersQuery, Flow, FlowInstance, FlowInstanceNode, FlowInstanceSelector, FlowNode, FlowNodeHandlerRunResponse, FlowNodeLink, FlowNodeRunOutput, FlowNodeRunOutputWithoutDownstreamRuns, FlowNodeRunParameters, FlowNodeRunRecord, FlowNodeRunRecordWithoutOutputsData, FlowNodeRunResult, FlowRun, FlowRunLaunchedBy, FlowRunNode, FlowSelector, GraphQLApiMapping, GraphQLFieldMapping, GraphqlApiClientInput, HandyScenarioTemplateElement, HttpRequestSpec, IWorkspaceUpdate, IncludeArchivedQuery, Integration, IntegrationAuthOption, IntegrationElement, IntegrationElementInstance, IntegrationElementInstanceDependency, IntegrationSpecificElementSelector, ListActionInstancesForConnectionQuery, ListActionsForIntegrationQuery, ListDataSourceInstancesForConnectionQuery, ListDataSourcesForIntegrationQuery, ListFieldMappingInstancesForConnectionQuery, ListFieldMappingsForIntegrationQuery, ListFlowInstancesForConnectionQuery, ListFlowsForIntegrationQuery, LogRecord, LookupValue, MappingItem, MinimalConnector, OpenActionConfigurationOptions, OpenDataSourceConfigurationOptions, OpenFieldMappingInstanceConfigurationOptions, OpenFlowInstanceConfigurationOptions, OpenFlowInstanceEditorOptions, OpenNewConnectionOptions, OpenapiMapping, OperationListItem, OperationMapping, OperationRunRequest, OperationRunResponse, OperationSpec, Org, OrgLimits, OrgUser, OrgWorkspace, PaginationQuery, PatchSchemaOption, PlatformUser, PullLatestRecordsEventOutput, ResetFlowInstanceOptions, RestApiClientInput, RestApiClientOptions, RestApiClientOutput, RestApiClientOverride, RestApiClientResponseHandler, RestApiMapping, RunFlowOptions, Scenario, ScenarioElement, ScenarioTemplate, ScenarioTemplateElementOverride, ScenarioTemplateElements, ScenarioTemplateIntegration, ScenarioTemplateKeyCollision, ScenarioToDo, Screen, ScreenBlock, ScreenSelector, SearchQuery, Self, UnifiedDataModel, UpdateActionInstanceRequest, UpdateActionRequest, UpdateAppDataSchemaInstanceRequest, UpdateAppDataSchemaRequest, UpdateAppEventTypeRequest, UpdateCustomerRequest, UpdateDataLinkTableInstanceRequest, UpdateDataLinkTableRequest, UpdateDataSourceInstanceRequest, UpdateDataSourceRequest, UpdateFieldMappingInstanceRequest, UpdateFieldMappingRequest, UpdateFlowInstanceRequest, UpdateFlowRequest, UpdateIntegrationRequest, UpdateScenarioRequest, UpdateScenarioTemplateRequest, UpdateScreenRequest, UpdateUserRequest, UpstreamFlowNodeRun, UsageEntry, UsageWithCredits, User, UserSelector, UserWorkspaceSettings, ValueToSchemaOptions, Webhook, WebhookType, WithExecutionLogs, Workspace, WorkspaceElement, WorkspaceElementCalculateStateResult, WorkspaceElementDependency, WorkspaceElementReference, WorkspaceElementSpec, WorkspaceElements, WorkspaceLimit, WorkspaceLimits, WorkspaceNotification, WorkspaceUpdate, WorkspaceUser };
