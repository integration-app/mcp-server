'use strict';

var zod = require('zod');
var qs = require('qs');
var insertCss = require('insert-css');
var penpal = require('penpal');
var jsConvertCase = require('js-convert-case');
var structuredClonePolyfill = require('@ungap/structured-clone');
var humanparser = require('humanparser');
var jsonata = require('jsonata');
var deepEqual = require('fast-deep-equal');
var urljoin = require('url-join');
var axiosOriginal = require('axios');

exports.LogRecordType = void 0;
(function (LogRecordType) {
    LogRecordType["MSG"] = "message";
    LogRecordType["TEXT"] = "text";
    LogRecordType["ERR"] = "error";
    LogRecordType["DATA"] = "data";
    LogRecordType["COMP"] = "compare";
    LogRecordType["API"] = "api-request";
})(exports.LogRecordType || (exports.LogRecordType = {}));

function isStream(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        typeof obj.pipe === 'function' &&
        (typeof obj.readable === 'boolean' || typeof obj.writable === 'boolean'));
}
async function streamToString(stream) {
    return new Promise((resolve, reject) => {
        let result = '';
        if (stream.closed) {
            resolve('');
        }
        stream.on('data', (chunk) => {
            result += chunk.toString();
        });
        stream.on('end', () => {
            resolve(result);
        });
        stream.on('error', (err) => {
            reject(err);
        });
    });
}
function truncateData(data, depth = 0) {
    const maxArrayItems = 500;
    const maxObjectKeys = 500;
    const maxStringLength = 500;
    const maxDepth = 15;
    if (depth > maxDepth) {
        return '<max depth reached>';
    }
    if (!data) {
        return data;
    }
    else if (Array.isArray(data)) {
        const result = data
            .slice(0, maxArrayItems)
            .map((item) => truncateData(item, depth + 1));
        if (data.length > maxArrayItems) {
            result.push({
                '...moreItems': data.length - maxArrayItems,
            });
        }
        return result;
    }
    else if (Buffer.isBuffer(data)) {
        return data.toString('utf-8').slice(0, maxStringLength);
    }
    else if (typeof data === 'object') {
        const keys = Object.keys(data);
        const result = {};
        for (const key of keys.slice(0, maxObjectKeys)) {
            result[key] = truncateData(data[key], depth + 1);
        }
        if (keys.length > maxObjectKeys) {
            result['...moreKeys'] = keys
                .slice(maxObjectKeys)
                .join(', ')
                .slice(0, maxStringLength);
        }
        return result;
    }
    else if (typeof data === 'string' && data.length > maxStringLength) {
        return `${data.slice(0, maxStringLength)}...`;
    }
    else {
        return data;
    }
}

exports.ErrorDoc = void 0;
(function (ErrorDoc) {
    ErrorDoc["AuthenticationTokenErrors"] = "authentication-token-errors";
    ErrorDoc["DataSourceNoCollectionSelected"] = "data-source-no-collection-selected";
    ErrorDoc["FlowInstanceSetupFailed"] = "flow-instance-setup-failed";
    ErrorDoc["FlowInstanceSetupTimeout"] = "flow-instance-setup-timeout";
    ErrorDoc["WebhookCannotFindUser"] = "webhook-cannot-find-user";
})(exports.ErrorDoc || (exports.ErrorDoc = {}));

exports.ErrorType = void 0;
(function (ErrorType) {
    ErrorType["BAD_REQUEST"] = "bad_request";
    ErrorType["CONNECTION"] = "connection";
    ErrorType["CONFIGURATION"] = "configuration";
    ErrorType["DEPENDENCY_ERROR"] = "dependency_error";
    ErrorType["FLOW_RUN"] = "flow_run";
    ErrorType["FLOW_INSTANCE_SETUP"] = "flow_instance_setup";
    ErrorType["CONCURRENCY"] = "concurrency";
    ErrorType["INTERNAL"] = "internal";
    ErrorType["ACTION_RUN"] = "action_run";
    ErrorType["ACTION_INSTANCE_SETUP"] = "action_instance_setup";
    ErrorType["UNIT_RUN"] = "unit_run";
})(exports.ErrorType || (exports.ErrorType = {}));
exports.BadRequestErrorKey = void 0;
(function (BadRequestErrorKey) {
    BadRequestErrorKey["NOT_FOUND"] = "not_found";
    BadRequestErrorKey["NOT_AUTHENTICATED"] = "not_authenticated";
    BadRequestErrorKey["ACCESS_DENIED"] = "access_denied";
    BadRequestErrorKey["ALREADY_EXISTS"] = "already_exists";
    BadRequestErrorKey["RATE_LIMIT_EXCEEDED"] = "rate_limit_exceeded";
})(exports.BadRequestErrorKey || (exports.BadRequestErrorKey = {}));
exports.ConnectionErrorKey = void 0;
(function (ConnectionErrorKey) {
    ConnectionErrorKey["CONNECTION_IS_DEFUNCT"] = "connection_is_defunct";
    ConnectionErrorKey["ACCESS_TOKEN_EXPIRED"] = "access_token_expired";
    ConnectionErrorKey["RATE_LIMIT_EXCEEDED"] = "rate_limit_exceeded";
})(exports.ConnectionErrorKey || (exports.ConnectionErrorKey = {}));
exports.ConcurrencyErrorKey = void 0;
(function (ConcurrencyErrorKey) {
    ConcurrencyErrorKey["LOCK_TIMEOUT"] = "lock_timeout";
})(exports.ConcurrencyErrorKey || (exports.ConcurrencyErrorKey = {}));
function isIntegrationAppError(error) {
    return error && error.isIntegrationAppError;
}
class ErrorData {
    constructor(arg) {
        if (arg instanceof Error) {
            this.message = arg.message;
            this.stack = arg.stack;
            this.type = exports.ErrorType.INTERNAL;
        }
        else if (typeof arg === 'string') {
            this.message = arg;
            this.type = exports.ErrorType.INTERNAL;
        }
        else if (typeof arg === 'object' && arg !== null) {
            Object.assign(this, arg);
        }
        else {
            throw new Error('Invalid argument when creating BaseErrorData: ' + JSON.stringify(arg));
        }
    }
}
class IntegrationAppError extends Error {
    constructor(arg) {
        const errorData = new ErrorData(arg);
        super(errorData.message);
        this.isIntegrationAppError = true;
        this.data = errorData;
        if (!this.data.type) {
            this.data.type = exports.ErrorType.INTERNAL;
        }
        if (typeof window !== 'undefined') {
            this.message = buildUserFriendlyErrorMessage(this.data);
        }
    }
}
class InternalError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.INTERNAL;
    }
}
class BadRequestError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.BAD_REQUEST;
    }
}
class ConcurrencyError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.CONCURRENCY;
    }
}
class ConfigurationError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.CONFIGURATION;
    }
}
class DependencyError extends IntegrationAppError {
    constructor(arg, workspaceElementReference) {
        super(arg);
        this.data.type = exports.ErrorType.DEPENDENCY_ERROR;
        this.data.data = { workspaceElementReference };
    }
}
class FlowInstanceSetupError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.FLOW_INSTANCE_SETUP;
    }
}
class FlowRunError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.FLOW_RUN;
    }
}
class ActionRunError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.ACTION_RUN;
    }
}
class ActionInstanceSetupError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.ACTION_INSTANCE_SETUP;
    }
}
class UnitRunError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.UNIT_RUN;
    }
}
class ConnectionError extends IntegrationAppError {
    constructor(arg) {
        super(arg);
        this.data.type = exports.ErrorType.CONNECTION;
    }
}
class NotFoundError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.key = exports.BadRequestErrorKey.NOT_FOUND;
    }
}
class RateLimitExceededError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.key = exports.BadRequestErrorKey.RATE_LIMIT_EXCEEDED;
    }
}
class NotAuthenticatedError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.key = exports.BadRequestErrorKey.NOT_AUTHENTICATED;
    }
}
class AccessDeniedError extends BadRequestError {
    constructor(arg) {
        super(arg);
        this.data.key = exports.BadRequestErrorKey.ACCESS_DENIED;
    }
}
const ERROR_CLASS_BY_TYPE = {
    [exports.ErrorType.BAD_REQUEST]: BadRequestError,
    [exports.ErrorType.CONNECTION]: ConnectionError,
    [exports.ErrorType.CONFIGURATION]: ConfigurationError,
    [exports.ErrorType.DEPENDENCY_ERROR]: DependencyError,
    [exports.ErrorType.FLOW_RUN]: FlowRunError,
    [exports.ErrorType.FLOW_INSTANCE_SETUP]: FlowInstanceSetupError,
    [exports.ErrorType.INTERNAL]: InternalError,
    [exports.ErrorType.CONCURRENCY]: ConcurrencyError,
    [exports.ErrorType.ACTION_RUN]: ActionRunError,
    [exports.ErrorType.ACTION_INSTANCE_SETUP]: ActionInstanceSetupError,
    [exports.ErrorType.UNIT_RUN]: UnitRunError,
};
function getErrorFromData(data) {
    if (typeof data === 'object' &&
        data !== null &&
        Object.values(exports.ErrorType).includes(data.type) &&
        data.type in ERROR_CLASS_BY_TYPE) {
        return new ERROR_CLASS_BY_TYPE[data.type](data);
    }
    return null;
}
function extractIntegrationAppErrorData(error) {
    var _a, _b;
    const errorMessage = error.message || ((_a = error.toString) === null || _a === void 0 ? void 0 : _a.call(error));
    const data = error.isIntegrationAppError
        ? error.data
        : new ErrorData({
            message: errorMessage,
            type: exports.ErrorType.INTERNAL,
        });
    if (!data.message) {
        data.message = errorMessage;
    }
    if (!data.data && ((_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.data)) {
        if (isStream(error.response.data)) {
            data.data = streamToString(error.response.data);
        }
        else if (error.response.data instanceof ArrayBuffer) {
            data.data = Buffer.from(error.response.data).toString('utf-8');
        }
        else {
            data.data = error.response.data;
        }
    }
    return data;
}
function buildUserFriendlyErrorMessage({ message, doc }) {
    const docsLink = !doc
        ? ''
        : `https://console.integration.app/docs/errors/${doc}`;
    return `${message} ${docsLink}`;
}

exports.ConfigurationState = void 0;
(function (ConfigurationState) {
    ConfigurationState["CONFIGURED"] = "CONFIGURED";
    ConfigurationState["NOT_CONFIGURED"] = "NOT_CONFIGURED";
})(exports.ConfigurationState || (exports.ConfigurationState = {}));
exports.WorkspaceElementType = void 0;
(function (WorkspaceElementType) {
    WorkspaceElementType["Customer"] = "customer";
    WorkspaceElementType["Connector"] = "connector";
    WorkspaceElementType["Integration"] = "integration";
    WorkspaceElementType["Flow"] = "flow";
    WorkspaceElementType["FlowInstance"] = "flow-instance";
    WorkspaceElementType["FlowRun"] = "flow-run";
    WorkspaceElementType["Action"] = "action";
    WorkspaceElementType["Scenario"] = "scenario";
    WorkspaceElementType["ActionInstance"] = "action-instance";
    WorkspaceElementType["Connection"] = "connection";
    WorkspaceElementType["FieldMapping"] = "field-mapping";
    WorkspaceElementType["FieldMappingInstance"] = "field-mapping-instance";
    WorkspaceElementType["DataSource"] = "data-source";
    WorkspaceElementType["DataSourceInstance"] = "data-source-instance";
    WorkspaceElementType["DataLinkTable"] = "data-link-table";
    WorkspaceElementType["DataLinkTableInstance"] = "data-link-table-instance";
    WorkspaceElementType["AppEventType"] = "app-event-type";
    WorkspaceElementType["AppEventSubscription"] = "app-event-subscription";
    WorkspaceElementType["AppDataSchema"] = "app-data-schema";
    WorkspaceElementType["AppDataSchemaInstance"] = "app-data-schema-instance";
    WorkspaceElementType["ExternalEventSubscription"] = "external-event-subscription";
    WorkspaceElementType["ExternalEventLogRecord"] = "external-event-log-record";
    WorkspaceElementType["ExternalEventPull"] = "external-event-pull";
    WorkspaceElementType["Screen"] = "screen";
})(exports.WorkspaceElementType || (exports.WorkspaceElementType = {}));
exports.WorkspaceEventType = void 0;
(function (WorkspaceEventType) {
    WorkspaceEventType["ConnectionCreated"] = "connection.created";
    WorkspaceEventType["ConnectionDeleted"] = "connection.deleted";
    WorkspaceEventType["ConnectionDisconnected"] = "connection.disconnected";
    WorkspaceEventType["ConnectionReconnected"] = "connection.reconnected";
    WorkspaceEventType["FlowRunQueued"] = "flowRun.queued";
    WorkspaceEventType["FlowRunStarted"] = "flowRun.started";
    WorkspaceEventType["FlowRunCompleted"] = "flowRun.completed";
    WorkspaceEventType["FlowRunFailed"] = "flowRun.failed";
    WorkspaceEventType["FlowRunStopped"] = "flowRun.stopped";
})(exports.WorkspaceEventType || (exports.WorkspaceEventType = {}));
exports.WorkspaceElementState = void 0;
(function (WorkspaceElementState) {
    WorkspaceElementState["SETTING_UP"] = "SETTING_UP";
    WorkspaceElementState["CONFIGURATION_ERROR"] = "CONFIGURATION_ERROR";
    WorkspaceElementState["SETUP_FAILED"] = "SETUP_FAILED";
    WorkspaceElementState["READY"] = "READY";
})(exports.WorkspaceElementState || (exports.WorkspaceElementState = {}));
exports.WorkspaceElementDependencyType = void 0;
(function (WorkspaceElementDependencyType) {
    WorkspaceElementDependencyType["Configuration"] = "CONFIGURATION";
    WorkspaceElementDependencyType["Parent"] = "PARENT";
})(exports.WorkspaceElementDependencyType || (exports.WorkspaceElementDependencyType = {}));

const flowNodeLinkSchema = zod.z.object({
    key: zod.z.string().optional(),
    filter: zod.z.any().optional(),
    name: zod.z.string().optional(),
});
const flowInstanceNodeCreateSchema = zod.z.object({
    name: zod.z.string().optional(),
    type: zod.z.string().optional(),
    userConfig: zod.z.any().optional(),
    config: zod.z.any().optional(),
    onError: zod.z.enum(['stop', 'continue']).optional(),
    concurrency: zod.z.number().optional(),
    ui: zod.z.any().optional(),
    links: zod.z.array(flowNodeLinkSchema).optional(),
    isCustomized: zod.z.boolean().optional(),
});
const flowInstanceNodeUpdateSchema = zod.z.object({
    name: zod.z.string().optional(),
    type: zod.z.string().optional(),
    userConfig: zod.z.any().optional(),
    config: zod.z.any().optional(),
    onError: zod.z.enum(['stop', 'continue']).optional(),
    links: zod.z.array(flowNodeLinkSchema).optional(),
    concurrency: zod.z.number().optional(),
    isCustomized: zod.z.boolean().optional(),
});
const createFlowInstanceSchema = zod.z.object({
    name: zod.z.string().optional(),
    userId: zod.z.string().optional(),
    flowId: zod.z.string().optional(),
    connectionId: zod.z.string().optional(),
    integrationId: zod.z.string().optional(),
    instanceKey: zod.z.string().optional(),
    parameters: zod.z.any().optional(),
    nodes: zod.z.record(zod.z.string(), flowInstanceNodeCreateSchema).optional(),
    enabled: zod.z.boolean().optional(),
    customized: zod.z
        .object({
        name: zod.z.boolean().optional(),
        nodes: zod.z.boolean().optional(),
    })
        .optional(),
});
const updateFlowInstanceSchema = zod.z.object({
    name: zod.z.string().optional(),
    enabled: zod.z.boolean().optional(),
    parameters: zod.z.any().optional(),
    nodes: zod.z.record(zod.z.string(), flowInstanceNodeUpdateSchema).optional(),
    archivedAt: zod.z.string().optional(),
    customized: zod.z
        .object({
        name: zod.z.boolean().optional(),
        nodes: zod.z.boolean().optional(),
    })
        .optional(),
});

const WorkspaceElementSpecs = {
    [exports.WorkspaceElementType.Customer]: {
        type: exports.WorkspaceElementType.Customer,
    },
    [exports.WorkspaceElementType.Connector]: {
        type: exports.WorkspaceElementType.Connector,
    },
    [exports.WorkspaceElementType.Integration]: {
        type: exports.WorkspaceElementType.Integration,
    },
    [exports.WorkspaceElementType.Flow]: {
        type: exports.WorkspaceElementType.Flow,
    },
    [exports.WorkspaceElementType.FlowInstance]: {
        type: exports.WorkspaceElementType.FlowInstance,
        createSchema: createFlowInstanceSchema,
        updateSchema: updateFlowInstanceSchema,
    },
    [exports.WorkspaceElementType.FlowRun]: {
        type: exports.WorkspaceElementType.FlowRun,
    },
    [exports.WorkspaceElementType.Action]: {
        type: exports.WorkspaceElementType.Action,
    },
    [exports.WorkspaceElementType.Scenario]: {
        type: exports.WorkspaceElementType.Scenario,
    },
    [exports.WorkspaceElementType.ActionInstance]: {
        type: exports.WorkspaceElementType.ActionInstance,
    },
    [exports.WorkspaceElementType.Connection]: {
        type: exports.WorkspaceElementType.Connection,
    },
    [exports.WorkspaceElementType.FieldMapping]: {
        type: exports.WorkspaceElementType.FieldMapping,
    },
    [exports.WorkspaceElementType.FieldMappingInstance]: {
        type: exports.WorkspaceElementType.FieldMappingInstance,
    },
    [exports.WorkspaceElementType.DataSource]: {
        type: exports.WorkspaceElementType.DataSource,
    },
    [exports.WorkspaceElementType.DataSourceInstance]: {
        type: exports.WorkspaceElementType.DataSourceInstance,
    },
    [exports.WorkspaceElementType.DataLinkTable]: {
        type: exports.WorkspaceElementType.DataLinkTable,
    },
    [exports.WorkspaceElementType.DataLinkTableInstance]: {
        type: exports.WorkspaceElementType.DataLinkTableInstance,
    },
    [exports.WorkspaceElementType.AppEventType]: {
        type: exports.WorkspaceElementType.AppEventType,
    },
    [exports.WorkspaceElementType.AppEventSubscription]: {
        type: exports.WorkspaceElementType.AppEventSubscription,
    },
    [exports.WorkspaceElementType.AppDataSchema]: {
        type: exports.WorkspaceElementType.AppDataSchema,
    },
    [exports.WorkspaceElementType.AppDataSchemaInstance]: {
        type: exports.WorkspaceElementType.AppDataSchemaInstance,
    },
    [exports.WorkspaceElementType.ExternalEventSubscription]: {
        type: exports.WorkspaceElementType.ExternalEventSubscription,
    },
    [exports.WorkspaceElementType.ExternalEventLogRecord]: {
        type: exports.WorkspaceElementType.ExternalEventLogRecord,
    },
    [exports.WorkspaceElementType.ExternalEventPull]: {
        type: exports.WorkspaceElementType.ExternalEventPull,
    },
    [exports.WorkspaceElementType.Screen]: {
        type: exports.WorkspaceElementType.Screen,
    },
};

class ElementAccessor {
    constructor(options) {
        this.options = options;
    }
    getUniqueIdentifier() {
        return this.getPath();
    }
    async get() {
        return this.options.client.get(this.getPath());
    }
    async put(data) {
        return this.options.client.put(this.getPath(), data);
    }
    async patch(data) {
        return this.options.client.patch(this.getPath(), data);
    }
    async archive() {
        await this.options.client.delete(this.getPath());
    }
    getPath(operation = '') {
        const { path, selector } = this.options;
        if (typeof selector === 'string') {
            return `${path}s/${selector}${operation ? '/' + operation : ''}`;
        }
        const query = qs.stringify(selector);
        return `${path}${operation ? '/' + operation : ''}?${query}`;
    }
}
class ElementListAccessor {
    constructor(client, path) {
        this.client = client;
        this.path = path;
    }
    async find(query) {
        return this.client.get(this.path, query);
    }
    async findAll(query) {
        let allItems = [];
        let currentCursor = '0';
        while (true) {
            const { items, cursor } = await this.client.get(this.path, {
                ...query,
                limit: 1000,
                cursor: currentCursor,
            });
            allItems = allItems.concat(items);
            if (!cursor) {
                break;
            }
            else {
                currentCursor = cursor;
            }
        }
        return allItems;
    }
    async create(data) {
        return this.client.post(this.path, data);
    }
}
class ElementInstanceListAccessor {
    constructor(client, path) {
        this.client = client;
        this.path = path;
    }
    async find(query) {
        return this.client.get(this.path, query);
    }
}
class ElementInstanceAccessor {
    constructor(options) {
        this.options = options;
    }
    getUniqueIdentifier() {
        return this.getPath();
    }
    async get() {
        return this.options.client.get(this.getPath());
    }
    async getId() {
        if (!this.id) {
            if (this.options.selector && typeof this.options.selector === 'string') {
                this.id = this.options.selector;
            }
            else {
                const element = await this.get();
                if (!element) {
                    throw new Error(`Element not found using selector ${JSON.stringify(this.options.selector)}`);
                }
                this.id = element.id;
            }
        }
        return this.id;
    }
    async create(data) {
        if (this.id) {
            throw new Error('Cannot create: element already exists');
        }
        if (this.options.type) {
            const createSchema = WorkspaceElementSpecs[this.options.type].createSchema;
            if (createSchema) {
                if (data) {
                    data = createSchema.parse(data);
                }
            }
        }
        const element = await this.options.client.post(this.getPath(), data);
        this.id = element.id;
        return element;
    }
    async put(data) {
        if (this.options.type) {
            const createSchema = WorkspaceElementSpecs[this.options.type].createSchema;
            if (createSchema) {
                data = createSchema.parse(data);
            }
        }
        return this.options.client.put(this.getPath(), data);
    }
    async patch(data) {
        if (this.options.type) {
            const updateSchema = WorkspaceElementSpecs[this.options.type].updateSchema;
            if (updateSchema) {
                data = updateSchema.parse(data);
            }
        }
        return this.options.client.patch(this.getPath(), data);
    }
    async archive() {
        return this.options.client.delete(this.getPath());
    }
    async delete() {
        return this.options.client.delete(this.getPath());
    }
    getPath(operation = '') {
        return (this.options.instancePath +
            (operation ? `/${operation}` : '') +
            '?' +
            qs.stringify(this.getSelector()));
    }
    getSelector() {
        return typeof this.options.selector === 'string'
            ? {
                id: this.options.selector,
            }
            : this.options.selector;
    }
}

const POPUP_ELEMENT_ID = '__integration-app-popup';
const CONTAINER_ELEMENT_ID = '__integration-app-container';
const CONTAINER_ELEMENT_CLASS = '__integration-app-container';
const CONTAINER_ELEMENT_CLASS__LOADER = '__integration-app-container__loader';
const BODY_CLASS = '__integration-app-open';
let initialized = false;
let IFRAME_START_SHOW_LOADER_TIME = 0;
let IFRAME_SHOW_LOADER_TIMEOUT_ID;
const IFRAME_SHOW_LOADER_MINIMAL_TIME = 500;
const IFRAME_LAYOUT_SHIFT_TIME = 300;
function showIframeLoader() {
    if (!initialized) {
        initialized = true;
        init();
    }
    const container = getContainer();
    container === null || container === void 0 ? void 0 : container.classList.add(CONTAINER_ELEMENT_CLASS__LOADER);
    IFRAME_START_SHOW_LOADER_TIME = Date.now();
}
function hideIframeLoader(waitLayoutShift = IFRAME_LAYOUT_SHIFT_TIME) {
    if (IFRAME_SHOW_LOADER_TIMEOUT_ID) {
        clearTimeout(IFRAME_SHOW_LOADER_TIMEOUT_ID);
    }
    const delta = Date.now() - IFRAME_START_SHOW_LOADER_TIME;
    if (delta >= IFRAME_SHOW_LOADER_MINIMAL_TIME) {
        setTimeout(() => {
            const container = getContainer();
            container === null || container === void 0 ? void 0 : container.classList.remove(CONTAINER_ELEMENT_CLASS__LOADER);
            IFRAME_START_SHOW_LOADER_TIME = 0;
        }, waitLayoutShift);
        return;
    }
    else {
        const waitLayoutShift = delta >= IFRAME_LAYOUT_SHIFT_TIME ? 0 : IFRAME_LAYOUT_SHIFT_TIME - delta;
        const timeoutTime = IFRAME_SHOW_LOADER_MINIMAL_TIME - delta;
        IFRAME_SHOW_LOADER_TIMEOUT_ID = setTimeout(() => {
            hideIframeLoader(waitLayoutShift);
        }, timeoutTime);
        return;
    }
}
async function openIframe(uri, callbacks = {}) {
    if (!initialized) {
        initialized = true;
        init();
    }
    close();
    return new Promise((resolve) => {
        function complete(callback) {
            close(callback);
            resolve();
        }
        function doOpen() {
            const iframe = document.createElement('iframe');
            iframe.src = uri;
            iframe.id = POPUP_ELEMENT_ID;
            iframe.onload = () => {
                hideIframeLoader();
            };
            if (!!getContainer()) {
                document.body.classList.add(BODY_CLASS);
                showIframeLoader();
                appendToContainer(iframe);
                penpal.connectToChild({
                    iframe,
                    methods: {
                        ...callbacks,
                        handshake: (...args) => {
                            var _a;
                            hideIframeLoader();
                            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.handshake) === null || _a === void 0 ? void 0 : _a.call(callbacks, ...args);
                        },
                        close: () => complete(callbacks.onClose),
                    },
                });
            }
            else {
                throw Error('Integration.app container element not found. Was it manually removed?');
            }
        }
        if (document.readyState === 'complete' ||
            document.readyState === 'interactive') {
            doOpen();
        }
        else {
            document.addEventListener('DOMContentLoaded', () => {
                doOpen();
            });
        }
    });
}
function close(callback) {
    document.body.classList.remove(BODY_CLASS);
    if (!!getContainer()) {
        clearContainer();
        if (callback) {
            callback();
        }
    }
}
function init() {
    if (!!getContainer()) {
        return;
    }
    insertCss.insertCss(`
    .${CONTAINER_ELEMENT_CLASS}:empty {
      display: none;
    }
    .${CONTAINER_ELEMENT_CLASS} {
      position: fixed;
      inset: 0;
      z-index: 2147483647;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: auto;
      background: rgba(0, 0, 0, 0);
      transition: background 0.2s ease-out;
    }

    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER} {
      background: rgba(0, 0, 0, 0.8);
    }
    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER}::before {
      content: "";
      width: 5rem;
      height: 4rem;
      background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 32 22" fill="%23000" xmlns="http://www.w3.org/2000/svg" %3E%3Cdefs%3E%3Cmask id="a"%3E%3Crect width="100%25" height="100%25" fill="%23fff" /%3E%3Cpath d="M11.8 13.12a3 3 0 0 1 0-4.24l7.08-7.07a3 3 0 0 1 4.24 0l7.07 7.07a3 3 0 0 1 0 4.24l-7.07 7.07a3 3 0 0 1-4.24 0l-7.07-7.07Z"%3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 21 11" to="-360 21 11" /%3E%3C/path%3E%3C/mask%3E%3Cmask id="b"%3E%3Crect width="100%25" height="100%25" fill="%23fff"/%3E%3Cpath fill-rule="evenodd" clip-rule="evenodd" d="M1.8 8.88a3 3 0 0 0 0 4.24l7.08 7.07a3 3 0 0 0 4.24 0l7.07-7.07a3 3 0 0 0 0-4.24L13.12 1.8a3 3 0 0 0-4.24 0L1.8 8.88Zm.71.7a2 2 0 0 0 0 2.83L9.6 19.5a2 2 0 0 0 2.82 0l7.08-7.08a2 2 0 0 0 0-2.82l-7.1-7.1a2 2 0 0 0-2.82 0L2.5 9.6Z" %3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 11 11" to="720 11 11" /%3E%3C/path%3E%3C/mask%3E%3C/defs%3E%3Cg mask="url(%23a)"%3E%3Cpath fill-rule="evenodd" clip-rule="evenodd" d="M1.8 8.88a3 3 0 0 0 0 4.24l7.08 7.07a3 3 0 0 0 4.24 0l7.07-7.07a3 3 0 0 0 0-4.24L13.12 1.8a3 3 0 0 0-4.24 0L1.8 8.88Zm.71.7a2 2 0 0 0 0 2.83L9.6 19.5a2 2 0 0 0 2.82 0l7.08-7.08a2 2 0 0 0 0-2.82l-7.1-7.1a2 2 0 0 0-2.82 0L2.5 9.6Z"%0A%3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 11 11" to="720 11 11" /%3E%3C/path%3E%3C/g%3E%3Cg mask="url(%23b)"%3E%3Cpath d="M11.8 13.12a3 3 0 0 1 0-4.24l7.08-7.07a3 3 0 0 1 4.24 0l7.07 7.07a3 3 0 0 1 0 4.24l-7.07 7.07a3 3 0 0 1-4.24 0l-7.07-7.07Z"%3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 21 11" to="-360 21 11" /%3E%3C/path%3E%3C/g%3E%3C/svg%3E');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      filter: invert(1);
    }

    .${CONTAINER_ELEMENT_CLASS} iframe {
      position: absolute;
      width: 100%;
      height: 100%;
      border-width: 0;

      /* fix transparent bg, because iframe document has light scheme */
      color-scheme: light;
    }

    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER} iframe {
      visibility: hidden;
    }

    body.${BODY_CLASS} {
      overflow: hidden;
    }
  `);
    const container = document.createElement('div');
    container.id = CONTAINER_ELEMENT_ID;
    container.classList.add(CONTAINER_ELEMENT_CLASS);
    document.body.appendChild(container);
}
function getContainer() {
    return document.getElementById(CONTAINER_ELEMENT_ID);
}
function appendToContainer(el) {
    const container = getContainer();
    container === null || container === void 0 ? void 0 : container.appendChild(el);
}
function clearContainer() {
    const container = getContainer();
    if (container.firstChild) {
        container.removeChild(container.firstChild);
    }
}

class ConnectionLevelElementAccessor {
    constructor(client, connectionSelector, selector, elementKey, query) {
        this.client = client;
        this.connectionSelector = connectionSelector;
        this.selector = selector;
        this.elementKey = elementKey;
        this.query = query;
        this.endpoint = `/connections/${this.connectionSelector}/${elementKey}/${selector}`;
    }
    uri(path = '', query = {}) {
        return (this.endpoint + path + '?' + qs.stringify({ ...this.query, ...query }));
    }
    getUniqueIdentifier() {
        return this.endpoint;
    }
    async get(query = {}) {
        return this.client.get(this.uri('', query));
    }
    async create() {
        return this.client.put(this.uri());
    }
    async patch(data) {
        return this.client.patch(this.uri(), data);
    }
    async put(data) {
        return this.client.put(this.uri(), data);
    }
    async archive() {
        return this.client.delete(this.uri());
    }
    async reset() {
        return this.client.post(this.uri('/reset'));
    }
    async setup() {
        return this.client.post(this.uri('/setup'));
    }
}
class ConnectionLevelElementsListAccessor {
    constructor(client, connectionSelector, elementKey) {
        this.client = client;
        this.connectionSelector = connectionSelector;
        this.elementKey = elementKey;
    }
    async list(query) {
        const endpoint = `/connections/${this.connectionSelector}/${this.elementKey}?${qs.stringify(query !== null && query !== void 0 ? query : {})}`;
        return this.client.get(endpoint);
    }
}

class IntegrationLevelElementAccessor {
    constructor(client, integrationSelector, elementSelector, elementKey) {
        this.client = client;
        this.integrationSelector = integrationSelector;
        this.elementSelector = elementSelector;
        this.elementKey = elementKey;
        this.endpoint = `/integrations/${this.integrationSelector}/${elementKey}/${elementSelector}`;
    }
    getUniqueIdentifier() {
        return this.endpoint;
    }
    async get() {
        return this.client.get(this.endpoint);
    }
    async patch(data) {
        return this.client.patch(this.endpoint, data);
    }
    async put(data) {
        return this.client.put(this.endpoint, data);
    }
    async archive() {
        return this.client.delete(this.endpoint);
    }
    async reset() {
        return this.client.post(this.endpoint + '/reset');
    }
}
class IntegrationLevelElementsListAccessor {
    constructor(client, integrationSelector, elementKey) {
        this.client = client;
        this.integrationSelector = integrationSelector;
        this.elementKey = elementKey;
        this.endpoint = `/integrations/${integrationSelector}/${elementKey}`;
    }
    async list(query) {
        return this.client.get(this.endpoint, query !== null && query !== void 0 ? query : {});
    }
    async create(data) {
        return this.client.post(this.endpoint, data);
    }
}

class ActionsAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'actions');
    }
}
class ActionAccessor extends ElementAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            path: 'action',
        });
    }
    async apply(integrationKeys) {
        return await this.options.client.post(this.getPath('apply'), {
            integrationKeys,
        });
    }
    async reset() {
        return await this.options.client.post(this.getPath('reset'));
    }
}
class ActionInstancesAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'action-instances');
    }
}
class ActionInstanceAccessor extends ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            instancePath: 'action-instance',
            selector,
        });
        this.client = client;
    }
    async setup() {
        await this.client.post(this.getPath('setup'));
    }
    async reset() {
        await this.client.post(this.getPath('reset'));
    }
    async run(input) {
        return this.client.post(this.getPath('run'), input);
    }
    async open({ onClose = () => { }, } = {}) {
        const id = await this.getId();
        const uri = await this.client.getEmbedUri(`action-instances/${id}/configuration`);
        return openIframe(uri, { onClose });
    }
}
class IntegrationLevelActionAccessor extends IntegrationLevelElementAccessor {
    constructor(client, integrationSelector, actionSelector) {
        super(client, integrationSelector, actionSelector, 'actions');
        this.client = client;
        this.integrationSelector = integrationSelector;
        this.actionSelector = actionSelector;
    }
}
class IntegrationLevelActionsListAccessor extends IntegrationLevelElementsListAccessor {
    constructor(client, integrationSelector) {
        super(client, integrationSelector, 'actions');
        this.client = client;
        this.integrationSelector = integrationSelector;
    }
}
class ConnectionLevelActionAccessor extends ConnectionLevelElementAccessor {
    constructor(client, connectionSelector, actionSelector, query) {
        super(client, connectionSelector, actionSelector, 'actions', query);
        this.client = client;
        this.connectionSelector = connectionSelector;
        this.actionSelector = actionSelector;
        this.query = query;
    }
    async run(input) {
        return this.client.post(this.uri('/run'), input);
    }
}
class ConnectionLevelActionsAccessor extends ConnectionLevelElementsListAccessor {
    constructor(client, connectionSelector) {
        super(client, connectionSelector, 'actions');
        this.client = client;
        this.connectionSelector = connectionSelector;
    }
}

class FieldMappingsAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'field-mappings');
    }
}
class FieldMappingAccessor extends ElementAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            path: 'field-mapping',
        });
    }
    async getAppSchema() {
        return await this.options.client.get(this.getPath('app-schema'));
    }
    async apply(integrationKeys) {
        return await this.options.client.post(this.getPath('apply'), {
            integrationKeys,
        });
    }
    async reset() {
        return await this.options.client.post(this.getPath('reset'));
    }
}
class FieldMappingInstancesAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'field-mapping-instances');
    }
}
class FieldMappingInstanceAccessor extends ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            instancePath: 'field-mapping-instance',
            selector,
        });
        this.client = client;
    }
    async setup() {
        const id = await this.getId();
        return this.client.post(`/field-mapping-instances/${id}/setup`);
    }
    async reset() {
        const id = await this.getId();
        return this.client.post(`/field-mapping-instances/${id}/reset`);
    }
    async openConfiguration({ onClose = () => { }, } = {}) {
        const id = await this.getId();
        const uri = await this.client.getEmbedUri(`field-mapping-instances/${id}/configuration`);
        return openIframe(uri, {
            onClose,
        });
    }
}
class IntegrationLevelFieldMappingAccessor extends IntegrationLevelElementAccessor {
    constructor(client, integrationSelector, fieldMappingSelector) {
        super(client, integrationSelector, fieldMappingSelector, 'field-mappings');
        this.client = client;
        this.integrationSelector = integrationSelector;
        this.fieldMappingSelector = fieldMappingSelector;
    }
}
class IntegrationLevelFieldMappingsListAccessor extends IntegrationLevelElementsListAccessor {
    constructor(client, integrationSelector) {
        super(client, integrationSelector, 'field-mappings');
        this.client = client;
        this.integrationSelector = integrationSelector;
    }
}
class ConnectionLevelFieldMappingAccessor extends ConnectionLevelElementAccessor {
    constructor(client, connectionSelector, fieldMappingSelector, query) {
        super(client, connectionSelector, fieldMappingSelector, 'field-mappings', query);
        this.client = client;
        this.connectionSelector = connectionSelector;
        this.fieldMappingSelector = fieldMappingSelector;
        this.query = query;
    }
    async openConfiguration({ onClose, } = {}) {
        const instance = await this.get({ autoCreate: true });
        const uri = await this.client.getEmbedUri(`field-mapping-instances/${instance.id}/configuration`);
        return openIframe(uri, { onClose: onClose !== null && onClose !== void 0 ? onClose : (() => { }) });
    }
}
class ConnectionLevelFieldMappingsAccessor extends ConnectionLevelElementsListAccessor {
    constructor(client, connectionSelector) {
        super(client, connectionSelector, 'field-mappings');
        this.client = client;
        this.connectionSelector = connectionSelector;
    }
}

exports.DataBuilderFormulaType = void 0;
(function (DataBuilderFormulaType) {
    DataBuilderFormulaType["VAR"] = "var";
    DataBuilderFormulaType["COPY"] = "copy";
    DataBuilderFormulaType["TPL"] = "tpl";
    DataBuilderFormulaType["RECORD"] = "record";
    DataBuilderFormulaType["LOOKUP"] = "lookup";
    DataBuilderFormulaType["PLAIN"] = "plain";
    DataBuilderFormulaType["MAP"] = "map";
    DataBuilderFormulaType["CONCAT"] = "concat";
    DataBuilderFormulaType["FIRST_NAME"] = "firstName";
    DataBuilderFormulaType["LAST_NAME"] = "lastName";
    DataBuilderFormulaType["ITERATE"] = "iterate";
    DataBuilderFormulaType["CASE"] = "case";
    DataBuilderFormulaType["EXTRACT_DATE"] = "extractDate";
    DataBuilderFormulaType["EXTRACT_TIME"] = "extractTime";
    DataBuilderFormulaType["FIND_EXTERNAL_RECORD_ID"] = "findExternalRecordId";
    DataBuilderFormulaType["FIND_APP_RECORD_ID"] = "findAppRecordId";
    DataBuilderFormulaType["EVAL"] = "eval";
    DataBuilderFormulaType["AND"] = "and";
    DataBuilderFormulaType["OR"] = "or";
    DataBuilderFormulaType["MERGE_OBJECTS"] = "mergeObjects";
    DataBuilderFormulaType["FIRST_NOT_EMPTY"] = "firstNotEmpty";
    DataBuilderFormulaType["DOMAIN_FROM_EMAIL"] = "domainFromEmail";
    DataBuilderFormulaType["FORMULA"] = "formula";
    DataBuilderFormulaType["JSONATA"] = "jsonata";
    DataBuilderFormulaType["DATA_SCHEMA_REF"] = "dataSchemaRef";
})(exports.DataBuilderFormulaType || (exports.DataBuilderFormulaType = {}));

function getFormulas() {
    return {
        [exports.DataBuilderFormulaType.VAR]: DataBuilderFormulaVar,
        [exports.DataBuilderFormulaType.RECORD]: DataBuilderFormulaRecord,
        [exports.DataBuilderFormulaType.TPL]: DataBuilderFormulaTpl,
        [exports.DataBuilderFormulaType.LOOKUP]: DataBuilderFormulaLookup,
        [exports.DataBuilderFormulaType.PLAIN]: DataBuilderFormulaPlain,
        [exports.DataBuilderFormulaType.MAP]: DataBuilderFormulaMap,
        [exports.DataBuilderFormulaType.CONCAT]: DataBuilderFormulaConcat,
        [exports.DataBuilderFormulaType.FIRST_NAME]: DataBuilderFormulaFirstName,
        [exports.DataBuilderFormulaType.LAST_NAME]: DataBuilderFormulaLastName,
        [exports.DataBuilderFormulaType.ITERATE]: DataBuilderFormulaIterate,
        [exports.DataBuilderFormulaType.CASE]: DataBuilderFormulaCase,
        [exports.DataBuilderFormulaType.EXTRACT_DATE]: DataBuilderFormulaExtractDate,
        [exports.DataBuilderFormulaType.EXTRACT_TIME]: DataBuilderFormulaExtractTime,
        [exports.DataBuilderFormulaType.FIND_EXTERNAL_RECORD_ID]: DataBuilderFormulaFindExternalRecordId,
        [exports.DataBuilderFormulaType.FIND_APP_RECORD_ID]: DataBuilderFormulaFindAppRecordId,
        [exports.DataBuilderFormulaType.COPY]: DataBuilderFormulaCopy,
        [exports.DataBuilderFormulaType.EVAL]: Eval,
        [exports.DataBuilderFormulaType.AND]: And,
        [exports.DataBuilderFormulaType.OR]: Or,
        [exports.DataBuilderFormulaType.MERGE_OBJECTS]: MergeObjects,
        [exports.DataBuilderFormulaType.FIRST_NOT_EMPTY]: FirstNotEmpty,
        [exports.DataBuilderFormulaType.DOMAIN_FROM_EMAIL]: DomainFromEmail,
        [exports.DataBuilderFormulaType.FORMULA]: FormulaFormula,
        [exports.DataBuilderFormulaType.JSONATA]: JsonataFormula,
        [exports.DataBuilderFormulaType.DATA_SCHEMA_REF]: DataSchemaRef,
    };
}
function isFormula(value) {
    return !!getFormula(value);
}
function hasFormulas(value) {
    if (isFormula(value)) {
        return true;
    }
    if (Array.isArray(value)) {
        return value.some((v) => hasFormulas(v));
    }
    else if (typeof value === 'object' && value !== null) {
        return Object.values(value).some((v) => hasFormulas(v));
    }
    else {
        return false;
    }
}
function getFormula(value) {
    if (typeof value === 'object' && value !== null) {
        const firstKey = Object.keys(value)[0];
        if (firstKey === null || firstKey === void 0 ? void 0 : firstKey.startsWith('$')) {
            const formulaType = firstKey.slice(1);
            const args = value[firstKey];
            const formulas = getFormulas();
            if (formulaType in formulas) {
                return new formulas[formulaType](args, value);
            }
        }
    }
    return undefined;
}

const structuredClone = (structuredClonePolyfill === null || structuredClonePolyfill === void 0 ? void 0 : structuredClonePolyfill.default) || structuredClonePolyfill;
function isNil(value) {
    return value == null;
}
function omitBy(obj, check) {
    obj = { ...obj };
    Object.entries(obj).forEach(([key, value]) => check(value) && delete obj[key]);
    return obj;
}
function isEmptyValue(value) {
    if (isNil(value)) {
        return true;
    }
    if (typeof value === 'symbol') {
        return true;
    }
    if (typeof value === 'boolean') {
        return false;
    }
    if (typeof value === 'number') {
        return isNaN(value);
    }
    if (typeof value === 'string') {
        return value.trim().length === 0;
    }
    const tag = value.toString();
    if (tag === '[object Map]' || tag === '[object Set]') {
        return !value.size;
    }
    return typeof value === 'object' && Object.keys(value).length === 0;
}

exports.DataLocatorStepType = void 0;
(function (DataLocatorStepType) {
    DataLocatorStepType["OBJECT_PROPERTY"] = "object_property";
    DataLocatorStepType["ARRAY_ITEM"] = "array_item";
})(exports.DataLocatorStepType || (exports.DataLocatorStepType = {}));
class DataLocatorStep {
}
class DataLocatorStepObjectProperty extends DataLocatorStep {
    constructor(propertyName) {
        super();
        this.propertyName = propertyName;
        this.type = exports.DataLocatorStepType.OBJECT_PROPERTY;
    }
}
class DataLocatorStepArrayItem extends DataLocatorStep {
    constructor(index) {
        super();
        this.index = index;
        this.type = exports.DataLocatorStepType.ARRAY_ITEM;
    }
}
class InvalidLocatorError extends Error {
}
function locatorToField(locator) {
    if (typeof locator == 'string') {
        return locator.replace(/^\$\./, '');
    }
    else {
        return locator;
    }
}
function makeObjectPropertyLocator(objectLocator, propertyName) {
    return `${objectLocator !== null && objectLocator !== void 0 ? objectLocator : '$'}.${escape(propertyName)}`;
}
function getLocatorsFromSchema(schema, rootLocator = '$') {
    var _a;
    switch (schema === null || schema === void 0 ? void 0 : schema.type) {
        case 'object':
            return Object.entries((_a = schema.properties) !== null && _a !== void 0 ? _a : {})
                .map(([key, value]) => {
                const locator = makeObjectPropertyLocator(rootLocator, key);
                return [locator, ...getLocatorsFromSchema(value, locator)];
            })
                .flat();
        default:
            return [];
    }
}
function getSchemaByLocator(schema, locator) {
    if (locator === undefined || locator === null || !isValidLocator(locator))
        return undefined;
    if (schema) {
        try {
            const schemaSteps = walkSchema$1(schema, locator);
            if (schemaSteps) {
                if (schemaSteps.length > 0) {
                    return schemaSteps[schemaSteps.length - 1].schema;
                }
                else {
                    return schema;
                }
            }
            else {
                return null;
            }
        }
        catch (e) {
            if (e instanceof InvalidLocatorError) {
                return null;
            }
            else {
                throw e;
            }
        }
    }
    else {
        return null;
    }
}
function findValueLocators(data, value) {
    function doFindValueLocator(data, value, locatorSoFar) {
        if (JSON.stringify(data) === JSON.stringify(value)) {
            return [locatorSoFar];
        }
        else {
            if (Array.isArray(data)) {
                const result = [];
                for (let i = 0; i < data.length; ++i) {
                    result.push(...doFindValueLocator(data[i], value, `${locatorSoFar}[${i}]`));
                }
                return result;
            }
            else if (typeof data === 'object' && data) {
                const result = [];
                for (const key in data) {
                    result.push(...doFindValueLocator(data[key], value, makeObjectPropertyLocator(locatorSoFar, key)));
                }
                return result;
            }
            else {
                return [];
            }
        }
    }
    return doFindValueLocator(data, value, '$');
}
function getValueAtLocator(data, locator) {
    if (data === null || data === undefined || !isValidLocator(locator))
        return undefined;
    if (!locator)
        return undefined;
    let curValue = data;
    const locatorSteps = locatorToSteps(locator);
    for (let i = 0; i < locatorSteps.length; ++i) {
        const locatorStep = locatorSteps[i];
        switch (locatorStep.type) {
            case exports.DataLocatorStepType.OBJECT_PROPERTY:
                const propStep = locatorStep;
                if (typeof curValue == 'object' &&
                    curValue !== null &&
                    curValue !== undefined &&
                    curValue[propStep.propertyName] !== undefined) {
                    curValue = curValue[propStep.propertyName];
                }
                else {
                    return undefined;
                }
                break;
            case exports.DataLocatorStepType.ARRAY_ITEM:
                const itemStep = locatorStep;
                if (Array.isArray(curValue) && curValue[itemStep.index] !== undefined) {
                    curValue = curValue[itemStep.index];
                }
                else {
                    return undefined;
                }
                break;
            default:
                throw new Error(`Unknown locator step type: ${locatorStep.type}`);
        }
    }
    return curValue;
}
function setValueAtLocator(obj, locator, value) {
    const locatorSteps = locatorToSteps(locator);
    let result = obj;
    if (locatorSteps.length > 0) {
        let cursor = result;
        let setValue = (value) => {
            result = value;
        };
        for (let i = 0; i < locatorSteps.length; i++) {
            const locatorStep = locatorSteps[i];
            if (locatorStep instanceof DataLocatorStepArrayItem) {
                if (!Array.isArray(cursor)) {
                    cursor = [];
                    setValue(cursor);
                }
                const index = locatorStep instanceof DataLocatorStepArrayItem
                    ? locatorStep.index
                    : 0;
                setValue = ((cursor) => {
                    return (value) => {
                        if (value !== undefined) {
                            cursor[index] = value;
                        }
                        else {
                            cursor.splice(index, 1);
                        }
                    };
                })(cursor);
                cursor = cursor[index];
            }
            else if (locatorStep instanceof DataLocatorStepObjectProperty) {
                if (typeof cursor !== 'object' || cursor === null) {
                    cursor = {};
                    setValue(cursor);
                }
                setValue = ((cursor) => {
                    return (value) => {
                        if (value !== undefined) {
                            cursor[locatorStep.propertyName] = value;
                        }
                        else {
                            delete cursor[locatorStep.propertyName];
                        }
                    };
                })(cursor);
                cursor = cursor[locatorStep.propertyName];
            }
            else {
                throw new Error(`Unexpected locator step type in "setValueAtLocator": ${locatorStep}`);
            }
        }
        setValue(value);
        return result;
    }
    else {
        return value;
    }
}
function pickFieldsFromValue(value, fields) {
    if (!Array.isArray(fields)) {
        return undefined;
    }
    let result;
    for (const field of fields) {
        const fieldValue = getValueAtLocator(value, field);
        if (fieldValue !== undefined) {
            result = setValueAtLocator(result, field, fieldValue);
        }
    }
    return result;
}
function excludeFieldsFromValue(value, fields) {
    if (!Array.isArray(fields)) {
        return value;
    }
    for (const field of fields) {
        setValueAtLocator(value, field, undefined);
    }
    return value;
}
function setSchemaAtLocator(schema, locator, schemaAtLocator) {
    var _a, _b, _c;
    const locatorSteps = locatorToSteps(locator);
    const result = schema !== null && schema !== void 0 ? schema : {};
    let curSchema = result;
    let curSchemaDataLocator = '$';
    for (const locatorStep of locatorSteps) {
        if (locatorStep.type == exports.DataLocatorStepType.OBJECT_PROPERTY) {
            curSchema.type = 'object';
            const propertyName = locatorStep
                .propertyName;
            if (!((_a = curSchema.properties) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(propertyName))) {
                curSchema.properties = {
                    ...((_b = curSchema.properties) !== null && _b !== void 0 ? _b : {}),
                    [propertyName]: {},
                };
            }
            curSchema = curSchema.properties[propertyName];
            curSchemaDataLocator = makeObjectPropertyLocator(curSchemaDataLocator + '.properties', propertyName);
        }
        else if (locatorStep.type == exports.DataLocatorStepType.ARRAY_ITEM) {
            curSchema.type = 'array';
            curSchema.items = (_c = curSchema.items) !== null && _c !== void 0 ? _c : {};
            curSchema = curSchema.items;
            curSchemaDataLocator = `${curSchemaDataLocator}.items`;
        }
        else {
            throw new Error(`Unexpected locator step type: ${locatorStep.type}`);
        }
    }
    return setValueAtLocator(result, curSchemaDataLocator, schemaAtLocator);
}
function extractFieldLocator(locator) {
    const steps = locatorToSteps(locator);
    const fieldSteps = [];
    for (const step of steps) {
        if (step.type === exports.DataLocatorStepType.OBJECT_PROPERTY &&
            step.propertyName.startsWith('$')) {
            break;
        }
        fieldSteps.push(step);
    }
    return stepsToLocator(fieldSteps);
}
function makeSchemaForLocator(locator, locatorSchema) {
    return setSchemaAtLocator(null, locator, locatorSchema);
}
function getNameForLocator(schema, locator) {
    if (locator === undefined || locator === null || !isValidLocator(locator))
        return undefined;
    locator = locatorToSteps(locator);
    const schemaSteps = walkSchema$1(schema, locator);
    if (schemaSteps) {
        const titleParts = schemaSteps.map((s) => s.title).filter((t) => !!t);
        return titleParts[titleParts.length - 1];
    }
    else {
        return null;
    }
}
function getNameComponentsForLocator(schema, locator) {
    if (locator === undefined || locator === null || !isValidLocator(locator))
        return undefined;
    locator = locatorToSteps(locator);
    const schemaSteps = walkSchema$1(schema, locator);
    return schemaSteps === null || schemaSteps === void 0 ? void 0 : schemaSteps.map((s) => s.title).filter((t) => !!t);
}
function getFullNameForLocator(schema, locator) {
    var _a;
    return (_a = getNameComponentsForLocator(schema, locator)) === null || _a === void 0 ? void 0 : _a.join(' > ');
}
function getIconUriForLocator(schema, locator) {
    if (locator === undefined || locator === null || !isValidLocator(locator))
        return undefined;
    locator = locatorToSteps(locator);
    const schemaSteps = walkSchema$1(schema, locator);
    return (schemaSteps &&
        schemaSteps
            .map((s) => s.iconUri)
            .filter((t) => !!t)
            .pop());
}
function getLocatorsFromData(data, parentLocator = '$') {
    if (data === null || data === undefined) {
        return [];
    }
    if (Array.isArray(data)) {
        return data.flatMap((item, idx) => getLocatorsFromData(item, `${parentLocator}[${idx}]`));
    }
    if (typeof data === 'object') {
        const locators = [];
        for (const [key, value] of Object.entries(data)) {
            locators.push(...getLocatorsFromData(value, makeObjectPropertyLocator(parentLocator, key)));
        }
        return locators;
    }
    return [parentLocator];
}
const getFullTitleForLocator = getFullNameForLocator;
function walkSchema$1(schema, locator) {
    var _a, _b;
    locator = locatorToSteps(locator);
    const schemaSteps = [];
    let curSchema = schema;
    if (schema) {
        schemaSteps.push({
            schema,
            title: schema.title,
            iconUri: schema.iconUri,
        });
    }
    for (let idx = 0; idx < locator.length; ++idx) {
        const schemaStep = {};
        const step = locator[idx];
        let defaultTitle;
        if (!curSchema) {
            return null;
        }
        if (step.type == exports.DataLocatorStepType.OBJECT_PROPERTY) {
            if (curSchema.type == 'object') {
                const objectPropertyStep = step;
                curSchema = (_a = curSchema.properties) === null || _a === void 0 ? void 0 : _a[objectPropertyStep.propertyName];
                defaultTitle = jsConvertCase.toHeaderCase(objectPropertyStep.propertyName);
            }
            else {
                return null;
            }
        }
        else if (step.type == exports.DataLocatorStepType.ARRAY_ITEM) {
            if (curSchema.type == 'array') {
                const arrayItemStep = step;
                curSchema = curSchema.items;
                defaultTitle = `Item #${arrayItemStep.index + 1}`;
            }
            else {
                return null;
            }
        }
        if (!curSchema) {
            return null;
        }
        schemaStep.schema = Object.assign({}, curSchema);
        schemaStep.title = (_b = schemaStep.schema.title) !== null && _b !== void 0 ? _b : defaultTitle;
        schemaStep.iconUri = schemaStep.schema.iconUri;
        schemaSteps.push(schemaStep);
    }
    return schemaSteps;
}
function isValidLocator(locator) {
    if (!locator) {
        return false;
    }
    try {
        locatorToSteps(locator);
        return true;
    }
    catch (_a) {
        return false;
    }
}
function locatorToSteps(sourceLocator) {
    if (Array.isArray(sourceLocator))
        return sourceLocator;
    if (typeof sourceLocator !== 'string')
        throw new BadRequestError(`Unexpected locator value: ${JSON.stringify(sourceLocator)}`);
    if (sourceLocator === '$')
        return [];
    if (!sourceLocator.startsWith('$')) {
        sourceLocator = `$.${sourceLocator}`;
    }
    const locators = [];
    let cursorPosition = 1;
    while (cursorPosition < sourceLocator.length) {
        if (sourceLocator[cursorPosition] === '.') {
            const closingIndex = findNextPosition(sourceLocator, cursorPosition + 1, '[.');
            const part = unescape(sourceLocator.slice(cursorPosition + 1, closingIndex));
            locators.push(new DataLocatorStepObjectProperty(part));
            cursorPosition = closingIndex;
        }
        else if (sourceLocator[cursorPosition] === '[') {
            const closingIndex = sourceLocator.indexOf(']', cursorPosition);
            if (closingIndex === -1) {
                throw new BadRequestError(`Could not find a closing bracket for the bracket at position ${cursorPosition}. Locator: ${sourceLocator}`);
            }
            const arrayIndex = +sourceLocator.slice(cursorPosition + 1, closingIndex);
            if (isNaN(arrayIndex) || arrayIndex < 0) {
                throw new BadRequestError(`Invalid index [${sourceLocator.slice(cursorPosition + 1, closingIndex)}]. Index should be a positive number`);
            }
            locators.push(new DataLocatorStepArrayItem(arrayIndex));
            cursorPosition = closingIndex + 1;
        }
        else {
            throw new BadRequestError(`Unexpected symbol at position ${cursorPosition}. Locator: ${sourceLocator}`);
        }
    }
    return locators;
}
function locatorToString(locator) {
    if (typeof locator === 'object' && Array.isArray(locator)) {
        return stepsToLocator(locator);
    }
    else {
        return locator;
    }
}
function stepsToLocator(steps) {
    let locator = '$';
    (steps !== null && steps !== void 0 ? steps : []).forEach((step) => {
        switch (step.type) {
            case exports.DataLocatorStepType.OBJECT_PROPERTY:
                locator = makeObjectPropertyLocator(locator, step.propertyName);
                break;
            case exports.DataLocatorStepType.ARRAY_ITEM:
                locator += `[${step.index}]`;
                break;
            default:
                throw new Error(`Unknown locator step type: ${step.type}`);
        }
    });
    return locator;
}
function createObjectFromLocators(locators = [], placeholderValue = '') {
    const locatorsWithoutNested = (locators !== null && locators !== void 0 ? locators : []).filter((locator) => !locators.some((otherLocator) => locator !== otherLocator && locator.startsWith(otherLocator + '.')));
    const obj = {};
    locatorsWithoutNested.forEach((locator) => {
        setValueAtLocator(obj, locator, placeholderValue);
    });
    return obj;
}
function getFormulaLocators(formulaType, data) {
    function doGetFormulaLocators(data, locator) {
        if (data && typeof data === 'object') {
            if (`$${formulaType}` in data && Object.keys(data).length === 1) {
                return [locator];
            }
            else if (Array.isArray(data)) {
                const locators = [];
                data.map((item, idx) => {
                    locators.push(...doGetFormulaLocators(item, `${locator}[${idx}]`));
                });
                return locators;
            }
            else {
                const locators = [];
                for (const [key, value] of Object.entries(data)) {
                    locators.push(...doGetFormulaLocators(value, makeObjectPropertyLocator(locator, key)));
                }
                return locators;
            }
        }
        else {
            return [];
        }
    }
    return doGetFormulaLocators(data, '$');
}
function transformVariablesWith(data, transformFunction) {
    let result = structuredClone(data);
    const variableLocators = getVariableLocators(data);
    for (const formulaLocator of variableLocators) {
        const value = getValueAtLocator(result, `${formulaLocator}.$var`);
        const newValue = transformFunction(value);
        result = setValueAtLocator(result, `${formulaLocator}.$var`, newValue);
    }
    return result;
}
function findNextPosition(str, startPosition, symbols) {
    let escaped = false;
    for (let i = startPosition; i < str.length; i++) {
        if (str[i] === '\\') {
            escaped = !escaped;
            continue;
        }
        if (escaped) {
            escaped = false;
            continue;
        }
        if (symbols.includes(str[i])) {
            return i;
        }
    }
}
function escape(str) {
    return str.replace(/[\\\[\].]/g, '\\$&');
}
function unescape(str) {
    return str.replace(/\\(.)/g, '$1');
}

function buildData(value, variables) {
    const result = processValue(value, variables);
    processCopy(result);
    return result;
}
async function resolveFormulas(value, params) {
    return resolveValue(value, params);
}
async function resolveValue(value, params) {
    if (isFormula(value)) {
        const formula = getFormula(value);
        return formula.resolveValue(params);
    }
    else {
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                if (!(value === null || value === void 0 ? void 0 : value.length))
                    return value;
                const result = [];
                for (const valueItem of value) {
                    const processedVal = await resolveValue(valueItem, params);
                    if (processedVal !== undefined) {
                        result.push(processedVal);
                    }
                }
                return (result.length > 0 ? result : undefined);
            }
            else if (value === null) {
                return value;
            }
            else {
                if (Object.keys(value).length === 0)
                    return value;
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    const processedVal = await resolveValue(val, params);
                    if (processedVal !== undefined) {
                        result[key] = processedVal;
                    }
                }
                if (Object.keys(result).length > 0) {
                    return result;
                }
                else {
                    return undefined;
                }
            }
        }
        else {
            return value;
        }
    }
}
function valueToString(value, variablesSchema) {
    const formula = getFormula(value);
    if (formula) {
        return formula.toString(variablesSchema);
    }
    else if (value === null || value === void 0 ? void 0 : value.toString) {
        return value.toString();
    }
    else {
        return '';
    }
}
function processValue(value, variables) {
    if (isFormula(value)) {
        const formula = getFormula(value);
        return formula.getValue(variables);
    }
    else {
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                if (!(value === null || value === void 0 ? void 0 : value.length))
                    return value;
                const result = [];
                for (const valueItem of value) {
                    const processedVal = processValue(valueItem, variables);
                    if (processedVal !== undefined) {
                        result.push(processedVal);
                    }
                }
                return result.length > 0 ? result : undefined;
            }
            else if (value === null) {
                return value;
            }
            else {
                if (Object.keys(value).length === 0)
                    return value;
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    const processedVal = processValue(val, variables);
                    if (processedVal !== undefined) {
                        result[key] = processedVal;
                    }
                }
                if (Object.keys(result).length > 0) {
                    return result;
                }
                else {
                    return undefined;
                }
            }
        }
        else {
            return value;
        }
    }
}
function processCopy(data) {
    const copyLocators = getFormulaLocators(exports.DataBuilderFormulaType.COPY, data);
    for (const locator of copyLocators) {
        const value = getValueAtLocator(data, locator);
        const formula = getFormula(value);
        const valueToCopy = getValueAtLocator(data, formula.locator);
        const valueHasCopy = getFormulaLocators(exports.DataBuilderFormulaType.COPY, valueToCopy).length > 0;
        if (valueHasCopy) {
            throw new ConfigurationError(`${locator} is copying ${formula.locator}, which contains a copy formula`);
        }
        setValueAtLocator(data, locator, valueToCopy);
    }
}
function getVariableLocators(data) {
    function doGetVariableLocators(data, locator) {
        if (data && typeof data === 'object') {
            const formula = getFormula(data);
            if (formula) {
                const locators = formula.getVariableLocators();
                return locators.map((loc) => `${locator}${loc.replace(/^\$/, '')}`);
            }
            else if (Array.isArray(data)) {
                const locators = [];
                data.map((item, idx) => {
                    locators.push(...doGetVariableLocators(item, `${locator}[${idx}]`));
                });
                return locators;
            }
            else {
                const locators = [];
                for (const [key, value] of Object.entries(data)) {
                    locators.push(...doGetVariableLocators(value, makeObjectPropertyLocator(locator, key)));
                }
                return locators;
            }
        }
        else {
            return [];
        }
    }
    return doGetVariableLocators(data, '$');
}
function transformVars(value, transformations) {
    const formula = getFormula(value);
    if (formula) {
        return formula.transformVars(transformations);
    }
    else if (Array.isArray(value)) {
        const result = [];
        for (const valueItem of value) {
            const processedVal = transformVars(valueItem, transformations);
            if (processedVal !== undefined) {
                result.push(processedVal);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    else if (typeof value === 'object') {
        if (value === null) {
            return value;
        }
        else {
            const result = {};
            for (const [key, val] of Object.entries(value)) {
                const processedVal = transformVars(val, transformations);
                if (processedVal !== undefined) {
                    result[key] = processedVal;
                }
            }
            if (Object.keys(result).length > 0) {
                return result;
            }
            else {
                return undefined;
            }
        }
    }
    else {
        return value;
    }
}
function removeNonExistentVars(value, schema) {
    const fieldLocators = getLocatorsFromSchema(schema);
    const transformations = {};
    for (const fieldLocator of fieldLocators) {
        setValueAtLocator(transformations, fieldLocator, {
            $var: fieldLocator,
        });
    }
    return transformVars(value, transformations);
}
function getValueByLocator(variables, locator) {
    if (locator === undefined || locator === null || !isValidLocator(locator))
        return undefined;
    let curValue = variables;
    const locatorSteps = locatorToSteps(locator);
    for (let i = 0; i < locatorSteps.length; ++i) {
        const locatorStep = locatorSteps[i];
        if (locatorStep.type == exports.DataLocatorStepType.OBJECT_PROPERTY) {
            curValue = executeLocatorStepObjectProperty(curValue, locatorStep);
        }
        else if (locatorStep.type == exports.DataLocatorStepType.ARRAY_ITEM) {
            curValue = executeLocatorStepArrayItem(curValue, locatorStep);
        }
        else {
            throw new BadRequestError(`Unexpected locator step type: ${locatorStep.type}`);
        }
        if (curValue === undefined) {
            break;
        }
    }
    return curValue;
}
function executeLocatorStepObjectProperty(value, step) {
    if (typeof value == 'object' && value !== null) {
        return value[step.propertyName];
    }
    else {
        return undefined;
    }
}
function executeLocatorStepArrayItem(value, step) {
    if (Array.isArray(value) && value[step.index]) {
        return value[step.index];
    }
    else {
        return undefined;
    }
}

class DataBuilderFormulaBase {
    constructor(type, args) {
        this.type = type;
        this.args = args;
    }
    async resolveValue(params) {
        return this.getValue(params.variables);
    }
    toObject() {
        return {
            [`$${this.type}`]: this.args,
        };
    }
    toString(_variablesSchema) {
        return jsConvertCase.toHeaderCase(this.type);
    }
    getVariableLocators() {
        return getVariableLocators(this.args).map((loc) => `$.$${this.type}${loc.replace(/^\$/, '')}`);
    }
    transformVars(transformations) {
        const transformedArgs = transformVars(this.args, transformations);
        if (transformedArgs !== undefined) {
            return {
                [`$${this.type}`]: transformedArgs,
            };
        }
        else {
            return undefined;
        }
    }
}

class And extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.AND, args);
    }
    getValue(variables) {
        const args = processValue(this.args, variables);
        if (Array.isArray(args) &&
            args.some((arg) => arg !== null && arg !== undefined)) {
            return args
                .filter((arg) => arg !== null && arg !== undefined)
                .every((arg) => !!arg);
        }
        else {
            return undefined;
        }
    }
    getSchema() {
        return { type: 'boolean' };
    }
}

function mergeSchemas(schemas) {
    const mergedSchema = combineSchemas(schemas);
    return mergedSchema;
}
function patchSchema(source, patch, options) {
    var _a, _b, _c, _d;
    const mergedSchema = combineSchemas([source, patch]);
    if (options === null || options === void 0 ? void 0 : options.readOnly) {
        const properties = Object.keys((_a = patch === null || patch === void 0 ? void 0 : patch.properties) !== null && _a !== void 0 ? _a : {});
        for (const prop of properties) {
            const sourceProperty = (_b = source === null || source === void 0 ? void 0 : source.properties) === null || _b === void 0 ? void 0 : _b[prop];
            if (!sourceProperty) {
                mergedSchema.properties[prop].readOnly = true;
            }
        }
    }
    else {
        const locators = getLocatorsFromSchema(patch);
        for (const locator of locators) {
            const sourceProperty = getSchemaByLocator(source, locator);
            const patchProperty = getSchemaByLocator(patch, locator);
            if ((sourceProperty === null || sourceProperty === void 0 ? void 0 : sourceProperty.readOnly) && !(patchProperty === null || patchProperty === void 0 ? void 0 : patchProperty.readOnly)) {
                const mergedProperty = getSchemaByLocator(mergedSchema, locator);
                delete mergedProperty.readOnly;
                setSchemaAtLocator(mergedSchema, locator, mergedProperty);
            }
        }
    }
    if (options === null || options === void 0 ? void 0 : options.writeOnly) {
        const properties = Object.keys((_c = patch === null || patch === void 0 ? void 0 : patch.properties) !== null && _c !== void 0 ? _c : {});
        for (const prop of properties) {
            const sourceProperty = (_d = source === null || source === void 0 ? void 0 : source.properties) === null || _d === void 0 ? void 0 : _d[prop];
            if (!sourceProperty) {
                mergedSchema.properties[prop].writeOnly = true;
            }
        }
    }
    else {
        const locators = getLocatorsFromSchema(patch);
        for (const locator of locators) {
            const sourceProperty = getSchemaByLocator(source, locator);
            const patchProperty = getSchemaByLocator(patch, locator);
            if ((sourceProperty === null || sourceProperty === void 0 ? void 0 : sourceProperty.writeOnly) && !(patchProperty === null || patchProperty === void 0 ? void 0 : patchProperty.writeOnly)) {
                const mergedProperty = getSchemaByLocator(mergedSchema, locator);
                delete mergedProperty.writeOnly;
                setSchemaAtLocator(mergedSchema, locator, mergedProperty);
            }
        }
    }
    return mergedSchema;
}
function combineSchemas(schemas) {
    const schemasByType = {
        undefined: [],
        ['null']: [],
        ['boolean']: [],
        ['integer']: [],
        ['number']: [],
        ['string']: [],
        ['array']: [],
        ['object']: [],
    };
    const unwrappedSchemas = unwrapSchemas(schemas);
    for (const unwrappedSchema of unwrappedSchemas) {
        const type = unwrappedSchema.type;
        if (!(type in schemasByType)) {
            continue;
        }
        schemasByType[type].push(unwrappedSchema);
    }
    if (schemasByType['number'].length > 0) {
        schemasByType['number'].push(...schemasByType['integer'].map((r) => ({
            ...r,
            type: 'number',
        })));
        delete schemasByType['integer'];
    }
    const resultSchemasByType = {
        undefined: combineSameTypeScalarSchemas(schemasByType['undefined']),
        ['null']: combineSameTypeScalarSchemas(schemasByType['null']),
        ['boolean']: combineSameTypeScalarSchemas(schemasByType['boolean']),
        ['number']: combineSameTypeScalarSchemas(schemasByType['number']),
        ['integer']: combineSameTypeScalarSchemas(schemasByType['integer']),
        ['string']: combineSameTypeScalarSchemas(schemasByType['string']),
        ['array']: combineArraySchemas(schemasByType['array']),
        ['object']: combineObjectSchemas(schemasByType['object']),
    };
    let schemasFound = Object.values(resultSchemasByType).filter(Boolean);
    const schemaTypesFound = new Set(schemasFound.map((s) => s.type));
    if (schemaTypesFound.size > 1 && schemaTypesFound.has(undefined)) {
        schemasFound = schemasFound.filter((s) => !!(s === null || s === void 0 ? void 0 : s.type));
    }
    const multiType = schemasFound.length > 1;
    if (multiType) {
        const wrapped = wrapAnyOfSchema({ anyOf: schemasFound });
        return wrapped;
    }
    return schemasFound[0];
}
function combineSameTypeScalarSchemas(schemas) {
    if (!schemas || schemas.length === 0) {
        return undefined;
    }
    let schema = {};
    for (const s of schemas) {
        schema = {
            ...schema,
            ...s,
        };
    }
    return schema;
}
function combineArraySchemas(schemas) {
    if (!schemas || schemas.length === 0) {
        return undefined;
    }
    const itemSchemas = [];
    for (const schema of schemas) {
        if (!schema.items)
            continue;
        const unwrappedSchemas = unwrapSchema(schema.items);
        itemSchemas.push(...unwrappedSchemas);
    }
    const schema = combineSameTypeScalarSchemas(schemas);
    if (itemSchemas.length > 0) {
        schema.items = combineSchemas(itemSchemas);
    }
    return schema;
}
function combineObjectSchemas(schemas) {
    if (!schemas || schemas.length === 0) {
        return undefined;
    }
    const allPropSchemas = [];
    const allRequiredProps = new Set();
    for (const schema of schemas) {
        if (!schema)
            continue;
        if (schema.properties) {
            allPropSchemas.push(schema.properties);
        }
        if (Array.isArray(schema.required)) {
            for (const prop of schema.required) {
                allRequiredProps.add(prop);
            }
        }
    }
    const schemasByProp = Object.create(null);
    for (const propSchemas of allPropSchemas) {
        for (const [prop, schema] of Object.entries(propSchemas)) {
            if (!schemasByProp[prop]) {
                schemasByProp[prop] = [];
            }
            const unwrappedSchemas = unwrapSchema(schema);
            schemasByProp[prop].push(...unwrappedSchemas);
        }
    }
    const properties = Object.entries(schemasByProp).reduce((props, [prop, schemas]) => {
        if (schemas.length === 1) {
            props[prop] = schemas[0];
        }
        else {
            props[prop] = combineSchemas(schemas);
        }
        return props;
    }, {});
    const combinedSchema = combineSameTypeScalarSchemas(schemas);
    if (Object.keys(properties).length > 0) {
        combinedSchema.properties = properties;
    }
    if (allRequiredProps.size > 0) {
        combinedSchema.required = Array.from(allRequiredProps);
    }
    return combinedSchema;
}
function unwrapSchema(schema) {
    if (!schema)
        return [];
    if (schema.anyOf) {
        return unwrapSchemas(schema.anyOf);
    }
    if (Array.isArray(schema.type)) {
        return schema.type.map((x) => ({ type: x }));
    }
    return [schema];
}
function unwrapSchemas(schemas) {
    if (!schemas || schemas.length === 0)
        return [];
    const unwrappedSchemas = schemas.flatMap((schema) => unwrapSchema(schema));
    return unwrappedSchemas;
}
function wrapAnyOfSchema(schema) {
    const simpleSchemas = [];
    const complexSchemas = [];
    for (const subSchema of schema.anyOf) {
        if (Array.isArray(subSchema.type)) {
            simpleSchemas.push(...subSchema.type);
        }
        else if (isSimpleSchema(subSchema)) {
            simpleSchemas.push(subSchema.type);
        }
        else {
            complexSchemas.push(subSchema);
        }
    }
    if (complexSchemas.length === 0) {
        return { type: simpleSchemas };
    }
    const anyOf = [];
    if (simpleSchemas.length > 0) {
        anyOf.push({
            type: simpleSchemas.length > 1 ? simpleSchemas : simpleSchemas[0],
        });
    }
    anyOf.push(...complexSchemas);
    return { anyOf };
}
function isSimpleSchema(schema) {
    const keys = Object.keys(schema);
    return keys.length === 1 && keys[0] === 'type';
}

function createSchema(value) {
    if (typeof value === 'undefined')
        value = null;
    const clone = JSON.parse(JSON.stringify(value));
    return createSchemaFor(clone);
}
function createCompoundSchema(values) {
    const schemas = values.map((value) => createSchema(value));
    return mergeSchemas(schemas);
}
function createSchemaFor(value) {
    switch (typeof value) {
        case 'number':
            if (Number.isInteger(value)) {
                return { type: 'integer' };
            }
            return { type: 'number' };
        case 'boolean':
            return { type: 'boolean' };
        case 'string':
            return { type: 'string' };
        case 'object':
            if (value === null) {
                return {};
            }
            if (Array.isArray(value)) {
                return createSchemaForArray(value);
            }
            return createSchemaForObject(value);
        default:
            return null;
    }
}
function createSchemaForArray(arr) {
    if (arr.length === 0) {
        return { type: 'array' };
    }
    const elementSchemas = arr.map((value) => createSchemaFor(value));
    const items = mergeSchemas(elementSchemas);
    return { type: 'array', items };
}
function createSchemaForObject(obj) {
    const keys = Object.keys(obj);
    if (keys.length === 0) {
        return {
            type: 'object',
        };
    }
    const properties = Object.entries(obj).reduce((props, [key, val]) => {
        props[key] = createSchemaFor(val);
        return props;
    }, {});
    const schema = { type: 'object', properties };
    return schema;
}

class IDataField {
}
class DataField {
    constructor(data) {
        var _a, _b;
        Object.assign(this, data);
        this.name = (_b = (_a = this.name) !== null && _a !== void 0 ? _a : this.schema.title) !== null && _b !== void 0 ? _b : jsConvertCase.toHeaderCase(this.key);
        this.subFields = extractSubFields(this);
    }
}
function extractSubFields(field) {
    var _a, _b, _c;
    let subfields = [];
    if (!((_a = field.schema) === null || _a === void 0 ? void 0 : _a.type)) {
        subfields = getSubfieldsFromValue(field);
    }
    else if (((_b = field.schema) === null || _b === void 0 ? void 0 : _b.type) === 'object') {
        subfields = [
            ...getSubfieldsFromObjectSchema(field),
            ...(isObjectAllowedAdditionalProperties(field)
                ? getSubfieldsFromValue(field)
                : []),
        ];
    }
    else if (((_c = field.schema) === null || _c === void 0 ? void 0 : _c.type) === 'array') {
        if (Array.isArray(field.value)) {
            subfields = getSubfieldsFromValue(field);
        }
    }
    return subfields;
}
function getSubfieldsFromValue(field) {
    const fields = [];
    if (Array.isArray(field.value)) {
        return field.value.map((item, idx) => {
            var _a;
            return new DataField({
                key: (idx + 1).toString(),
                schema: (_a = field.schema) === null || _a === void 0 ? void 0 : _a.items,
                value: item,
            });
        });
    }
    else if (typeof field.value == 'object' &&
        field.value !== null &&
        !isFormula(field.value)) {
        Object.entries(field.value).forEach(([key, value]) => {
            if (!field.schema ||
                !field.schema.properties ||
                !(key in field.schema.properties)) {
                fields.push(new DataField({
                    key,
                    schema: null,
                    value: value,
                }));
            }
        });
    }
    return fields;
}
function getSubfieldsFromObjectSchema(field) {
    var _a;
    const fields = [];
    if ((_a = field.schema) === null || _a === void 0 ? void 0 : _a.properties) {
        Object.entries(field.schema.properties).forEach(([key, value]) => {
            var _a;
            fields.push(new DataField({
                key,
                schema: value,
                value: (_a = field.value) === null || _a === void 0 ? void 0 : _a[key],
            }));
        });
    }
    return fields;
}
function isObjectAllowedAdditionalProperties(field) {
    var _a, _b;
    if (((_a = field.schema) === null || _a === void 0 ? void 0 : _a.type) !== 'object') {
        return true;
    }
    return ((_b = field.schema) === null || _b === void 0 ? void 0 : _b.additionalProperties) === true;
}

exports.ConnectorMethodImplementationType = void 0;
(function (ConnectorMethodImplementationType) {
    ConnectorMethodImplementationType["mapping"] = "mapping";
    ConnectorMethodImplementationType["operationMapping"] = "operation-mapping";
    ConnectorMethodImplementationType["restApiMapping"] = "rest-api-mapping";
    ConnectorMethodImplementationType["graphqlApiMapping"] = "graphql-api-mapping";
    ConnectorMethodImplementationType["javascript"] = "javascript";
    ConnectorMethodImplementationType["notSupported"] = "not-supported";
})(exports.ConnectorMethodImplementationType || (exports.ConnectorMethodImplementationType = {}));
const CONNECTOR_METHOD_IMPLEMENTATION_SUFFIXES = {
    [exports.ConnectorMethodImplementationType.restApiMapping]: ['.rest.yml', '.api.yml'],
    [exports.ConnectorMethodImplementationType.graphqlApiMapping]: ['.graphql.yml'],
    [exports.ConnectorMethodImplementationType.operationMapping]: ['.op.yml'],
    [exports.ConnectorMethodImplementationType.javascript]: ['.js', '.ts'],
    [exports.ConnectorMethodImplementationType.mapping]: ['.map.yml', '.yml'],
};

const CONNECTOR_AUTH_TYPES = [
    'integration-app-token',
    'oauth2',
    'oauth1',
    'client-credentials',
    'proxy',
];
function getAuthSpec(spec, authOptionKey) {
    var _a, _b;
    let authSpec;
    if (authOptionKey) {
        authSpec = (_b = (_a = spec === null || spec === void 0 ? void 0 : spec.auth) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b[authOptionKey];
    }
    else {
        authSpec = spec === null || spec === void 0 ? void 0 : spec.auth;
    }
    return authSpec;
}
const getDefaultAuthInputSchema = (args) => {
    var _a, _b, _c, _d, _e, _f;
    const authSpec = getAuthSpec(args.connectorSpec, args.authOptionKey);
    return {
        type: 'object',
        properties: {
            connectorParameters: (_b = (_a = args.connectorSpec) === null || _a === void 0 ? void 0 : _a.parametersSchema) !== null && _b !== void 0 ? _b : {},
            connectionParameters: (_d = (_c = authSpec === null || authSpec === void 0 ? void 0 : authSpec.ui) === null || _c === void 0 ? void 0 : _c.schema) !== null && _d !== void 0 ? _d : (_f = (_e = args.connectorSpec) === null || _e === void 0 ? void 0 : _e.ui) === null || _f === void 0 ? void 0 : _f.schema,
        },
    };
};
const ConnectorAuthMethodTypes = {
    getOAuthConfig: {
        authTypes: ['oauth2', 'oauth1'],
        fileKeys: ['get-oauth-config', 'oauth-config'],
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.mapping,
            exports.ConnectorMethodImplementationType.javascript,
        ],
        getInputSchema: (args) => {
            const schema = getDefaultAuthInputSchema(args);
            return {
                ...schema,
                properties: {
                    ...schema.properties,
                    redirectUri: { type: 'string' },
                    state: { type: 'string' },
                },
            };
        },
        getOutputSchema: ({ connectorSpec, authOptionKey }) => {
            const authSpec = getAuthSpec(connectorSpec, authOptionKey);
            return (authSpec === null || authSpec === void 0 ? void 0 : authSpec.type) === 'oauth1'
                ? OAUTH1_CONFIG_SCHEMA
                : OAUTH_CONFIG_SCHEMA;
        },
        isRequired: true,
    },
    getTokenData: {
        authTypes: ['oauth2'],
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.mapping,
            exports.ConnectorMethodImplementationType.javascript,
        ],
        getInputSchema: getDefaultAuthInputSchema,
        getOutputSchema: ({ connectorSpec, authOptionKey }) => {
            const authSpec = getAuthSpec(connectorSpec, authOptionKey);
            return authSpec === null || authSpec === void 0 ? void 0 : authSpec.credentialsSchema;
        },
        isRequired: false,
    },
    getCredentialsFromAccessTokenResponse: {
        authTypes: ['oauth2'],
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.javascript,
        ],
        isRequired: false,
    },
    getCredentialsFromRefreshTokenResponse: {
        authTypes: ['oauth2'],
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.javascript,
        ],
        isRequired: false,
    },
    getCredentialsFromConnectionParameters: {
        authTypes: ['client-credentials'],
        getInputSchema: getDefaultAuthInputSchema,
        getOutputSchema: ({ connectorSpec, authOptionKey }) => {
            var _a;
            const authSpec = getAuthSpec(connectorSpec, authOptionKey);
            return (_a = authSpec === null || authSpec === void 0 ? void 0 : authSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema;
        },
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.mapping,
            exports.ConnectorMethodImplementationType.javascript,
        ],
        isRequired: false,
    },
    refreshCredentials: {
        authTypes: ['oauth2', 'oauth1', 'client-credentials'],
        getInputSchema: getDefaultAuthInputSchema,
        getOutputSchema: ({ connectorSpec, authOptionKey }) => {
            var _a;
            const authSpec = getAuthSpec(connectorSpec, authOptionKey);
            return (_a = authSpec === null || authSpec === void 0 ? void 0 : authSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema;
        },
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.javascript,
        ],
        isRequired: false,
    },
    makeApiClient: {
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.mapping,
            exports.ConnectorMethodImplementationType.javascript,
        ],
        getInputSchema: ({ connectorSpec, authOptionKey }) => {
            var _a, _b;
            const authSpec = getAuthSpec(connectorSpec, authOptionKey);
            return {
                type: 'object',
                properties: {
                    credentials: mergeSchemas([
                        ((_a = authSpec === null || authSpec === void 0 ? void 0 : authSpec.customCredentialsSchema) !== null && _a !== void 0 ? _a : authSpec === null || authSpec === void 0 ? void 0 : authSpec.credentialsSchema),
                        (_b = authSpec === null || authSpec === void 0 ? void 0 : authSpec.ui) === null || _b === void 0 ? void 0 : _b.schema,
                    ]),
                },
            };
        },
        getOutputSchema: () => REST_API_CLIENT_SCHEMA,
        isRequired: true,
    },
    test: {
        supportedImplementationTypes: [
            exports.ConnectorMethodImplementationType.operationMapping,
            exports.ConnectorMethodImplementationType.restApiMapping,
            exports.ConnectorMethodImplementationType.javascript,
        ],
        getOutputSchema: () => ({
            title: 'Connection Is Active',
            type: 'boolean',
        }),
        isRequired: true,
    },
};
const OAUTH_CONFIG_SCHEMA = {
    type: 'object',
    properties: {
        clientId: { type: 'string' },
        clientSecret: { type: 'string' },
        authorizeUri: {
            type: 'string',
            description: 'URL to redirect user to when starting the authentication process',
        },
        tokenUri: {
            type: 'string',
            description: 'URL used to exchnage code for access token',
        },
        scopes: { type: 'array', items: { type: 'string' } },
        clientAuthLocation: {
            type: 'string',
            enum: ['headers', 'body'],
            default: 'headers',
            description: 'Whether to send clientId and clientSecret in the request body or headers (different apps expect it in different places)',
        },
        noRefreshToken: {
            type: 'boolean',
            description: 'Do not expect refresh_token in the token response. Use this if application does not support refresh tokens.',
        },
        skipPkce: {
            type: 'boolean',
            description: 'Skip sending PKCE parameters in the token request. Some authentication processes error if PKCE is enabled.',
        },
        extra: {
            type: 'object',
            additionalProperties: true,
            description: 'Any additional parameters in the request query parameters that are not covered by the oAuth2 standard.',
        },
        skipClientAuthInBody: {
            type: 'boolean',
            description: '(Deprecated) Skip sending client credentials in the body of the token request',
        },
        skipClientAuthInHeader: {
            type: 'boolean',
            description: '(Deprecated) Skip sending client credentials in the body of the token request',
        },
    },
};
const OAUTH1_CONFIG_SCHEMA = {
    type: 'object',
    properties: {
        consumerKey: { type: 'string' },
        consumerSecret: { type: 'string' },
        requestTokenUri: { type: 'string' },
        authorizeUri: { type: 'string' },
        tokenUri: { type: 'string' },
        scopes: { type: 'array', items: { type: 'string' } },
        extra: {
            type: 'object',
            additionalProperties: true,
            description: 'Additional parameters in the request query parameters',
        },
    },
};
const REST_API_CLIENT_RESPONSE_HANDLERS_SCHEMA = {
    title: 'Respose Handlers',
    description: 'Define how to handle responses from the API',
    type: 'array',
    items: {
        type: 'object',
        properties: {
            match: {
                type: 'boolean',
                description: 'Whether this handler matches the response. If true, the handler will be used.',
            },
            isSuccess: {
                type: 'boolean',
                description: 'Whether to consider response successful. If yes - data will be returned. If no - error will be thrown',
            },
            data: {},
            error: {
                type: 'object',
                properties: {
                    message: { type: 'string' },
                    key: {
                        type: 'string',
                        enum: [
                            exports.ConnectionErrorKey.ACCESS_TOKEN_EXPIRED,
                            exports.ConnectionErrorKey.CONNECTION_IS_DEFUNCT,
                            exports.ConnectionErrorKey.RATE_LIMIT_EXCEEDED,
                        ],
                    },
                    data: {},
                },
            },
        },
    },
};
const REST_API_CLIENT_SCHEMA = {
    type: 'object',
    properties: {
        args: {
            type: 'object',
            properties: {
                baseUri: {
                    type: 'string',
                    description: 'This prefix will be added to all relative API requests.',
                },
                query: {
                    type: 'object',
                    additionalProperties: true,
                },
                headers: {
                    type: 'object',
                    additionalProperties: true,
                },
                auth: {
                    type: 'object',
                    description: 'Basic authentication',
                    properties: {
                        username: { type: 'string' },
                        password: { type: 'string' },
                    },
                },
                responseHandlers: REST_API_CLIENT_RESPONSE_HANDLERS_SCHEMA,
            },
        },
    },
};

const CONNECTOR_DATA_DIR = 'data';
const CONNECTOR_OPERATIONS_DIR = 'operations';
const CONNECTOR_DOCS_DIR = 'docs';
const CONNECTOR_GLOBAL_WEBHOOKS_DIR = 'global-webhooks';
const CONNECTOR_EVENTS_DIR = 'events';

const FIELDS_SCHEMA$G = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        title: { type: 'string' },
        description: { type: 'string' },
        type: { type: 'string' },
        durationSeconds: { type: 'number' },
        location: { type: 'string' },
        isRecurrent: { type: 'boolean' },
        participants: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    userId: { type: 'string' },
                    contactId: { type: 'string' },
                },
            },
        },
        status: { type: 'string' },
        contactId: {
            type: 'string',
            referenceUdm: 'contacts',
        },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        dealId: {
            type: 'string',
            referenceUdm: 'deals',
        },
        leadId: {
            type: 'string',
            referenceUdm: 'leads',
        },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        startTime: {
            type: 'string',
            format: 'date-time',
        },
        endTime: {
            type: 'string',
            format: 'date-time',
        },
        dueTime: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
    },
};
const FallbackFieldsMap = {
    fromActivitiesToTasks: {
        subject: {
            $var: 'title',
        },
        content: {
            $var: 'description',
        },
    },
    fromTasksToActivities: {
        title: {
            $var: 'subject',
        },
        description: {
            $var: 'content',
        },
    },
    fromActivitiesToNotes: {
        content: {
            $var: 'description',
        },
    },
    fromNotesToActivities: {
        description: {
            $var: 'content',
        },
    },
    fromActivitiesToEmails: {
        subject: {
            $var: 'title',
        },
        body: {
            $var: 'description',
        },
    },
    fromEmailsToActivities: {
        title: {
            $var: 'subject',
        },
        description: {
            $var: 'body',
        },
    },
};
const udm$G = {
    singularName: 'activity',
    pluralName: 'activities',
    fieldsSchema: FIELDS_SCHEMA$G,
    list: {
        filterFields: [
            'type',
            'companyId',
            'contactId',
            'dealId',
            'leadId',
            'ownerId',
        ],
    },
    match: {
        fields: ['type', 'companyId', 'contactId', 'dealId', 'leadId', 'ownerId'],
    },
    populateFields,
    udmFallbacks: [
        {
            udm: 'tasks',
            importFields: FallbackFieldsMap.fromTasksToActivities,
            exportFields: FallbackFieldsMap.fromActivitiesToTasks,
        },
        {
            udm: 'meetings',
        },
        {
            udm: 'notes',
            importFields: FallbackFieldsMap.fromNotesToActivities,
            exportFields: FallbackFieldsMap.fromActivitiesToNotes,
        },
        {
            udm: 'emails',
            importFields: FallbackFieldsMap.fromEmailsToActivities,
            exportFields: FallbackFieldsMap.fromActivitiesToEmails,
        },
    ],
};
function populateFields(fields) {
    const result = JSON.parse(JSON.stringify(fields));
    if (!result.dueTime) {
        result.dueTime = result.endTime || result.startTime;
    }
    if (!result.startTime) {
        result.startTime = result.dueTime || result.endTime;
    }
    if (!result.endTime) {
        result.endTime = result.dueTime || result.startTime;
    }
    return result;
}

const FIELDS_SCHEMA$F = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        number: { type: 'string' },
        name: { type: 'string' },
        memo: { type: 'string' },
        status: { type: 'string' },
        paymentMethod: { type: 'string' },
        supplierId: { type: 'string', referenceUdm: 'suppliers' },
        currency: { type: 'string' },
        payments: {
            type: 'array',
            items: {
                type: 'string',
                referenceUdm: 'payments',
            },
        },
        lineItems: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    itemName: { type: 'string' },
                    description: { type: 'string' },
                    code: { type: 'string' },
                    type: { type: 'string' },
                    companyId: { type: 'string', referenceUdm: 'companies' },
                    ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
                    quantity: { type: 'number' },
                    unitPrice: { type: 'number' },
                    unitOfMeasure: { type: 'string' },
                    purchasePrice: { type: 'number' },
                    salesPrice: { type: 'number' },
                    taxable: { type: 'boolean' },
                    taxAmount: { type: 'number' },
                    totalAmount: { type: 'number' },
                },
            },
        },
        totalAmount: { type: 'number' },
        totalTax: { type: 'number' },
        exchangeRate: { type: 'number' },
        totalDiscount: { type: 'number' },
        subTotal: { type: 'number' },
        balance: { type: 'number' },
        ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
        issueDate: {
            type: 'string',
            format: 'date-time',
        },
        dueDate: {
            type: 'string',
            format: 'date-time',
        },
        paidOnDate: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$F = {
    singularName: 'bill',
    pluralName: 'bills',
    fieldsSchema: FIELDS_SCHEMA$F,
    list: {
        filterFields: ['name', 'number', 'status', 'supplierId'],
    },
    match: {
        fields: ['name', 'number', 'status', 'supplierId'],
    },
};

const FIELDS_SCHEMA$E = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        fullName: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        primaryEmail: { type: 'string' },
        campaignId: {
            type: 'string',
            referenceUdm: 'campaigns',
        },
        contactId: {
            type: 'string',
            referenceUdm: 'contacts',
        },
        leadId: {
            type: 'string',
            referenceUdm: 'leads',
        },
        source: { type: 'string' },
        status: { type: 'string' },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        jobTitle: { type: 'string' },
        hasOptedOutOfEmail: { type: 'boolean' },
        createdTime: {
            type: 'string',
            format: 'date-time',
        },
        createdBy: {
            type: 'string',
            readOnly: true,
            referenceUdm: 'users',
        },
        updatedTime: {
            type: 'string',
            readOnly: true,
            format: 'date-time',
        },
        updatedBy: {
            type: 'string',
            readOnly: true,
            referenceUdm: 'users',
        },
    },
};
const udm$E = {
    singularName: 'campaign-member',
    pluralName: 'campaign-members',
    fieldsSchema: FIELDS_SCHEMA$E,
    list: {
        filterFields: [
            'primaryEmail',
            'fullName',
            'firstName',
            'lastName',
            'campaignId',
            'contactId',
            'leadId',
            'companyId',
        ],
    },
    match: {
        fields: [
            'primaryEmail',
            'fullName',
            'firstName',
            'lastName',
            'campaignId',
            'contactId',
            'leadId',
            'companyId',
        ],
    },
};

const FIELDS_SCHEMA$D = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: {
            type: 'string',
        },
        cost: {
            type: 'number',
        },
        description: {
            type: 'string',
        },
        source: {
            type: 'string',
        },
        stage: {
            type: 'string',
        },
        type: {
            type: 'string',
        },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        sentCount: {
            type: 'number',
            readOnly: true,
        },
        replyCount: {
            type: 'number',
            readOnly: true,
        },
        openCount: {
            type: 'number',
            readOnly: true,
        },
        clickCount: {
            type: 'number',
            readOnly: true,
        },
        startTime: {
            type: 'string',
            format: 'date-time',
        },
        endTime: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        lastActivityTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
    },
};
const MODIFIABLE_FIELDS$2 = [
    'name',
    'description',
    'ownerId',
    'startTime',
    'endTime',
    'cost',
    'source',
    'stage',
    'type',
];
const udm$D = {
    singularName: 'campaign',
    pluralName: 'campaigns',
    fieldsSchema: FIELDS_SCHEMA$D,
    categories: ['Marketing Automation', 'Sales', 'CRM', 'Ads'],
    list: {
        filterFields: ['name', 'source', 'stage', 'type', 'ownerId'],
    },
    find: {
        queryFields: ['name', 'source', 'stage', 'type', 'ownerId'],
    },
    match: {
        fields: ['name', 'source', 'stage', 'type', 'ownerId'],
    },
    create: {
        fields: MODIFIABLE_FIELDS$2,
    },
    update: {
        fields: MODIFIABLE_FIELDS$2,
    },
};

const AddressSchema = {
    type: 'object',
    properties: {
        type: { type: 'string' },
        full: { type: 'string' },
        street: { type: 'string' },
        city: { type: 'string' },
        state: { type: 'string' },
        country: { type: 'string' },
        zip: { type: 'string' },
    },
};
const PhoneEmailSchema = {
    type: 'object',
    properties: {
        value: { type: 'string' },
        type: { type: 'string' },
    },
};

const FIELDS_SCHEMA$C = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: {
            type: 'string',
        },
        websiteUrl: {
            type: 'string',
        },
        phones: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        primaryPhone: {
            type: 'string',
        },
        description: {
            type: 'string',
        },
        currency: {
            type: 'string',
        },
        industry: {
            type: 'string',
        },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        primaryAddress: AddressSchema,
        addresses: {
            type: 'array',
            items: AddressSchema,
        },
        numberOfEmployees: {
            type: 'number',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        lastActivityTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
    },
};
const udm$C = {
    singularName: 'company',
    pluralName: 'companies',
    fieldsSchema: FIELDS_SCHEMA$C,
    list: {
        filterFields: ['ownerId', 'name', 'websiteUrl', 'industry'],
    },
    find: {
        queryFields: ['ownerId', 'name', 'websiteUrl', 'industry'],
    },
    match: {
        fields: ['ownerId', 'name', 'websiteUrl', 'industry'],
    },
    fieldFallbacks: {
        'primaryAddress.full': [
            {
                $concat: {
                    values: [
                        { $var: 'primaryAddress.street' },
                        { $var: 'primaryAddress.city' },
                        { $var: 'primaryAddress.state' },
                        { $var: 'primaryAddress.zip' },
                        { $var: 'primaryAddress.country' },
                    ],
                    delimiter: ', ',
                },
            },
        ],
    },
};

const FIELDS_SCHEMA$B = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        description: { type: 'string' },
        source: { type: 'string' },
        type: { type: 'string' },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
    },
};
const MODIFIABLE_FIELDS$1 = ['name', 'description', 'ownerId', 'source', 'type'];
const udm$B = {
    singularName: 'contact-list',
    pluralName: 'contact-lists',
    fieldsSchema: FIELDS_SCHEMA$B,
    categories: ['Marketing Automation', 'Sales', 'CRM'],
    list: {
        filterFields: ['name', 'source', 'type', 'ownerId'],
    },
    match: {
        fields: ['name'],
    },
    create: {
        fields: MODIFIABLE_FIELDS$1,
    },
    update: {
        fields: MODIFIABLE_FIELDS$1,
    },
    udmFallbacks: [{ udm: 'campaigns' }],
};

const FIELDS_SCHEMA$A = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        fullName: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        primaryEmail: { type: 'string' },
        emails: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        primaryPhone: { type: 'string' },
        phones: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        primaryAddress: AddressSchema,
        addresses: {
            type: 'array',
            items: AddressSchema,
        },
        stage: { type: 'string' },
        companyName: { type: 'string' },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        jobTitle: { type: 'string' },
        source: { type: 'string' },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        lastActivityTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
    },
};
const FILTER_FIELDS$g = [
    'fullName',
    'firstName',
    'lastName',
    'primaryEmail',
    'primaryPhone',
    'companyId',
    'companyName',
    'jobTitle',
    'source',
    'stage',
    'ownerId',
];
const udm$A = {
    singularName: 'contact',
    pluralName: 'contacts',
    fieldsSchema: FIELDS_SCHEMA$A,
    list: {
        filterFields: FILTER_FIELDS$g,
    },
    match: {
        fields: ['fullName', 'primaryEmail', 'primaryPhone'],
    },
    fieldFallbacks: {
        fullName: [
            {
                $concat: {
                    values: [{ $var: 'firstName' }, { $var: 'lastName' }],
                    delimiter: ' ',
                },
            },
        ],
        firstName: [
            {
                $firstName: {
                    $var: 'fullName',
                },
            },
        ],
        lastName: [
            {
                $lastName: {
                    $var: 'fullName',
                },
            },
        ],
        primaryEmail: [
            {
                $var: 'emails[0].value',
            },
        ],
        emails: [
            [
                {
                    value: { $var: 'primaryEmail' },
                },
            ],
        ],
        primaryPhone: [
            {
                $var: 'phones[0].value',
            },
        ],
        phones: [
            [
                {
                    value: { $var: 'primaryPhone' },
                },
            ],
        ],
        primaryAddress: [
            {
                $var: 'addresses[0]',
            },
        ],
        addresses: [
            [
                {
                    value: { $var: 'primaryAddress' },
                },
            ],
        ],
        'primaryAddress.full': [
            {
                $concat: {
                    values: [
                        { $var: 'primaryAddress.street' },
                        { $var: 'primaryAddress.city' },
                        { $var: 'primaryAddress.state' },
                        { $var: 'primaryAddress.zip' },
                        { $var: 'primaryAddress.country' },
                    ],
                    delimiter: ', ',
                },
            },
        ],
    },
};

const FIELDS_SCHEMA$z = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        number: { type: 'string' },
        memo: { type: 'string' },
        status: { type: 'string' },
        customerId: { type: 'string', referenceUdm: 'customers' },
        currency: { type: 'string' },
        exchangeRate: { type: 'number' },
        payments: {
            type: 'array',
            items: {
                type: 'string',
                referenceUdm: 'payments',
            },
        },
        lineItems: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    itemName: { type: 'string' },
                    description: { type: 'string' },
                    quantity: { type: 'number' },
                    totalLineAmount: { type: 'number' },
                    companyId: { type: 'string', referenceUdm: 'companies' },
                    ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
                    unitPrice: { type: 'number' },
                    taxRate: { type: 'string', referenceUdm: 'tax-rates' },
                },
            },
        },
        allocations: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    type: {
                        type: 'string',
                        enum: [
                            'invoice',
                            'order',
                            'expense',
                            'credit_memo',
                            'over_payment',
                            'pre_payment',
                        ],
                    },
                    amount: { type: 'number' },
                },
            },
        },
        totalAmount: { type: 'number' },
        totalTax: { type: 'number' },
        totalDiscount: { type: 'number' },
        subTotal: { type: 'number' },
        balance: { type: 'number' },
        ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
        issueDate: {
            type: 'string',
            format: 'date-time',
        },
        paidOnDate: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$z = {
    singularName: 'credit-note',
    pluralName: 'credit-notes',
    fieldsSchema: FIELDS_SCHEMA$z,
    categories: ['Accounting', 'Payments'],
    list: {
        filterFields: ['id', 'number', 'customerId', 'status', 'issueDate'],
    },
    match: {
        fields: ['id', 'number', 'customerId', 'status', 'issueDate'],
    },
};

const FIELDS_SCHEMA$y = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        code: { type: 'string' },
        description: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        companyName: { type: 'string' },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        status: 'active',
        currency: { type: 'string' },
        addresses: {
            type: 'array',
            items: AddressSchema,
        },
        phones: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        emails: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        websiteUrl: {
            type: 'string',
        },
        notes: { type: 'string' },
        tax_number: { type: 'string' },
        orderIds: {
            type: 'array',
            items: {
                type: 'string',
                referenceUdm: 'orders',
            },
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$y = {
    singularName: 'customer',
    pluralName: 'customers',
    fieldsSchema: FIELDS_SCHEMA$y,
    categories: ['CRM', 'Sales', 'E-Commerce', 'Accounting', 'Payments'],
    list: {
        filterFields: [
            'code',
            'companyId',
            'companyName',
            'firstName',
            'lastName',
            'name',
            'status',
            'websiteUrl',
        ],
    },
    match: {
        fields: [
            'code',
            'companyId',
            'companyName',
            'firstName',
            'lastName',
            'name',
            'status',
            'websiteUrl',
        ],
    },
    udmFallbacks: [
        {
            udm: 'companies',
        },
    ],
};

const FIELDS_SCHEMA$x = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        quantity: { type: 'number' },
        price: { type: 'number' },
        dealId: {
            type: 'string',
            referenceUdm: 'deals',
        },
        productId: {
            type: 'string',
            referenceUdm: 'products',
        },
        isActive: { type: 'boolean' },
        createdTime: {
            type: 'string',
            format: 'date-time',
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
    },
};
const MODIFIABLE_FIELDS = ['name', 'quantity', 'price'];
const CREATABLE_FIELDS = ['name', 'quantity', 'price', 'dealId', 'productId'];
const udm$x = {
    singularName: 'deal-product',
    pluralName: 'deal-products',
    fieldsSchema: FIELDS_SCHEMA$x,
    list: {
        filterFields: ['dealId', 'productId', 'name'],
    },
    match: {
        fields: ['dealId', 'productId', 'name'],
    },
    find: {
        queryFields: ['dealId', 'productId', 'name'],
    },
    create: {
        fields: CREATABLE_FIELDS,
    },
    update: {
        fields: MODIFIABLE_FIELDS,
    },
};

const FIELDS_SCHEMA$w = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        state: { type: 'string', enum: ['open', 'won', 'lost'] },
    },
};
const udm$w = {
    singularName: 'deal-stage',
    pluralName: 'deal-stages',
    fieldsSchema: FIELDS_SCHEMA$w,
    categories: ['CRM', 'Sales'],
    list: {
        filterFields: ['name', 'state'],
    },
    match: {
        fields: ['name'],
    },
};

const FIELDS_SCHEMA$v = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        amount: { type: 'number' },
        currency: { type: 'string' },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        contactId: {
            type: 'string',
            referenceUdm: 'contacts',
        },
        campaignId: {
            type: 'string',
            referenceUdm: 'campaigns',
        },
        source: { type: 'string' },
        description: { type: 'string' },
        stage: { type: 'string' },
        stageId: { type: 'string' },
        status: {
            type: 'string',
            enum: ['open', 'won', 'lost'],
        },
        type: { type: 'string' },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        probability: { type: 'number' },
        closeTime: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        lastActivityTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
    },
};
const udm$v = {
    singularName: 'deal',
    pluralName: 'deals',
    fieldsSchema: FIELDS_SCHEMA$v,
    categories: ['CRM', 'Sales'],
    list: {
        filterFields: [
            'companyId',
            'name',
            'stage',
            'status',
            'contactId',
            'campaignId',
            'source',
            'type',
            'ownerId',
        ],
    },
    find: {
        queryFields: [
            'companyId',
            'name',
            'stage',
            'status',
            'contactId',
            'campaignId',
            'source',
            'type',
            'ownerId',
        ],
    },
    match: {
        fields: [
            'companyId',
            'name',
            'stage',
            'status',
            'contactId',
            'campaignId',
            'source',
            'type',
            'ownerId',
        ],
    },
};

const FIELDS_SCHEMA$u = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        uri: { type: 'string', readOnly: true },
        title: { type: 'string' },
        parentDocumentId: { type: 'string', referenceUdm: 'documents' },
        canHaveChildren: { type: 'boolean', readOnly: true },
        isDownloadable: { type: 'boolean', readOnly: true, default: true },
        text: { type: 'string' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$u = {
    singularName: 'document',
    pluralName: 'documents',
    fieldsSchema: FIELDS_SCHEMA$u,
    categories: ['Document Management'],
    list: {
        filterFields: ['parentDocumentId', 'ownerId'],
    },
};

const FIELDS_SCHEMA$t = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        itemType: { type: 'string', enum: ['file', 'folder'], allowCustom: true },
        name: { type: 'string' },
        mimeType: { type: 'string' },
        description: { type: 'string' },
        previewUri: { type: 'string', readOnly: true },
        size: { type: 'integer', readOnly: true },
        path: { type: 'string', readOnly: true },
        folderId: { type: 'string', referenceUdm: 'drive-items' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        driveId: { type: 'string', referenceUdm: 'drives' },
        downloadUri: { type: 'string', readOnly: true },
        uri: { type: 'string', readOnly: true },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$t = {
    singularName: 'drive-item',
    pluralName: 'drive-items',
    fieldsSchema: FIELDS_SCHEMA$t,
    categories: ['File Storage', 'Communication', 'Document Management'],
    list: {
        filterFields: ['ownerId', 'folderId', 'driveId', 'mimeType', 'itemType'],
    },
};

const FIELDS_SCHEMA$s = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        description: { type: 'string' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        uri: { type: 'string', readOnly: true },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$s = {
    singularName: 'drive',
    pluralName: 'drives',
    fieldsSchema: FIELDS_SCHEMA$s,
    categories: ['File Storage', 'Communication'],
    list: {
        filterFields: ['ownerId', 'name'],
    },
    match: {
        fields: ['ownerId', 'name'],
    },
};

const FIELDS_SCHEMA$r = {
    type: 'object',
    properties: {
        id: {
            type: 'string',
            readonly: true,
        },
        candidateId: {
            type: 'string',
            referenceUdm: 'jobCandidates',
        },
        race: { type: 'string' },
        gender: { type: 'string' },
        veteranStatus: { type: 'string' },
        disabilityStatus: { type: 'string' },
        submittedTime: { type: 'string', format: 'date-time', readOnly: true },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$f = [
    'candidateId',
    'race',
    'gender',
    'veteranStatus',
    'disabilityStatus',
];
const udm$r = {
    singularName: 'eeoc',
    pluralName: 'eeocs',
    description: 'Represents the Equal Employment Opportunity Commission information for a candidate',
    fieldsSchema: FIELDS_SCHEMA$r,
    categories: ['ATS'],
    match: {
        fields: FILTER_FIELDS$f,
    },
    list: {
        filterFields: FILTER_FIELDS$f,
    },
};

const FIELDS_SCHEMA$q = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        threadId: { type: 'string', readOnly: true },
        to: {
            type: 'array',
            items: { type: 'string' },
        },
        cc: {
            type: 'array',
            items: { type: 'string' },
        },
        bcc: {
            type: 'array',
            items: { type: 'string' },
        },
        from: { type: 'string' },
        replyTo: { type: 'string' },
        subject: { type: 'string' },
        body: { type: 'string' },
        html_body: { type: 'string' },
        status: { type: 'string' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        contactId: { type: 'string', referenceUdm: 'contacts' },
        leadId: { type: 'string', referenceUdm: 'leads' },
        companyId: { type: 'string', referenceUdm: 'companies' },
        dealId: { type: 'string', referenceUdm: 'deals' },
        attachments: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    type: { type: 'string' },
                    name: { type: 'string' },
                    url: { type: 'string' },
                    content: { type: 'string' },
                },
            },
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$q = {
    singularName: 'email',
    pluralName: 'emails',
    fieldsSchema: FIELDS_SCHEMA$q,
    categories: [
        'Communication',
        'CRM',
        'Sales',
        'Customer Success',
        'Marketing Automation',
    ],
    list: {
        filterFields: [
            'subject',
            'status',
            'ownerId',
            'contactId',
            'leadId',
            'companyId',
            'dealId',
        ],
    },
    match: {
        fields: [
            'subject',
            'status',
            'ownerId',
            'contactId',
            'leadId',
            'companyId',
            'dealId',
        ],
    },
    udmFallbacks: [
        {
            udm: 'activities',
            importFields: FallbackFieldsMap.fromActivitiesToEmails,
            exportFields: FallbackFieldsMap.fromEmailsToActivities,
        },
    ],
};

const FIELDS_SCHEMA$p = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        fullName: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        userName: { type: 'string' },
        preferredName: { type: 'string' },
        personalEmail: { type: 'string' },
        workEmail: { type: 'string' },
        mobileNumber: { type: 'string' },
        homeAddress: AddressSchema,
        workAddress: AddressSchema,
        employmentStatus: {
            type: 'string',
            enum: ['active', 'inactive', 'terminated', 'other'],
        },
        companyId: { type: 'string', referenceUdm: 'companies' },
        departmentId: { type: 'string' },
        startDate: { type: 'string', format: 'date-time' },
        terminationDate: { type: 'string', format: 'date-time' },
        gender: {
            type: 'string',
            enum: ['male', 'female', 'other', 'not_specified'],
            allowCustom: true,
        },
        ethnicity: { type: 'string' },
        birthday: { type: 'string', format: 'date-time' },
        photoUrl: { type: 'string' },
        timezone: { type: 'string' },
        title: { type: 'string' },
        employments: {
            type: 'array',
            properties: {
                id: { type: 'string' },
                title: { type: 'string' },
                role: { type: 'string' },
                type: { type: 'string' },
                compensationRate: { type: 'number' },
                paymentUnit: { type: 'string' },
                currency: { type: 'string' },
                department: { type: 'string' },
                division: { type: 'string' },
                location: AddressSchema,
                startDate: { type: 'string', format: 'date-time' },
                endDate: { type: 'string', format: 'date-time' },
            },
        },
        compensations: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    jobId: { type: 'string' },
                    rate: { type: 'number' },
                    paymentUnit: { type: 'string' },
                    currency: { type: 'string' },
                    paymentFrequency: { type: 'string' },
                    flsaStatus: { type: 'string' },
                    effectiveDate: { type: 'string', format: 'date-time' },
                },
            },
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$e = [
    'companyId',
    'ethnicity',
    'firstName',
    'fullName',
    'gender',
    'lastName',
    'mobileNumber',
    'personalEmail',
    'title',
    'userName',
    'workEmail',
];
const udm$p = {
    singularName: 'employee',
    pluralName: 'employees',
    fieldsSchema: FIELDS_SCHEMA$p,
    categories: ['HRIS', 'ATS'],
    match: {
        fields: FILTER_FIELDS$e,
    },
    list: {
        filterFields: FILTER_FIELDS$e,
    },
    fieldFallbacks: {
        fullName: [
            {
                $concat: {
                    values: [{ $var: 'firstName' }, { $var: 'lastName' }],
                    delimiter: ' ',
                },
            },
        ],
        firstName: [
            {
                $firstName: {
                    $var: 'fullName',
                },
            },
        ],
        lastName: [
            {
                $lastName: {
                    $var: 'fullName',
                },
            },
        ],
        'homeAddress.full': [
            {
                $concat: {
                    values: [
                        { $var: 'homeAddress.street' },
                        { $var: 'homeAddress.city' },
                        { $var: 'homeAddress.state' },
                        { $var: 'homeAddress.zip' },
                        { $var: 'homeAddress.country' },
                    ],
                    delimiter: ', ',
                },
            },
        ],
    },
    udmFallbacks: [
        {
            udm: 'users',
            importFields: {
                workEmail: {
                    $var: 'primaryEmail',
                },
                mobileNumber: {
                    $var: 'primaryPhone',
                },
                workAddress: {
                    $var: 'primaryAddress',
                },
            },
            exportFields: {
                primaryEmail: {
                    $var: 'workEmail',
                },
                primaryPhone: {
                    $var: 'mobileNumber',
                },
                primaryAddress: {
                    $var: 'workAddress',
                },
            },
        },
    ],
};

const FIELDS_SCHEMA$o = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        mimeType: { type: 'string' },
        name: { type: 'string' },
        description: { type: 'string' },
        previewUri: { type: 'string', readOnly: true },
        size: { type: 'integer', readOnly: true },
        path: { type: 'string', readOnly: true },
        folderId: { type: 'string', referenceUdm: 'folders' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        driveId: { type: 'string', referenceUdm: 'drives' },
        downloadUri: { type: 'string', readOnly: true },
        uri: { type: 'string', readOnly: true },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$o = {
    singularName: 'file',
    pluralName: 'files',
    fieldsSchema: FIELDS_SCHEMA$o,
    categories: ['File Storage', 'Communication', 'Document Management'],
    list: {
        filterFields: [
            'ownerId',
            'folderId',
            'driveId',
            'name',
            'mimeType',
            'size',
        ],
    },
    match: {
        fields: ['ownerId', 'driveId', 'folderId', 'name', 'mimeType', 'size'],
    },
};

const FIELDS_SCHEMA$n = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        description: { type: 'string' },
        size: { type: 'integer', readOnly: true },
        path: { type: 'string', readOnly: true },
        parentFolderId: { type: 'string', referenceUdm: 'folders' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        driveId: { type: 'string', referenceUdm: 'drives' },
        downloadUri: { type: 'string', readOnly: true },
        uri: { type: 'string', readOnly: true },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$n = {
    singularName: 'folder',
    pluralName: 'folders',
    fieldsSchema: FIELDS_SCHEMA$n,
    categories: ['File Storage', 'Communication', 'Document Management'],
    list: {
        filterFields: ['ownerId', 'parentFolderId', 'driveId', 'name', 'size'],
    },
    match: {
        fields: ['ownerId', 'parentFolderId', 'driveId', 'name', 'size'],
    },
};

const FIELDS_SCHEMA$m = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        number: { type: 'string' },
        name: { type: 'string' },
        memo: { type: 'string' },
        status: { type: 'string' },
        paymentMethod: { type: 'string' },
        customerId: { type: 'string', referenceUdm: 'customers' },
        currency: { type: 'string' },
        payments: {
            type: 'array',
            items: {
                type: 'string',
                referenceUdm: 'payments',
            },
        },
        lineItems: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    itemName: { type: 'string' },
                    description: { type: 'string' },
                    code: { type: 'string' },
                    type: { type: 'string' },
                    status: { type: 'string' },
                    companyId: { type: 'string', referenceUdm: 'companies' },
                    ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
                    quantity: { type: 'number' },
                    unitOfMeasure: { type: 'string' },
                    unitPrice: { type: 'number' },
                    purchasePrice: { type: 'number' },
                    salesPrice: { type: 'number' },
                    taxable: { type: 'boolean' },
                    taxAmount: { type: 'number' },
                    totalAmount: { type: 'number' },
                    inventoryDate: { type: 'string', format: 'date-time' },
                },
            },
        },
        totalAmount: { type: 'number' },
        totalTax: { type: 'number' },
        exchangeRate: { type: 'number' },
        totalDiscount: { type: 'number' },
        subTotal: { type: 'number' },
        balance: { type: 'number' },
        ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
        issueDate: {
            type: 'string',
            format: 'date-time',
        },
        dueDate: {
            type: 'string',
            format: 'date-time',
        },
        paidOnDate: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$m = {
    singularName: 'invoice',
    pluralName: 'invoices',
    fieldsSchema: FIELDS_SCHEMA$m,
    categories: ['Accounting', 'Payments'],
    list: {
        filterFields: [
            'number',
            'name',
            'status',
            'customerId',
            'paymentMethod',
            'issueDate',
            'dueDate',
            'paidOnDate',
        ],
    },
    match: {
        fields: [
            'number',
            'name',
            'status',
            'customerId',
            'paymentMethod',
            'issueDate',
            'dueDate',
            'paidOnDate',
        ],
    },
};

const FIELDS_SCHEMA$l = {
    type: 'object',
    properties: {
        id: {
            type: 'string',
            readonly: true,
        },
        candidateId: {
            type: 'string',
            referenceUdm: 'jobCandidates',
        },
        jobId: {
            type: 'string',
            referenceUdm: 'jobs',
        },
        appliedAt: {
            type: 'string',
            format: 'date-time',
        },
        status: { type: 'string' },
        currentStage: { type: 'string' },
        source: { type: 'string' },
        rejectedTime: {
            type: 'string',
            format: 'date-time',
        },
        rejectionReason: { type: 'string' },
        creditedTo: {
            type: 'string',
            referenceUdm: 'users',
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$d = [
    'candidateId',
    'jobId',
    'status',
    'currentStage',
    'source',
];
const udm$l = {
    singularName: 'job-application',
    pluralName: 'job-applications',
    fieldsSchema: FIELDS_SCHEMA$l,
    categories: ['ATS'],
    match: {
        fields: FILTER_FIELDS$d,
    },
    list: {
        filterFields: FILTER_FIELDS$d,
    },
};

const FIELDS_SCHEMA$k = {
    type: 'object',
    properties: {
        id: { type: 'string', readonly: true },
        fullName: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        company: { type: 'string' },
        title: { type: 'string' },
        addresses: { type: 'array', items: AddressSchema },
        phones: { type: 'array', items: PhoneEmailSchema },
        primaryEmail: { type: 'string' },
        primaryPhone: { type: 'string' },
        emails: { type: 'array', items: PhoneEmailSchema },
        urls: { type: 'array', items: PhoneEmailSchema },
        applicationIds: {
            type: 'array',
            items: {
                type: 'string',
                referenceUdm: 'jobApplications',
            },
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$c = [
    'firstName',
    'lastName',
    'fullName',
    'title',
    'company',
    'primaryEmail',
    'primaryPhone',
];
const udm$k = {
    singularName: 'job-candidate',
    pluralName: 'job-candidates',
    fieldsSchema: FIELDS_SCHEMA$k,
    categories: ['ATS'],
    match: {
        fields: FILTER_FIELDS$c,
    },
    list: {
        filterFields: FILTER_FIELDS$c,
    },
    fieldFallbacks: {
        fullName: [
            {
                $concat: {
                    values: [{ $var: 'firstName' }, { $var: 'lastName' }],
                    delimiter: ' ',
                },
            },
        ],
        firstName: [
            {
                $firstName: {
                    $var: 'fullName',
                },
            },
        ],
        lastName: [
            {
                $lastName: {
                    $var: 'fullName',
                },
            },
        ],
        primaryEmail: [
            {
                $primaryEmail: {
                    $var: 'emails[0].value',
                },
            },
        ],
        primaryPhone: [
            {
                $primaryPhone: {
                    $var: 'phones[0].value',
                },
            },
        ],
    },
};

const FIELDS_SCHEMA$j = {
    type: 'object',
    properties: {
        id: {
            type: 'string',
            readonly: true,
        },
        candidateId: {
            type: 'string',
            referenceUdm: 'jobCandidates',
        },
        organizerId: { type: 'string', referenceUdm: 'users' },
        interviewerIds: {
            type: 'array',
            items: { type: 'string', referenceUdm: 'users' },
        },
        stage: { type: 'string' },
        status: { type: 'string' },
        location: { type: 'string' },
        startTime: { type: 'string', format: 'date-time' },
        endTime: { type: 'string', format: 'date-time' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$b = ['candidateId', 'organizerId', 'stage', 'status'];
const udm$j = {
    singularName: 'job-interview',
    pluralName: 'job-interviews',
    fieldsSchema: FIELDS_SCHEMA$j,
    categories: ['ATS'],
    match: {
        fields: FILTER_FIELDS$b,
    },
    list: {
        filterFields: FILTER_FIELDS$b,
    },
};

const FIELDS_SCHEMA$i = {
    type: 'object',
    properties: {
        id: {
            type: 'string',
            readonly: true,
        },
        jobApplicationId: {
            type: 'string',
            referenceUdm: 'job-applications',
        },
        status: { type: 'string' },
        sentTime: {
            type: 'string',
            format: 'date-time',
        },
        closedTime: {
            type: 'string',
            format: 'date-time',
        },
        startDate: {
            type: 'string',
            format: 'date',
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$a = ['jobApplicationId', 'status'];
const udm$i = {
    singularName: 'job-offer',
    pluralName: 'job-offers',
    fieldsSchema: FIELDS_SCHEMA$i,
    categories: ['ATS'],
    match: {
        fields: FILTER_FIELDS$a,
    },
    list: {
        filterFields: FILTER_FIELDS$a,
    },
};

const FIELDS_SCHEMA$h = {
    type: 'object',
    properties: {
        id: {
            type: 'string',
            readonly: true,
        },
        name: { type: 'string' },
        description: { type: 'string' },
        code: { type: 'string' },
        status: { type: 'string' },
        isConfidential: { type: 'boolean' },
        hiringManagersIds: {
            type: 'array',
            items: { type: 'string', referenceUdm: 'users' },
        },
        recruitersIds: {
            type: 'array',
            items: { type: 'string', referenceUdm: 'users' },
        },
        departmentsIds: { type: 'array', items: { type: 'string' } },
        officesIds: { type: 'array', items: { type: 'string' } },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$9 = ['name', 'code', 'status'];
const udm$h = {
    singularName: 'job',
    pluralName: 'jobs',
    fieldsSchema: FIELDS_SCHEMA$h,
    categories: ['ATS'],
    match: {
        fields: FILTER_FIELDS$9,
    },
    list: {
        filterFields: FILTER_FIELDS$9,
    },
};

const FIELDS_SCHEMA$g = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        number: { type: 'string' },
        title: { type: 'string' },
        memo: { type: 'string' },
        currency: { type: 'string' },
        companyId: { type: 'string', referenceUdm: 'companies' },
        lineItems: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    description: { type: 'string' },
                    type: { type: 'string', enum: ['debit', 'credit'] },
                    amount: { type: 'number' },
                    ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
                    companyId: { type: 'string', referenceUdm: 'companies' },
                    contactId: { type: 'string', referenceUdm: 'contacts' },
                    exchangeRate: { type: 'number' },
                },
            },
        },
        taxType: { type: 'string' },
        taxCode: { type: 'string' },
        ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
        payments: {
            type: 'array',
            items: { type: 'string', referenceUdm: 'payments' },
        },
        transactionDate: { type: 'string', format: 'date-time' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
    },
};
const udm$g = {
    singularName: 'journal-entry',
    pluralName: 'journal-entries',
    fieldsSchema: FIELDS_SCHEMA$g,
    categories: ['Accounting', 'Payments'],
    list: {
        filterFields: [
            'number',
            'title',
            'companyId',
            'ledgerAccountId',
            'transactionDate',
        ],
    },
    match: {
        fields: [
            'number',
            'title',
            'companyId',
            'ledgerAccountId',
            'transactionDate',
        ],
    },
};

const FIELDS_SCHEMA$f = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        fullName: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        primaryEmail: { type: 'string' },
        emails: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        primaryPhone: { type: 'string' },
        phones: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        primaryAddress: AddressSchema,
        addresses: {
            type: 'array',
            items: AddressSchema,
        },
        stage: { type: 'string' },
        value: { type: 'number' },
        companyName: { type: 'string' },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        jobTitle: { type: 'string' },
        source: { type: 'string' },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        lastActivityTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
    },
};
const FILTER_FIELDS$8 = [
    'fullName',
    'firstName',
    'lastName',
    'primaryEmail',
    'primaryPhone',
    'companyId',
    'companyName',
    'jobTitle',
    'source',
    'stage',
    'value',
    'ownerId',
];
const udm$f = {
    singularName: 'lead',
    pluralName: 'leads',
    fieldsSchema: FIELDS_SCHEMA$f,
    categories: ['CRM', 'Sales', 'Marketing Automation'],
    find: {
        queryFields: FILTER_FIELDS$8,
    },
    list: {
        filterFields: FILTER_FIELDS$8,
    },
    match: {
        fields: FILTER_FIELDS$8,
    },
    udmFallbacks: [{ udm: 'contacts' }],
    fieldFallbacks: {
        fullName: [
            {
                $concat: {
                    values: [{ $var: 'firstName' }, { $var: 'lastName' }],
                    delimiter: ' ',
                },
            },
        ],
        firstName: [
            {
                $firstName: {
                    $var: 'fullName',
                },
            },
        ],
        lastName: [
            {
                $lastName: {
                    $var: 'fullName',
                },
            },
        ],
        primaryEmail: [
            {
                $var: 'emails[0].value',
            },
        ],
        emails: [
            [
                {
                    value: { $var: 'primaryEmail' },
                },
            ],
        ],
        primaryPhone: [
            {
                $var: 'phones[0].value',
            },
        ],
        phones: [
            [
                {
                    value: { $var: 'primaryPhone' },
                },
            ],
        ],
        primaryAddress: [
            {
                $var: 'addresses[0]',
            },
        ],
        addresses: [
            [
                {
                    value: { $var: 'primaryAddress' },
                },
            ],
        ],
        'primaryAddress.full': [
            {
                $concat: {
                    values: [
                        { $var: 'primaryAddress.street' },
                        { $var: 'primaryAddress.city' },
                        { $var: 'primaryAddress.state' },
                        { $var: 'primaryAddress.zip' },
                        { $var: 'primaryAddress.country' },
                    ],
                    delimiter: ', ',
                },
            },
        ],
    },
};

const FIELDS_SCHEMA$e = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        code: { type: 'string' },
        description: { type: 'string' },
        classification: {
            type: 'string',
            enum: ['Asset', 'Liability', 'Equity', 'Revenue', 'Expense'],
        },
        type: { type: 'string' },
        status: {
            type: 'string',
            enum: ['Active', 'Inactive', 'Archived'],
        },
        currentBalance: { type: 'number' },
        currency: { type: 'string' },
        taxRateId: {
            type: 'string',
            referenceUdm: 'tax-rates',
        },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$e = {
    singularName: 'ledger-account',
    pluralName: 'ledger-accounts',
    fieldsSchema: FIELDS_SCHEMA$e,
    categories: ['Accounting'],
    list: {
        filterFields: [
            'name',
            'code',
            'type',
            'status',
            'classification',
            'companyId',
        ],
    },
    match: {
        fields: ['name', 'code', 'type', 'status', 'classification', 'companyId'],
    },
};

const FIELDS_SCHEMA$d = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        title: {
            type: 'string',
        },
        description: {
            type: 'string',
        },
        durationSeconds: {
            type: 'number',
        },
        location: {
            type: 'string',
        },
        isRecurrent: {
            type: 'boolean',
        },
        participants: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    userId: {
                        type: 'string',
                        referenceUdm: 'users',
                    },
                    contactId: {
                        type: 'string',
                        referenceUdm: 'contacts',
                    },
                    leadId: {
                        type: 'string',
                        referenceUdm: 'leads',
                    },
                },
            },
        },
        status: {
            type: 'string',
        },
        contactId: {
            type: 'string',
            referenceUdm: 'contacts',
        },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        dealId: {
            type: 'string',
            referenceUdm: 'deals',
        },
        leadId: {
            type: 'string',
            referenceUdm: 'leads',
        },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        startTime: {
            type: 'string',
            format: 'date-time',
        },
        endTime: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
    },
};
const udm$d = {
    singularName: 'meeting',
    pluralName: 'meetings',
    fieldsSchema: FIELDS_SCHEMA$d,
    categories: [
        'CRM',
        'Sales',
        'Marketing Automation',
        'Communication',
        'Project Management',
        'Customer Success',
    ],
    list: {
        filterFields: [
            'title',
            'companyId',
            'contactId',
            'dealId',
            'leadId',
            'ownerId',
            'status',
        ],
    },
    match: {
        fields: [
            'title',
            'companyId',
            'contactId',
            'dealId',
            'leadId',
            'ownerId',
            'status',
        ],
    },
    udmFallbacks: [
        {
            udm: 'activities',
        },
    ],
    fieldFallbacks: {
        endTime: [
            {
                $var: 'startTime',
            },
        ],
        startTime: [
            {
                $var: 'endTime',
            },
        ],
    },
};

const FIELDS_SCHEMA$c = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        subject: { type: 'string' },
        channelId: { type: 'string' },
        threadId: { type: 'string' },
        text: { type: 'string' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        status: { type: 'string' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$c = {
    singularName: 'message',
    pluralName: 'messages',
    fieldsSchema: FIELDS_SCHEMA$c,
    categories: ['Communication'],
};

const FIELDS_SCHEMA$b = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        title: { type: 'string' },
        content: { type: 'string' },
        status: { type: 'string' },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        contactId: {
            type: 'string',
            referenceUdm: 'contacts',
        },
        leadId: {
            type: 'string',
            referenceUdm: 'leads',
        },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        dealId: {
            type: 'string',
            referenceUdm: 'deals',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
    },
};
const udm$b = {
    singularName: 'note',
    pluralName: 'notes',
    fieldsSchema: FIELDS_SCHEMA$b,
    categories: [
        'CRM',
        'Sales',
        'Marketing Automation',
        'Communication',
        'Project Management',
        'Customer Success',
        'Ticketing',
        'ATS',
        'HRIS',
    ],
    list: {
        filterFields: [
            'companyId',
            'contactId',
            'dealId',
            'leadId',
            'ownerId',
            'status',
            'title',
        ],
    },
    match: {
        fields: [
            'companyId',
            'contactId',
            'dealId',
            'leadId',
            'ownerId',
            'status',
            'title',
        ],
    },
    udmFallbacks: [
        {
            udm: 'activities',
            importFields: FallbackFieldsMap.fromActivitiesToNotes,
            exportFields: FallbackFieldsMap.fromNotesToActivities,
        },
    ],
};

const FIELDS_SCHEMA$a = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        notes: { type: 'string' },
        status: { type: 'string', enum: ['open', 'closed'] },
        customerId: { type: 'string', referenceUdm: 'customers' },
        currency: { type: 'string' },
        totalAmount: { type: 'number' },
        paymentMethod: { type: 'string' },
        paymentStatus: { type: 'string' },
        fullFillmentStatus: { type: 'string' },
        billingAddress: AddressSchema,
        shippingAddress: AddressSchema,
        lineItems: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    name: { type: 'string' },
                    productId: { type: 'string', referenceUdm: 'products' },
                    sku: { type: 'string' },
                    quantity: { type: 'number' },
                    unitPrice: { type: 'number' },
                    totalAmount: { type: 'number' },
                },
            },
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$7 = [
    'name',
    'status',
    'customerId',
    'currency',
    'paymentMethod',
    'paymentStatus',
];
const udm$a = {
    singularName: 'order',
    pluralName: 'orders',
    fieldsSchema: FIELDS_SCHEMA$a,
    categories: ['CRM', 'Sales', 'E-Commerce', 'Accounting', 'Payments'],
    list: {
        filterFields: FILTER_FIELDS$7,
    },
    find: {
        queryFields: FILTER_FIELDS$7,
    },
    match: {
        fields: FILTER_FIELDS$7,
    },
};

const FIELDS_SCHEMA$9 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        status: { type: 'string' },
        type: { type: 'string' },
        notes: { type: 'string' },
        currency: { type: 'string' },
        exchangeRate: { type: 'string' },
        totalAmount: { type: 'number' },
        supplierId: { type: 'string', referenceUdm: 'suppliers' },
        customerId: { type: 'string', referenceUdm: 'customers' },
        ledgerAccountId: { type: 'string', referenceUdm: 'ledger-accounts' },
        paymentMethod: { type: 'string' },
        transactionDate: { type: 'string', format: 'date-time' },
        isReconciled: { type: 'boolean' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$9 = {
    singularName: 'payment',
    pluralName: 'payments',
    fieldsSchema: FIELDS_SCHEMA$9,
    categories: ['Accounting', 'Payments'],
    list: {
        filterFields: [
            'customerId',
            'type',
            'status',
            'supplierId',
            'ledgerAccountId',
            'paymentMethod',
            'isReconciled',
        ],
    },
    match: {
        fields: [
            'customerId',
            'type',
            'status',
            'supplierId',
            'ledgerAccountId',
            'paymentMethod',
            'isReconciled',
        ],
    },
};

const FIELDS_SCHEMA$8 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        employeeId: { type: 'string', referenceUdm: 'employees' },
        companyId: { type: 'string', referenceUdm: 'companies' },
        runState: {
            type: 'string',
            enum: ['PAID', 'DRAFT', 'APPROVED', 'CLOSED'],
            allowCustom: true,
        },
        runType: {
            type: 'string',
            enum: [
                'REGULAR',
                'OFF_CYCLE',
                'UNSCHEDULED',
                'CORRECTION',
                'TERMINATION',
                'SIGN_ON_BONUS',
            ],
            allowCustom: true,
        },
        isProcessed: { type: 'boolean' },
        processedTime: { type: 'string', format: 'date-time' },
        checkTime: { type: 'string', format: 'date-time' },
        startTime: { type: 'string', format: 'date-time' },
        endTime: { type: 'string', format: 'date-time' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$6 = [
    'employeeId',
    'companyId',
    'runState',
    'runType',
    'isProcessed',
];
const udm$8 = {
    singularName: 'payroll',
    pluralName: 'payrolls',
    fieldsSchema: FIELDS_SCHEMA$8,
    categories: ['HRIS'],
    match: {
        fields: FILTER_FIELDS$6,
    },
    list: {
        filterFields: FILTER_FIELDS$6,
    },
};

const FIELDS_SCHEMA$7 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        description: { type: 'string' },
        code: { type: 'string' },
        type: { type: 'string' },
        weight: { type: 'number' },
        isActive: { type: 'boolean' },
        price: { type: 'number' },
        status: { type: 'string' },
        options: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    name: { type: 'string' },
                    values: { type: 'array', items: { type: 'string' } },
                },
            },
        },
        variants: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    name: { type: 'string' },
                    price: { type: 'number' },
                    sku: { type: 'string' },
                    weight: { type: 'number' },
                },
            },
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$5 = [
    'name',
    'code',
    'type',
    'weight',
    'isActive',
    'price',
    'status',
];
const udm$7 = {
    singularName: 'product',
    pluralName: 'products',
    fieldsSchema: FIELDS_SCHEMA$7,
    categories: [
        'E-Commerce',
        'Accounting',
        'Sales',
        'CRM',
        'Customer Success',
        'Payments',
    ],
    list: {
        filterFields: FILTER_FIELDS$5,
    },
    match: {
        fields: FILTER_FIELDS$5,
    },
};

const FIELDS_SCHEMA$6 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        description: { type: 'string' },
        type: { type: 'string' },
        parentId: { type: 'string', referenceUdm: 'projects' },
        ownerId: { type: 'string', referenceUdm: 'users' },
        startTime: { type: 'string', format: 'date-time' },
        dueTime: { type: 'string', format: 'date-time' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$6 = {
    singularName: 'project',
    pluralName: 'projects',
    fieldsSchema: FIELDS_SCHEMA$6,
    categories: ['Project Management'],
    find: {
        queryFields: ['name', 'description', 'type', 'ownerId'],
    },
    list: {
        filterFields: ['name', 'description', 'type', 'ownerId'],
    },
    match: {
        fields: ['name', 'description', 'type', 'ownerId'],
    },
};

const FIELDS_SCHEMA$5 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        code: { type: 'string' },
        description: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        companyName: { type: 'string' },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        status: { type: 'string' },
        currency: { type: 'string' },
        addresses: {
            type: 'array',
            items: AddressSchema,
        },
        phones: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        emails: {
            type: 'array',
            items: PhoneEmailSchema,
        },
        websiteUrl: {
            type: 'string',
        },
        notes: { type: 'string' },
        taxNumber: { type: 'string' },
        orderIds: {
            type: 'array',
            items: {
                type: 'string',
                referenceUdm: 'orders',
            },
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$4 = [
    'companyName',
    'firstName',
    'lastName',
    'name',
    'code',
    'status',
    'currency',
    'companyId',
    'websiteUrl',
    'taxNumber',
];
const udm$5 = {
    singularName: 'supplier',
    pluralName: 'suppliers',
    fieldsSchema: FIELDS_SCHEMA$5,
    categories: ['CRM', 'Sales', 'E-Commerce', 'Accounting', 'Payments'],
    list: {
        filterFields: FILTER_FIELDS$4,
    },
    match: {
        fields: FILTER_FIELDS$4,
    },
    udmFallbacks: [
        {
            udm: 'companies',
        },
    ],
};

const FIELDS_SCHEMA$4 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        subject: { type: 'string' },
        content: { type: 'string' },
        status: { type: 'string' },
        type: { type: 'string' },
        priority: { type: 'string' },
        ownerId: {
            type: 'string',
            referenceUdm: 'users',
        },
        assigneeId: {
            type: 'string',
            referenceUdm: 'users',
        },
        followerIds: {
            type: 'array',
            items: { type: 'string', referenceUdm: 'users' },
        },
        parentTaskId: {
            type: 'string',
            referenceUdm: 'tasks',
        },
        projectId: {
            type: 'string',
            referenceUdm: 'projects',
        },
        tags: {
            type: 'array',
            items: { type: 'string' },
        },
        contactId: {
            type: 'string',
            referenceUdm: 'contacts',
        },
        leadId: {
            type: 'string',
            referenceUdm: 'leads',
        },
        companyId: {
            type: 'string',
            referenceUdm: 'companies',
        },
        dealId: {
            type: 'string',
            referenceUdm: 'deals',
        },
        dueTime: {
            type: 'string',
            format: 'date-time',
        },
        startTime: {
            type: 'string',
            format: 'date-time',
        },
        endTime: {
            type: 'string',
            format: 'date-time',
        },
        createdTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        createdBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
        updatedTime: {
            type: 'string',
            format: 'date-time',
            readOnly: true,
        },
        updatedBy: {
            type: 'string',
            referenceUdm: 'users',
            readOnly: true,
        },
    },
};
const FILTER_FIELDS$3 = [
    'companyId',
    'contactId',
    'dealId',
    'leadId',
    'ownerId',
    'status',
    'type',
    'priority',
    'assigneeId',
    'parentTaskId',
    'projectId',
];
const udm$4 = {
    singularName: 'task',
    pluralName: 'tasks',
    fieldsSchema: FIELDS_SCHEMA$4,
    categories: [
        'Project Management',
        'CRM',
        'Sales',
        'Customer Success',
        'Ticketing',
    ],
    list: {
        filterFields: FILTER_FIELDS$3,
    },
    match: {
        fields: FILTER_FIELDS$3,
    },
    udmFallbacks: [
        {
            udm: 'activities',
            importFields: FallbackFieldsMap.fromActivitiesToTasks,
            exportFields: FallbackFieldsMap.fromTasksToActivities,
        },
    ],
    fieldFallbacks: {
        endTime: [
            {
                $var: 'startTime',
            },
        ],
        startTime: [
            {
                $var: 'endTime',
            },
        ],
        assigneeId: [
            {
                $var: 'ownerId',
            },
        ],
        ownerId: [
            {
                $var: 'assigneeId',
            },
        ],
    },
};

const FIELDS_SCHEMA$3 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        name: { type: 'string' },
        code: { type: 'string' },
        description: { type: 'string' },
        effectiveTaxRate: { type: 'number' },
        totalTaxRate: { type: 'number' },
        type: { type: 'string' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const udm$3 = {
    singularName: 'tax-rate',
    pluralName: 'tax-rates',
    fieldsSchema: FIELDS_SCHEMA$3,
    categories: ['Accounting', 'Payments'],
    list: {
        filterFields: ['name', 'code', 'type', 'effectiveTaxRate', 'totalTaxRate'],
    },
    match: {
        fields: ['name', 'code', 'type', 'effectiveTaxRate', 'totalTaxRate'],
    },
};

const FIELDS_SCHEMA$2 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        employeeId: { type: 'string', referenceUdm: 'employees' },
        balanceHours: { type: 'number' },
        usedHours: { type: 'number' },
        policyType: {
            type: 'string',
            enum: [
                'VACATION',
                'SICK',
                'PERSONAL',
                'JURY_DUTY',
                'VOLUNTEER',
                'BEREAVEMENT',
            ],
            allowCustom: true,
        },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$2 = [
    'employeeId',
    'approverId',
    'status',
    'requestType',
    'startTime',
    'endTime',
];
const udm$2 = {
    singularName: 'timeoff-balance',
    pluralName: 'timeoff-balances',
    fieldsSchema: FIELDS_SCHEMA$2,
    categories: ['HRIS'],
    match: {
        fields: FILTER_FIELDS$2,
    },
    list: {
        filterFields: FILTER_FIELDS$2,
    },
};

const FIELDS_SCHEMA$1 = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        employeeId: { type: 'string', referenceUdm: 'employees' },
        approverId: { type: 'string', referenceUdm: 'employees' },
        status: {
            type: 'string',
            enum: ['REQUESTED', 'APPROVED', 'DECLINED', 'CANCELLED'],
            allowCustom: true,
        },
        employeeNote: { type: 'string' },
        units: {
            type: 'string',
            enum: ['DAYS', 'HOURS'],
            allowCustom: true,
        },
        amount: { type: 'number' },
        requestType: {
            type: 'string',
            enum: [
                'VACATION',
                'SICK',
                'PERSONAL',
                'JURY_DUTY',
                'VOLUNTEER',
                'BEREAVEMENT',
            ],
            allowCustom: true,
        },
        startTime: { type: 'string', format: 'date-time' },
        endTime: { type: 'string', format: 'date-time' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS$1 = [
    'employeeId',
    'approverId',
    'status',
    'requestType',
    'startTime',
    'endTime',
];
const udm$1 = {
    singularName: 'timeoff-request',
    pluralName: 'timeoff-requests',
    fieldsSchema: FIELDS_SCHEMA$1,
    categories: ['HRIS'],
    match: {
        fields: FILTER_FIELDS$1,
    },
    list: {
        filterFields: FILTER_FIELDS$1,
    },
};

const FIELDS_SCHEMA = {
    type: 'object',
    properties: {
        id: { type: 'string', readOnly: true },
        title: { type: 'string' },
        fullName: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        userName: { type: 'string' },
        primaryEmail: { type: 'string' },
        emails: { type: 'array', items: PhoneEmailSchema },
        primaryPhone: { type: 'string' },
        phones: { type: 'array', items: PhoneEmailSchema },
        primaryAddress: AddressSchema,
        addresses: {
            type: 'array',
            items: AddressSchema,
        },
        companyName: { type: 'string' },
        companyId: { type: 'string', referenceUdm: 'companies' },
        imageUrl: { type: 'string' },
        timezone: { type: 'string' },
        isActive: { type: 'boolean' },
        roleId: { type: 'string' },
        createdTime: { type: 'string', format: 'date-time', readOnly: true },
        createdBy: { type: 'string', referenceUdm: 'users', readOnly: true },
        updatedTime: { type: 'string', format: 'date-time', readOnly: true },
        updatedBy: { type: 'string', referenceUdm: 'users', readOnly: true },
    },
};
const FILTER_FIELDS = [
    'companyId',
    'companyName',
    'userName',
    'fullName',
    'firstName',
    'lastName',
    'primaryEmail',
    'primaryPhone',
    'roleId',
    'title',
    'isActive',
];
const udm = {
    singularName: 'user',
    pluralName: 'users',
    fieldsSchema: FIELDS_SCHEMA,
    match: {
        fields: FILTER_FIELDS,
    },
    find: {
        queryFields: FILTER_FIELDS,
    },
    list: {
        filterFields: FILTER_FIELDS,
    },
    fieldFallbacks: {
        fullName: [
            {
                $concat: {
                    values: [{ $var: 'firstName' }, { $var: 'lastName' }],
                    delimiter: ' ',
                },
            },
        ],
        firstName: [
            {
                $firstName: {
                    $var: 'fullName',
                },
            },
        ],
        lastName: [
            {
                $lastName: {
                    $var: 'fullName',
                },
            },
        ],
        primaryEmail: [
            {
                $var: 'emails[0].value',
            },
        ],
        emails: [
            [
                {
                    value: { $var: 'primaryEmail' },
                },
            ],
        ],
        primaryPhone: [
            {
                $var: 'phones[0].value',
            },
        ],
        phones: [
            [
                {
                    value: { $var: 'primaryPhone' },
                },
            ],
        ],
        primaryAddress: [
            {
                $var: 'addresses[0]',
            },
        ],
        addresses: [
            [
                {
                    value: { $var: 'primaryAddress' },
                },
            ],
        ],
        'primaryAddress.full': [
            {
                $concat: {
                    values: [
                        { $var: 'primaryAddress.street' },
                        { $var: 'primaryAddress.city' },
                        { $var: 'primaryAddress.state' },
                        { $var: 'primaryAddress.zip' },
                        { $var: 'primaryAddress.country' },
                    ],
                    delimiter: ', ',
                },
            },
        ],
    },
};

exports.UDM = void 0;
(function (UDM) {
    UDM["ACTIVITIES"] = "activities";
    UDM["BILLS"] = "bills";
    UDM["CAMPAIGN_MEMBERS"] = "campaign-members";
    UDM["CAMPAIGNS"] = "campaigns";
    UDM["COMPANIES"] = "companies";
    UDM["CONTACTS"] = "contacts";
    UDM["CONTACT_LISTS"] = "contact-lists";
    UDM["CREDIT_NOTES"] = "credit-notes";
    UDM["CUSTOMERS"] = "customers";
    UDM["DEAL_PRODUCTS"] = "deal-products";
    UDM["DEALS"] = "deals";
    UDM["DEAL_STAGES"] = "deal-stages";
    UDM["DOCUMENTS"] = "documents";
    UDM["DRIVES"] = "drives";
    UDM["DRIVE_ITEMS"] = "drive-items";
    UDM["EEOCS"] = "eeocs";
    UDM["EMAILS"] = "emails";
    UDM["EMPLOYEES"] = "employees";
    UDM["FILES"] = "files";
    UDM["FOLDERS"] = "folders";
    UDM["INVOICES"] = "invoices";
    UDM["JOB_APPLICATIONS"] = "job-applications";
    UDM["JOB_CANDIDATES"] = "job-candidates";
    UDM["JOB_INTERVIEWS"] = "job-interviews";
    UDM["JOB_OFFERS"] = "job-offers";
    UDM["JOBS"] = "jobs";
    UDM["JOURNAL_ENTRIES"] = "journal-entries";
    UDM["LEADS"] = "leads";
    UDM["LEDGER_ACCOUNTS"] = "ledger-accounts";
    UDM["MEETINGS"] = "meetings";
    UDM["MESSAGES"] = "messages";
    UDM["NOTES"] = "notes";
    UDM["ORDERS"] = "orders";
    UDM["PAYMENTS"] = "payments";
    UDM["PAYROLLS"] = "payrolls";
    UDM["PRODUCTS"] = "products";
    UDM["PROJECTS"] = "projects";
    UDM["SUPPLIERS"] = "suppliers";
    UDM["TASKS"] = "tasks";
    UDM["TAX_RATES"] = "tax-rates";
    UDM["USERS"] = "users";
    UDM["TIMEOFF_BALANCES"] = "timeoff-balances";
    UDM["TIMEOFF_REQUESTS"] = "timeoff-requests";
})(exports.UDM || (exports.UDM = {}));
const UNIFIED_DATA_MODELS = {
    [exports.UDM.ACTIVITIES]: udm$G,
    [exports.UDM.BILLS]: udm$F,
    [exports.UDM.CAMPAIGN_MEMBERS]: udm$E,
    [exports.UDM.CAMPAIGNS]: udm$D,
    [exports.UDM.COMPANIES]: udm$C,
    [exports.UDM.CONTACTS]: udm$A,
    [exports.UDM.CONTACT_LISTS]: udm$B,
    [exports.UDM.CREDIT_NOTES]: udm$z,
    [exports.UDM.CUSTOMERS]: udm$y,
    [exports.UDM.DEAL_PRODUCTS]: udm$x,
    [exports.UDM.DEALS]: udm$v,
    [exports.UDM.DEAL_STAGES]: udm$w,
    [exports.UDM.DOCUMENTS]: udm$u,
    [exports.UDM.DRIVES]: udm$s,
    [exports.UDM.DRIVE_ITEMS]: udm$t,
    [exports.UDM.EEOCS]: udm$r,
    [exports.UDM.EMAILS]: udm$q,
    [exports.UDM.EMPLOYEES]: udm$p,
    [exports.UDM.FILES]: udm$o,
    [exports.UDM.FOLDERS]: udm$n,
    [exports.UDM.INVOICES]: udm$m,
    [exports.UDM.JOB_APPLICATIONS]: udm$l,
    [exports.UDM.JOB_CANDIDATES]: udm$k,
    [exports.UDM.JOB_INTERVIEWS]: udm$j,
    [exports.UDM.JOB_OFFERS]: udm$i,
    [exports.UDM.JOBS]: udm$h,
    [exports.UDM.JOURNAL_ENTRIES]: udm$g,
    [exports.UDM.LEADS]: udm$f,
    [exports.UDM.LEDGER_ACCOUNTS]: udm$e,
    [exports.UDM.MEETINGS]: udm$d,
    [exports.UDM.MESSAGES]: udm$c,
    [exports.UDM.NOTES]: udm$b,
    [exports.UDM.ORDERS]: udm$a,
    [exports.UDM.PAYMENTS]: udm$9,
    [exports.UDM.PAYROLLS]: udm$8,
    [exports.UDM.PRODUCTS]: udm$7,
    [exports.UDM.PROJECTS]: udm$6,
    [exports.UDM.SUPPLIERS]: udm$5,
    [exports.UDM.TASKS]: udm$4,
    [exports.UDM.TAX_RATES]: udm$3,
    [exports.UDM.USERS]: udm,
    [exports.UDM.TIMEOFF_BALANCES]: udm$2,
    [exports.UDM.TIMEOFF_REQUESTS]: udm$1,
};
function findUdmRootLocation(spec, udm, useFallback = true) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    if (!spec) {
        return undefined;
    }
    if (!udm) {
        return ((_c = parseDataLocationPath((_b = (_a = spec.data) === null || _a === void 0 ? void 0 : _a.rootLocation) === null || _b === void 0 ? void 0 : _b.path)) !== null && _c !== void 0 ? _c : parseDataLocationPath((_e = (_d = spec.data) === null || _d === void 0 ? void 0 : _d.root) === null || _e === void 0 ? void 0 : _e.path));
    }
    const udmSpec = UNIFIED_DATA_MODELS[udm];
    if (!udmSpec) {
        throw new BadRequestError(`Unknown UDM: ${udm}`);
    }
    if ((_g = (_f = spec.udm) === null || _f === void 0 ? void 0 : _f[udm]) === null || _g === void 0 ? void 0 : _g.rootDirectory) {
        return (_j = (_h = spec.udm) === null || _h === void 0 ? void 0 : _h[udm]) === null || _j === void 0 ? void 0 : _j.rootDirectory;
    }
    else if ((_l = (_k = spec === null || spec === void 0 ? void 0 : spec.data) === null || _k === void 0 ? void 0 : _k.udm) === null || _l === void 0 ? void 0 : _l[udm]) {
        if (spec.data.udm[udm].rootLocation) {
            return parseDataLocationPath(spec.data.udm[udm].rootLocation.path);
        }
    }
    else if ((_m = spec.data) === null || _m === void 0 ? void 0 : _m[udm]) {
        return parseDataLocationPath((_o = spec.data[udm]) === null || _o === void 0 ? void 0 : _o.path);
    }
    if (useFallback) {
        for (const fallback of (_p = udmSpec.udmFallbacks) !== null && _p !== void 0 ? _p : []) {
            const pointer = findUdmRootLocation(spec, fallback.udm, false);
            if (pointer) {
                return pointer;
            }
        }
    }
    return ((_s = parseDataLocationPath((_r = (_q = spec.data) === null || _q === void 0 ? void 0 : _q.rootLocation) === null || _r === void 0 ? void 0 : _r.path)) !== null && _s !== void 0 ? _s : parseDataLocationPath((_u = (_t = spec.data) === null || _t === void 0 ? void 0 : _t.root) === null || _u === void 0 ? void 0 : _u.path));
}
function findUdmDefaultCollection(spec, udm, useFallback = true) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (!spec || !udm) {
        return undefined;
    }
    if ((_b = (_a = spec.udm) === null || _a === void 0 ? void 0 : _a[udm]) === null || _b === void 0 ? void 0 : _b.defaultCollection) {
        return (_d = (_c = spec.udm) === null || _c === void 0 ? void 0 : _c[udm]) === null || _d === void 0 ? void 0 : _d.defaultCollection;
    }
    if ((_h = (_g = (_f = (_e = spec.udm) === null || _e === void 0 ? void 0 : _e[udm]) === null || _f === void 0 ? void 0 : _f.collectionMappings) === null || _g === void 0 ? void 0 : _g[0]) === null || _h === void 0 ? void 0 : _h.key) {
        return {
            key: spec.udm[udm].collectionMappings[0].key,
        };
    }
    const udmSpec = UNIFIED_DATA_MODELS[udm];
    if (!udmSpec) {
        throw new BadRequestError(`Unknown UDM: ${udm}`);
    }
    if (useFallback) {
        for (const fallback of (_j = udmSpec.udmFallbacks) !== null && _j !== void 0 ? _j : []) {
            const pointer = findUdmDefaultCollection(spec, fallback.udm, false);
            if (pointer) {
                return pointer;
            }
        }
    }
    return undefined;
}
function addUdmFallbackFields(fields, udm) {
    if (!udm) {
        return fields;
    }
    const udmSpec = UNIFIED_DATA_MODELS[udm];
    if (!udmSpec) {
        throw new BadRequestError(`Unknown UDM: ${udm}`);
    }
    if (!udmSpec.fieldFallbacks) {
        return fields;
    }
    let result = structuredClone(fields);
    for (const fieldKeyWithFallbacks of Object.keys(udmSpec.fieldFallbacks)) {
        const currentValue = getValueAtLocator(fields, fieldKeyWithFallbacks);
        if (currentValue !== undefined)
            continue;
        for (const fallbackValue of udmSpec.fieldFallbacks[fieldKeyWithFallbacks]) {
            const varFormulaLocators = getVariableLocators(fallbackValue);
            const varLocators = [];
            for (const varFormulaLocator of varFormulaLocators) {
                const formula = getFormula(getValueAtLocator(fallbackValue, varFormulaLocator));
                varLocators.push(formula.locator);
            }
            const fallbackValueHasDependencies = varLocators.some((locator) => getValueAtLocator(fields, locator) !== undefined);
            if (fallbackValueHasDependencies) {
                result = setValueAtLocator(result, fieldKeyWithFallbacks, transformVars(fallbackValue, fields));
                break;
            }
        }
    }
    return result;
}

const DATA_RECORD_SCHEMA = {
    type: 'object',
    properties: {
        id: {
            type: 'string',
        },
        name: {
            type: 'string',
        },
        uri: {
            type: 'string',
            format: 'url',
        },
        createdTime: {
            type: 'string',
            format: 'datetime',
        },
        updatedTime: {
            type: 'string',
            format: 'datetime',
        },
        deletedTime: {
            type: 'string',
            format: 'datetime',
        },
        createdById: {
            type: 'string',
        },
        updatedById: {
            type: 'string',
        },
    },
};
function makeDataRecordSchema({ fieldsSchema, udm, rawFieldsSchema, }) {
    var _a, _b, _c;
    const schema = structuredClone(DATA_RECORD_SCHEMA);
    schema.properties = {
        ...((_a = schema.properties) !== null && _a !== void 0 ? _a : {}),
        fields: fieldsSchema !== null && fieldsSchema !== void 0 ? fieldsSchema : { type: 'object' },
    };
    if (udm) {
        const unifiedModel = UNIFIED_DATA_MODELS[udm];
        if (unifiedModel === null || unifiedModel === void 0 ? void 0 : unifiedModel.fieldsSchema) {
            schema.properties = {
                ...((_b = schema.properties) !== null && _b !== void 0 ? _b : {}),
                unifiedFields: unifiedModel.fieldsSchema,
            };
        }
    }
    if (rawFieldsSchema) {
        schema.properties = {
            ...((_c = schema.properties) !== null && _c !== void 0 ? _c : {}),
            rawFields: rawFieldsSchema,
        };
    }
    return schema;
}

const DataLocationMethodImplementationTypes = [
    exports.ConnectorMethodImplementationType.operationMapping,
    exports.ConnectorMethodImplementationType.restApiMapping,
    exports.ConnectorMethodImplementationType.graphqlApiMapping,
    exports.ConnectorMethodImplementationType.javascript,
    exports.ConnectorMethodImplementationType.notSupported,
];

const DataCollectionMethodCreate = {
    name: 'Create',
    description: 'Create a new data record in the collection',
    getConfigSchema: ({ collectionSpec }) => {
        var _a, _b;
        const fields = Object.keys((_b = (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : {}).map(locatorToField);
        return {
            type: 'object',
            properties: {
                fields: {
                    type: 'array',
                    items: { type: 'string', enum: fields },
                },
                excludedFields: {
                    type: 'array',
                    items: { type: 'string', enum: fields },
                },
            },
        };
    },
    getInputSchema: ({ collectionSpec, method, connectorSpec }) => {
        var _a, _b;
        let fieldsSchema = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema;
        if (method === null || method === void 0 ? void 0 : method.fields) {
            fieldsSchema = pickFieldsFromSchema(fieldsSchema, method.fields);
        }
        if (method === null || method === void 0 ? void 0 : method.excludedFields) {
            fieldsSchema = excludeFieldsFromSchema(fieldsSchema, method.excludedFields);
        }
        return {
            type: 'object',
            properties: {
                fields: (_a = transformVariablesWith(fieldsSchema, (locator) => `fields.${locatorToField(locator)}`)) !== null && _a !== void 0 ? _a : { type: 'object' },
                credentials: (_b = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _b === void 0 ? void 0 : _b.credentialsSchema,
            },
        };
    },
    getOutputSchema: ({}) => ({
        type: 'object',
        properties: {
            id: { type: 'string' },
        },
    }),
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const DataCollectionMethodDelete = {
    name: 'Delete',
    description: 'Delete a data record from the collection by id',
    getInputSchema: ({ collectionHandler, parameters, connectorSpec }) => {
        var _a;
        return {
            type: 'object',
            properties: {
                id: {
                    type: 'string',
                    referenceCollection: { key: collectionHandler === null || collectionHandler === void 0 ? void 0 : collectionHandler.key, parameters },
                },
                credentials: (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema,
            },
        };
    },
    getOutputSchema: () => null,
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const DataCollectionMethodFind = {
    isDeprecated: true,
    name: 'Find',
    description: 'Find a list of data records in the collection',
    getConfigSchema: ({ collectionSpec }) => {
        var _a, _b;
        const fields = Object.keys((_b = (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : {}).map(locatorToField);
        return {
            type: 'object',
            properties: {
                queryFields: {
                    type: 'array',
                    items: { type: 'string', enum: fields },
                },
            },
        };
    },
    getInputSchema: ({ collectionSpec, method, connectorSpec }) => {
        var _a;
        const queryFieldsSchema = pickFieldsFromSchema(collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema, method === null || method === void 0 ? void 0 : method.queryFields);
        const schema = {
            type: 'object',
            properties: {
                cursor: { type: 'string' },
                credentials: (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema,
            },
        };
        if (queryFieldsSchema === null || queryFieldsSchema === void 0 ? void 0 : queryFieldsSchema.properties) {
            schema.properties = {
                ...schema.properties,
                query: transformVariablesWith(queryFieldsSchema, (locator) => `query.${locatorToField(locator)}`),
            };
        }
        return schema;
    },
    getOutputSchema: ({ collectionSpec }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                records: {
                    type: 'array',
                    items: (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
                },
                cursor: {
                    type: 'string',
                },
            },
        });
    },
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const DataCollectionMethodFindById = {
    name: 'Find by ID',
    description: 'Find a single data record in the collection by its id',
    getInputSchema: ({ collectionHandler, parameters, connectorSpec }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                id: {
                    type: 'string',
                    referenceCollection: { key: collectionHandler === null || collectionHandler === void 0 ? void 0 : collectionHandler.key, parameters },
                },
                credentials: (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema,
            },
        });
    },
    getOutputSchema: ({ collectionSpec }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                record: (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
            },
        });
    },
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const DataCollectionMethodList = {
    name: 'List',
    description: 'Return all data records from the collection',
    getConfigSchema: ({ collectionSpec }) => {
        var _a, _b;
        const fields = Object.keys((_b = (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : {}).map(locatorToField);
        return {
            type: 'object',
            properties: {
                filterFields: {
                    type: 'array',
                    items: { type: 'string', enum: fields },
                },
            },
        };
    },
    getInputSchema: ({ method, collectionSpec, connectorSpec }) => {
        var _a;
        const fieldsSchema = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema;
        let filterSchema;
        if (method === null || method === void 0 ? void 0 : method.filterFields) {
            filterSchema = pickFieldsFromSchema(fieldsSchema, method.filterFields);
        }
        return {
            type: 'object',
            properties: nonEmptyObjectProperties({
                filter: filterSchema,
                cursor: {
                    type: 'string',
                    description: 'Cursor returned in response to the previous "list" request',
                },
                credentials: (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema,
            }),
        };
    },
    getOutputSchema: ({ collectionSpec }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                records: {
                    type: 'array',
                    items: (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
                },
                cursor: {
                    type: 'string',
                    description: 'Cursor to request the next page of results',
                },
            },
        });
    },
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const DataCollectionMethodMatch = {
    name: 'Match',
    description: 'Find a single matching record in a data collection by a set of fields',
    getConfigSchema: ({ collectionSpec }) => {
        var _a, _b;
        const fields = Object.keys((_b = (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : {}).map(locatorToField);
        return {
            type: 'object',
            properties: {
                fields: {
                    type: 'array',
                    items: { type: 'string', enum: fields },
                },
            },
        };
    },
    getInputSchema: ({ collectionSpec, method, connectorSpec }) => {
        var _a;
        const fieldsSchema = pickFieldsFromSchema(collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema, method === null || method === void 0 ? void 0 : method.fields);
        return {
            type: 'object',
            properties: {
                query: transformVariablesWith(fieldsSchema !== null && fieldsSchema !== void 0 ? fieldsSchema : {}, (locator) => `query.${locatorToField(locator)}`),
                credentials: (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema,
            },
        };
    },
    getOutputSchema: ({ collectionSpec }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                record: (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
            },
        });
    },
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const DataCollectionMethodSearch = {
    name: 'Search',
    description: 'Find data records in a collection by a string query',
    getInputSchema: ({ connectorSpec }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                query: { type: 'string' },
                cursor: { type: 'string' },
                credentials: (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.credentialsSchema,
            },
        });
    },
    getOutputSchema: ({ collectionSpec }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                records: {
                    type: 'array',
                    items: (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
                },
                cursor: { type: 'string' },
            },
        });
    },
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const DataCollectionMethodUpdate = {
    name: 'Update',
    description: 'Update one data record in the collection by its id',
    getConfigSchema: ({ collectionSpec }) => {
        var _a, _b;
        const fields = Object.keys((_b = (_a = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : {}).map(locatorToField);
        return {
            type: 'object',
            properties: {
                fields: {
                    type: 'array',
                    items: { type: 'string', enum: fields },
                },
                excludedFields: {
                    type: 'array',
                    items: { type: 'string', enum: fields },
                },
            },
        };
    },
    getInputSchema: ({ collectionSpec, collectionHandler, connectorSpec, method, parameters, }) => {
        var _a, _b;
        let fieldsSchema = collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema;
        if (method === null || method === void 0 ? void 0 : method.fields) {
            fieldsSchema = pickFieldsFromSchema(fieldsSchema, method.fields);
        }
        if (method === null || method === void 0 ? void 0 : method.excludedFields) {
            fieldsSchema = excludeFieldsFromSchema(fieldsSchema, method.excludedFields);
        }
        return {
            type: 'object',
            properties: {
                id: {
                    type: 'string',
                    referenceCollection: { key: collectionHandler === null || collectionHandler === void 0 ? void 0 : collectionHandler.key, parameters },
                },
                fields: (_a = transformVariablesWith(fieldsSchema, (locator) => `fields.${locatorToField(locator)}`)) !== null && _a !== void 0 ? _a : { type: 'object' },
                credentials: (_b = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _b === void 0 ? void 0 : _b.credentialsSchema,
            },
        };
    },
    getOutputSchema: ({}) => ({
        type: 'object',
        properties: {
            id: { type: 'string' },
        },
    }),
    supportedImplementationTypes: DataLocationMethodImplementationTypes,
};

const GetEventConfig = {
    fileKey: 'connector-event-get-event-config',
    getInputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            parameters: collection.parametersSchema,
        },
    }),
    getOutputSchema: ({}) => ({
        type: 'object',
        properties: {
            eventKey: {
                type: 'string',
            },
            eventParameters: {
                type: 'object',
                additionalProperties: true,
            },
        },
    }),
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.mapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const ExtractEventsMethod = {
    fileKey: 'connector-event-extract-events',
    getInputSchema: ({}) => ({
        type: 'object',
        properties: {
            events: {
                type: 'array',
            },
        },
    }),
    getOutputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            events: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        record: collection.fieldsSchema,
                    },
                },
            },
        },
    }),
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.mapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const ConnectorEventImplementationType = {
    methods: {
        getEventConfig: GetEventConfig,
        extractEvents: ExtractEventsMethod,
    },
};

const SubscribeMethod = {
    fileKey: 'custom-pull-subscribe',
    getInputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            parameters: collection.parametersSchema,
        },
    }),
    getOutputSchema: ({}) => ({}),
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const CollectEventsMethod = {
    fileKey: 'custom-pull-collect-events',
    getInputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            parameters: collection.parametersSchema,
        },
    }),
    getOutputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            events: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        record: collection.fieldsSchema,
                    },
                },
            },
            state: {},
        },
    }),
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const CustomPullEventImplementationType = {
    methods: {
        subscribe: SubscribeMethod,
        collectEvents: CollectEventsMethod,
    },
};

const FullScanEventImplementationType = {
    methods: {},
};

const PullLatestRecordsMethod = {
    fileKey: 'pull-latest-records',
    getInputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            parameters: collection.parametersSchema,
            cursor: { type: 'string' },
        },
    }),
    getOutputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            records: {
                type: 'array',
                items: collection.fieldsSchema,
            },
            cursor: {
                type: 'string',
            },
        },
    }),
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.restApiMapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const PullLatestRecordsEventImplementationType = {
    methods: {
        pullLatestRecords: PullLatestRecordsMethod,
    },
};

exports.DataCollectionEventType = void 0;
(function (DataCollectionEventType) {
    DataCollectionEventType["CREATED"] = "created";
    DataCollectionEventType["UPDATED"] = "updated";
    DataCollectionEventType["DELETED"] = "deleted";
})(exports.DataCollectionEventType || (exports.DataCollectionEventType = {}));

const WebhookSubscribeMethod = {
    fileKey: 'webhook-subscribe',
    getInputSchema: ({ collection }) => ({
        type: 'object',
        properties: {
            parameters: collection.parametersSchema,
            webhookUri: { type: 'string' },
        },
    }),
    getOutputSchema: ({ event }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                state: (_a = event.stateSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
                nextRefreshTimestamp: { type: 'number' },
            },
            required: ['state'],
        });
    },
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.restApiMapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const WebhookUnsubscribeMethod = {
    fileKey: 'webhook-unsubscribe',
    getInputSchema: ({ collection, event }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                parameters: collection.parametersSchema,
                state: (_a = event.stateSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
            },
        });
    },
    getOutputSchema: () => null,
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.restApiMapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const WebhookHandleMethod = {
    fileKey: 'webhook-handle',
    getInputSchema: ({ collection, event }) => ({
        type: 'object',
        properties: {
            query: event.querySchema,
            data: event.dataSchema,
            parameters: collection.parametersSchema,
            state: event.stateSchema,
        },
    }),
    getOutputSchema: ({ collection, event }) => {
        var _a, _b;
        return ({
            type: 'object',
            properties: {
                events: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            type: {
                                type: 'string',
                                enum: Object.values(exports.DataCollectionEventType),
                            },
                            record: (_a = collection.fieldsSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
                        },
                    },
                },
                response: {
                    type: 'object',
                    properties: {
                        headers: {
                            type: 'object',
                        },
                        data: {},
                    },
                },
                state: (_b = event.stateSchema) !== null && _b !== void 0 ? _b : { type: 'object' },
            },
        });
    },
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.mapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const WebhookRefreshMethod = {
    fileKey: 'webhook-refresh',
    getInputSchema: ({ collection, event }) => ({
        type: 'object',
        properties: {
            parameters: collection.parametersSchema,
            state: event.stateSchema,
        },
    }),
    getOutputSchema: ({ event }) => {
        var _a;
        return ({
            type: 'object',
            properties: {
                state: (_a = event.stateSchema) !== null && _a !== void 0 ? _a : { type: 'object' },
                nextRefreshTimestamp: { type: 'number' },
            },
        });
    },
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.restApiMapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const WebhookEventImplementationType = {
    methods: {
        subscribe: WebhookSubscribeMethod,
        unsubscribe: WebhookUnsubscribeMethod,
        handle: WebhookHandleMethod,
        refresh: WebhookRefreshMethod,
    },
};

const ConnectorDataCollectionEventImplementationType = {
    webhook: WebhookEventImplementationType,
    'pull-latest-records': PullLatestRecordsEventImplementationType,
    'custom-pull': CustomPullEventImplementationType,
    'connector-event': ConnectorEventImplementationType,
    'full-scan': FullScanEventImplementationType,
};
function getEventMethodFileKey(eventType, eventImplementationType, methodKey) {
    const methodType = ConnectorDataCollectionEventImplementationType[eventImplementationType]
        .methods[methodKey];
    if (!methodType) {
        return undefined;
    }
    return `events-${eventType}-${methodType.fileKey}`;
}
function getAllEventMethodFilePaths(eventType, eventImplementationType, methodKey) {
    return [
        eventType === 'all'
            ? undefined
            : getEventMethodFileKey(eventType, eventImplementationType, methodKey),
        getLegacyEventMethodFielPath(eventType, eventImplementationType, methodKey),
    ].filter(Boolean);
}
function getLegacyEventMethodFielPath(eventType, eventImplementationType, methodKey) {
    const prefix = eventType === 'all' ? 'events' : eventType;
    switch (eventImplementationType) {
        case 'webhook':
            switch (methodKey) {
                case 'handle':
                    return `${prefix}-webhook-handle`;
                case 'subscribe':
                    return `${prefix}-webhook-subscribe`;
                case 'unsubscribe':
                    return `${prefix}-webhook-unsubscribe`;
                default:
                    return null;
            }
        case 'pull-latest-records':
            switch (methodKey) {
                case 'pullLatestRecords':
                    return `${prefix}-pull-latest-records`;
                default:
                    return null;
            }
        case 'custom-pull':
            switch (methodKey) {
                case 'subscribe':
                    return `${prefix}-custom-pull-subscribe`;
                case 'collectEvents':
                    return `${prefix}-custom-pull-collect-events`;
                default:
                    return null;
            }
        default:
            return null;
    }
}

const DataCollectionCustomSpecMethod = {
    supportedImplementationTypes: [exports.ConnectorMethodImplementationType.javascript],
};
const DataCollectionCustomFieldsSchemaMethod = {
    fileKey: 'custom-fields-schema',
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const DataCollectionRecordFromApiMethod = {
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.mapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const DataCollectionRecordFromFieldsMethod = {
    getInputSchema: ({ collectionSpec }) => ({
        type: 'object',
        properties: {
            fields: collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema,
            parameters: collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.parametersSchema,
        },
    }),
    getOutputSchema: () => DATA_RECORD_SCHEMA,
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.mapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const DataCollectionRecordFromApiMappingMethod = {
    fileKey: 'record-from-api',
    supportedImplementationTypes: [exports.ConnectorMethodImplementationType.mapping],
};
const DataCollectionRecordFromApiCodeMethod = {
    fileKey: 'record-from-api',
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const DataCollectionFieldsToApiMappingMethod = {
    fileKey: 'fields-to-api',
    supportedImplementationTypes: [exports.ConnectorMethodImplementationType.mapping],
};
const DataCollectionFieldsToApiCodeMethod = {
    fileKey: 'fields-to-api',
    supportedImplementationTypes: [exports.ConnectorMethodImplementationType.javascript],
};
const DataCollectionFieldsFromApiMethod = {
    name: 'Fields From API',
    description: 'Transform fields coming from API into fieldsSchema',
    getInputSchema: () => {
        return {
            type: 'object',
            properties: {
                fields: {
                    type: 'object',
                    additionalProperties: true,
                },
            },
        };
    },
    getOutputSchema: ({ collectionSpec }) => collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema,
    supportedImplementationTypes: [exports.ConnectorMethodImplementationType.javascript],
};
const DataCollectionFieldsToApiMethod = {
    name: 'Fields To API',
    description: "Transform fieldsSchema into format accepted by the application's API",
    getInputSchema: ({ collectionSpec }) => ({
        type: 'object',
        properties: {
            fields: collectionSpec === null || collectionSpec === void 0 ? void 0 : collectionSpec.fieldsSchema,
        },
    }),
    getOutputSchema: () => {
        return {
            type: 'object',
            additionalProperties: true,
        };
    },
    supportedImplementationTypes: [exports.ConnectorMethodImplementationType.javascript],
};
const DataCollectionRecordToApiMethod = {
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.mapping,
        exports.ConnectorMethodImplementationType.javascript,
    ],
};
const DataLocationTypeCollection = {
    spec: DataCollectionCustomSpecMethod,
    recordFromFields: DataCollectionRecordFromFieldsMethod,
    customFieldsSchema: DataCollectionCustomFieldsSchemaMethod,
    fieldsFromApi: DataCollectionFieldsFromApiMethod,
    fieldsToApi: DataCollectionFieldsToApiMethod,
    methods: {
        list: DataCollectionMethodList,
        findById: DataCollectionMethodFindById,
        match: DataCollectionMethodMatch,
        search: DataCollectionMethodSearch,
        create: DataCollectionMethodCreate,
        update: DataCollectionMethodUpdate,
        delete: DataCollectionMethodDelete,
        find: DataCollectionMethodFind,
    },
    recordToApi: DataCollectionRecordToApiMethod,
    recordFromApi: DataCollectionRecordFromApiMethod,
    recordFromApiMapping: DataCollectionRecordFromApiMappingMethod,
    recordFromApiCode: DataCollectionRecordFromApiCodeMethod,
    fieldsToApiMapping: DataCollectionFieldsToApiMappingMethod,
    fieldsToApiCode: DataCollectionFieldsToApiCodeMethod,
};
const ConnectorDataCollectionMethodKeys = Object.keys(DataLocationTypeCollection.methods);

const DataDirectoryMethodList = {
    name: 'List',
    description: 'List collections and directories inside this directory',
    getInputSchema: ({ directory }) => ({
        type: 'object',
        properties: {
            parameters: directory.parametersSchema,
            cursor: { type: 'string' },
        },
    }),
    getOutputSchema: () => ({
        type: 'object',
        properties: {
            locations: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        key: { type: 'string' },
                        path: { type: 'string' },
                        type: {
                            type: 'string',
                            enum: Object.keys(ConnectorDataLocationTypes),
                        },
                    },
                },
            },
        },
    }),
    supportedImplementationTypes: [
        exports.ConnectorMethodImplementationType.mapping,
        ...DataLocationMethodImplementationTypes,
    ],
};

const DataDirectoryCustomSpecMethod = {
    supportedImplementationTypes: [exports.ConnectorMethodImplementationType.javascript],
};
const DataLocationTypeDirectory = {
    spec: DataDirectoryCustomSpecMethod,
    methods: {
        list: DataDirectoryMethodList,
    },
};
const ConnectorDataDirectoryMethodKeys = Object.keys(DataLocationTypeDirectory.methods);

exports.DataLocationType = void 0;
(function (DataLocationType) {
    DataLocationType["directory"] = "directory";
    DataLocationType["collection"] = "collection";
})(exports.DataLocationType || (exports.DataLocationType = {}));
exports.DataDirectoryOperation = void 0;
(function (DataDirectoryOperation) {
    DataDirectoryOperation["list"] = "list";
})(exports.DataDirectoryOperation || (exports.DataDirectoryOperation = {}));
const ConnectorDataLocationTypes = {
    collection: DataLocationTypeCollection,
    directory: DataLocationTypeDirectory,
};

function getDataLocationMethodPath(locationKey, methodKey) {
    return `data/${locationKey}/${jsConvertCase.toKebabCase(methodKey)}`;
}
function dataLocationParametersMatch({ locationParameters, targetParameters, }) {
    targetParameters =
        typeof targetParameters === 'object' && targetParameters
            ? targetParameters
            : {};
    locationParameters =
        typeof locationParameters === 'object' && locationParameters
            ? locationParameters
            : {};
    for (const [key, value] of Object.entries(targetParameters)) {
        if (locationParameters[key] !== value) {
            return false;
        }
    }
    return true;
}
function parseDataLocationPath(path) {
    if (!path) {
        return undefined;
    }
    if (path.startsWith('/')) {
        path = path.slice(1);
    }
    if (!path.startsWith('data/')) {
        throw new Error(`Invalid data location path: ${path}. It should start with "data/"`);
    }
    path = path.slice(5);
    const [key, query] = path.split('?');
    const parameters = Object.fromEntries(new URLSearchParams(query).entries());
    return { key, parameters };
}
function makeDataLocationPath(pointer) {
    var _a;
    const normalizedPointer = normalizePointer(pointer);
    if (normalizedPointer === null || normalizedPointer === void 0 ? void 0 : normalizedPointer.key) {
        let path = `/data/${normalizedPointer.key}`;
        const parameters = omitBy((_a = normalizedPointer.parameters) !== null && _a !== void 0 ? _a : {}, isNil);
        if (Object.keys(parameters).length > 0) {
            path += `?${new URLSearchParams(parameters).toString()}`;
        }
        return path;
    }
    else {
        return undefined;
    }
}
function normalizePointer(pointer) {
    if (typeof pointer === 'string' && pointer.startsWith('/data/')) {
        return {
            key: pointer.slice(6),
        };
    }
    return pointer;
}
function makeDataLocationOperationPath(collectionPath, operation) {
    const [path, query] = (collectionPath !== null && collectionPath !== void 0 ? collectionPath : '').split('?');
    return urljoin(path, operation, query ? `?${query}` : '');
}
function isSameDataLocation(location1, location2) {
    if (location1.key !== location2.key) {
        return false;
    }
    const cleanParameters1 = location1.parameters && Object.keys(location1.parameters).length > 0
        ? location1.parameters
        : undefined;
    const cleanParameters2 = location2.parameters && Object.keys(location2.parameters).length > 0
        ? location2.parameters
        : undefined;
    if (!deepEqual(cleanParameters1, cleanParameters2)) {
        return false;
    }
    return true;
}
function isDataLocationMethodSupported(location, methodKey) {
    var _a;
    const method = (_a = location === null || location === void 0 ? void 0 : location.methods) === null || _a === void 0 ? void 0 : _a[methodKey];
    return (method &&
        method.implementationType !== exports.ConnectorMethodImplementationType.notSupported);
}
function getDataCollectionCreateFields(spec) {
    if (!spec)
        return undefined;
    if (!spec.fieldsSchema)
        return undefined;
    if (!spec.create)
        return undefined;
    let schema = excludeReadOnlyFieldsFromSchema(spec.fieldsSchema);
    if (spec.create.fields) {
        schema = pickFieldsFromSchema(schema, spec.create.fields);
    }
    if (spec.create.excludedFields) {
        schema = excludeFieldsFromSchema(schema, spec.create.excludedFields);
    }
    return schema;
}
function getDataCollectionUpdateFields(spec) {
    if (!spec)
        return undefined;
    if (!spec.fieldsSchema)
        return undefined;
    if (!spec.update)
        return undefined;
    let schema = excludeReadOnlyFieldsFromSchema(spec.fieldsSchema);
    if (spec.update.fields) {
        schema = pickFieldsFromSchema(schema, spec.update.fields);
    }
    if (spec.update.excludedFields) {
        schema = excludeFieldsFromSchema(schema, spec.update.excludedFields);
    }
    return schema;
}
function getWritableFieldsSchema(spec) {
    if (!spec)
        return undefined;
    if (!spec.fieldsSchema)
        return undefined;
    return mergeSchemas([
        getDataCollectionCreateFields(spec),
        getDataCollectionUpdateFields(spec),
    ]);
}

const ConnectorOperationMethodImplementationTypes = [
    exports.ConnectorMethodImplementationType.restApiMapping,
    exports.ConnectorMethodImplementationType.javascript,
];

const CONNECTOR_CATEGORIES = [
    'Accounting',
    'Ads',
    'Analytics',
    'ATS',
    'Communication',
    'CRM',
    'Customer Success',
    'Document Management',
    'E-Commerce',
    'E-Signature',
    'ERP',
    'File Storage',
    'HRIS',
    'Legal',
    'Marketing Automation',
    'Payments',
    'Project Management',
    'Sales',
    'Ticketing',
];
exports.ConnectorStatus = void 0;
(function (ConnectorStatus) {
    ConnectorStatus["production"] = "production";
    ConnectorStatus["beta"] = "beta";
    ConnectorStatus["planned"] = "planned";
})(exports.ConnectorStatus || (exports.ConnectorStatus = {}));

function findUdmCollectionMapping(udm, collectionKey, parameters) {
    if (!Array.isArray(udm === null || udm === void 0 ? void 0 : udm.collectionMappings)) {
        return undefined;
    }
    return udm.collectionMappings.find((mapping) => mapping.key === collectionKey &&
        dataLocationParametersMatch({
            targetParameters: mapping.parameters,
            locationParameters: parameters,
        }));
}

exports.ConnectorEventImplementationType = void 0;
(function (ConnectorEventImplementationType) {
    ConnectorEventImplementationType["GlobalWebhook"] = "global-webhook";
    ConnectorEventImplementationType["Webhook"] = "webhook";
})(exports.ConnectorEventImplementationType || (exports.ConnectorEventImplementationType = {}));
const ConnectorEventHandlerMethods = {
    [exports.ConnectorEventImplementationType.GlobalWebhook]: {
        getEventSelector: {
            supportedImplementationTypes: [
                exports.ConnectorMethodImplementationType.mapping,
                exports.ConnectorMethodImplementationType.javascript,
            ],
            isRequired: true,
        },
    },
    [exports.ConnectorEventImplementationType.Webhook]: {
        subscribe: {
            supportedImplementationTypes: [
                exports.ConnectorMethodImplementationType.restApiMapping,
                exports.ConnectorMethodImplementationType.javascript,
            ],
            isRequired: true,
        },
        unsubscribe: {
            supportedImplementationTypes: [
                exports.ConnectorMethodImplementationType.restApiMapping,
                exports.ConnectorMethodImplementationType.javascript,
            ],
            isRequired: true,
        },
        handle: {
            supportedImplementationTypes: [
                exports.ConnectorMethodImplementationType.mapping,
                exports.ConnectorMethodImplementationType.javascript,
            ],
            isRequired: true,
        },
        refresh: {
            supportedImplementationTypes: [
                exports.ConnectorMethodImplementationType.restApiMapping,
                exports.ConnectorMethodImplementationType.javascript,
            ],
            isRequired: false,
        },
    },
};

function buildDataSchema(value, variablesSchema) {
    return getSchemaFromValue(value, variablesSchema);
}
function updateImpliedSchema({ schema: sourceSchema, value, variablesSchema, }) {
    let resultSchema = sourceSchema
        ? JSON.parse(JSON.stringify(sourceSchema))
        : undefined;
    resultSchema = walkSchema(resultSchema, (schema) => schema.isImplied ? undefined : schema);
    const schemaFromValue = getSchemaFromValue(value, variablesSchema);
    walkSchema(schemaFromValue, (schema, locator) => {
        const existingSchema = getSchemaByLocator(resultSchema, locator);
        if (existingSchema) {
            if ((existingSchema === null || existingSchema === void 0 ? void 0 : existingSchema.type) !== schema.type) {
                throw new StopWalkError();
            }
        }
        else {
            const impliedSchema = walkSchema(schema, (schema) => {
                delete schema.readOnly;
                delete schema.title;
                return {
                    ...schema,
                    isImplied: true,
                };
            });
            resultSchema = setSchemaAtLocator(resultSchema, locator, impliedSchema);
        }
        return schema;
    });
    return resultSchema;
}
function schemaHasProperties(schema) {
    var _a;
    if (!schema) {
        return false;
    }
    if ((schema === null || schema === void 0 ? void 0 : schema.type) !== 'object') {
        return false;
    }
    if (Object.keys((_a = schema === null || schema === void 0 ? void 0 : schema.properties) !== null && _a !== void 0 ? _a : {}).length > 0) {
        return true;
    }
    return false;
}
function nonEmptyObjectProperties(properties) {
    if (!properties) {
        return {};
    }
    const result = {};
    for (const [key, value] of Object.entries(properties)) {
        if (value) {
            result[key] = value;
        }
    }
    return result;
}
function getSchemaFromValue(value, variablesSchema, ignoreFormulas = false) {
    if (isFormula(value) && !ignoreFormulas) {
        return getFormula(value).getSchema(variablesSchema);
    }
    else {
        const type = schemaTypeFromValue(value);
        switch (type) {
            case 'object':
                const properties = {};
                for (const [propKey, propValue] of Object.entries(value)) {
                    properties[propKey] = getSchemaFromValue(propValue, variablesSchema, ignoreFormulas);
                }
                return {
                    type: 'object',
                    properties,
                };
            case 'array':
                const schemas = [];
                for (const item of value) {
                    schemas.push(getSchemaFromValue(item, variablesSchema, ignoreFormulas));
                }
                return {
                    type: 'array',
                    items: mergeSchemas(schemas),
                };
            case undefined:
                return undefined;
            default:
                return { type: type };
        }
    }
}
function schemaTypeFromValue(value) {
    switch (typeof value) {
        case 'object':
            if (Array.isArray(value)) {
                return 'array';
            }
            else if (value === null) {
                return undefined;
            }
            else {
                return 'object';
            }
        case 'boolean':
            return 'boolean';
        case 'bigint':
        case 'number':
            return 'number';
        case 'undefined':
            return undefined;
        default:
            return 'string';
    }
}
function valueToSchema(value, schema, options, field = '') {
    var _a;
    if (!schema)
        return value;
    if ((value === null || value === undefined) &&
        (schema === null || schema === void 0 ? void 0 : schema.default) !== undefined &&
        (options === null || options === void 0 ? void 0 : options.addDefaults)) {
        value = schema.default;
    }
    if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'object') {
        return valueToObject();
    }
    else if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'array') {
        if (Array.isArray(value)) {
            const hasItems = value.length > 0;
            const newValue = [];
            for (const item of value) {
                const newItem = valueToSchema(item, schema.items, options, field);
                if (item === undefined || newItem !== undefined) {
                    newValue.push(newItem);
                }
            }
            if (hasItems && newValue.length === 0) {
                return undefined;
            }
            return newValue;
        }
        else {
            return value;
        }
    }
    else {
        if (options === null || options === void 0 ? void 0 : options.normalizeValues) {
            switch (schema === null || schema === void 0 ? void 0 : schema.type) {
                case 'string':
                    return (_a = value === null || value === void 0 ? void 0 : value.toString()) !== null && _a !== void 0 ? _a : value;
                case 'integer':
                case 'number':
                    return valueToNumber();
                case 'boolean':
                    return valueToBoolean();
                default:
                    return value;
            }
        }
        else {
            return value;
        }
    }
    function valueToNumber() {
        if (value === null || value === undefined || typeof value === 'object')
            return value;
        const result = Number(value);
        if (isNaN(result)) {
            return value;
        }
        if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'integer' && !Number.isInteger(result)) {
            return value;
        }
        return result;
    }
    function valueToBoolean() {
        if (value === null || value === undefined) {
            return value;
        }
        if (typeof value === 'boolean') {
            return value;
        }
        else if (typeof value === 'string') {
            if (value === 'true') {
                return true;
            }
            else if (value === 'false') {
                return false;
            }
            else {
                return value;
            }
        }
        else {
            return value;
        }
    }
    function valueToObject() {
        var _a;
        if ((options === null || options === void 0 ? void 0 : options.valueHasFormulas) && isFormula(value)) {
            return value;
        }
        const result = {};
        const properties = schema === null || schema === void 0 ? void 0 : schema.properties;
        if (properties) {
            for (const [key, propertySchema] of Object.entries(properties)) {
                if ((propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.readOnly) && (options === null || options === void 0 ? void 0 : options.skipReadOnlyFields))
                    continue;
                const propertyValue = valueToSchema(value === null || value === void 0 ? void 0 : value[key], propertySchema, options, field ? `${field}.${key}` : key);
                const propertyWasUndefined = ((_a = value === null || value === void 0 ? void 0 : value.hasOwnProperty) === null || _a === void 0 ? void 0 : _a.call(value, key)) && value[key] === undefined;
                if (propertyWasUndefined || propertyValue !== undefined) {
                    result[key] = propertyValue;
                }
            }
        }
        if (Object.keys(result).length === 0) {
            if (typeof value !== 'object' || Array.isArray(value) || !value)
                return value;
        }
        for (const [key, fieldValue] of Object.entries(value !== null && value !== void 0 ? value : {})) {
            if (properties === null || properties === void 0 ? void 0 : properties[key])
                continue;
            if ((options === null || options === void 0 ? void 0 : options.skipUnknownFields) && !(schema === null || schema === void 0 ? void 0 : schema.additionalProperties))
                continue;
            result[key] = fieldValue;
        }
        const valueHasKeys = typeof value === 'object' && value && Object.keys(value).length > 0;
        const resultHasKeys = typeof result === 'object' && result && Object.keys(result).length > 0;
        if (valueHasKeys && !resultHasKeys) {
            return undefined;
        }
        return result;
    }
}
function schemaIsScalar(schema) {
    if (!schema || typeof schema !== 'object') {
        return false;
    }
    return (schema.type != 'array' && schema.type != 'object' && schema.type != 'null');
}
function schemaHasFixedValues(schema) {
    if (!schema) {
        return false;
    }
    return !!(schema.enum ||
        schema.referenceRecords ||
        schema.referenceCollection ||
        schema.type === 'boolean');
}
function schemaAllowsCustomValue(schema) {
    return !schemaHasFixedValues(schema) || schema.allowCustom;
}
function schemaIsNumber(schema) {
    return schema && (schema.type === 'number' || schema.type === 'integer');
}
function schemaWithTitle(schema, title) {
    return typeof schema === 'object'
        ? {
            ...schema,
            title,
        }
        : schema;
}
function pickFieldsFromSchema(schema, fields) {
    const result = {
        type: 'object',
        properties: {},
    };
    if (!Array.isArray(fields)) {
        return result;
    }
    if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'object' && (schema === null || schema === void 0 ? void 0 : schema.properties)) {
        for (const field of fields) {
            const fieldSchema = getSchemaByLocator(schema, field);
            if (fieldSchema) {
                setSchemaAtLocator(result, field, getSchemaByLocator(schema, field));
            }
        }
        if (schema.required) {
            const normalizedFields = fields.map(locatorToField);
            result.required = schema.required.filter((field) => normalizedFields.includes(field));
        }
    }
    return result;
}
function excludeReadOnlyFieldsFromSchema(schema) {
    var _a;
    if (!schema) {
        return schema;
    }
    let result = JSON.parse(JSON.stringify(schema));
    if (result.type === 'object') {
        const properties = {};
        for (const [key, propertySchema] of Object.entries((_a = result.properties) !== null && _a !== void 0 ? _a : {})) {
            if (!(propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.readOnly)) {
                properties[key] = excludeReadOnlyFieldsFromSchema(propertySchema);
            }
        }
        result = {
            ...result,
            properties,
        };
    }
    else if (result.type === 'array') {
        result.items = excludeReadOnlyFieldsFromSchema(result.items);
    }
    return result;
}
function excludeWriteOnlyFieldsFromSchema(schema) {
    var _a;
    if (!schema) {
        return schema;
    }
    let result = JSON.parse(JSON.stringify(schema));
    if (schema.type === 'object') {
        const properties = {};
        for (const [key, propertySchema] of Object.entries((_a = schema.properties) !== null && _a !== void 0 ? _a : {})) {
            if (!propertySchema.writeOnly) {
                properties[key] = excludeWriteOnlyFieldsFromSchema(propertySchema);
            }
        }
        result = {
            ...result,
            properties,
        };
    }
    else if (schema.type === 'array') {
        result.items = excludeWriteOnlyFieldsFromSchema(schema.items);
    }
    return result;
}
function excludeFieldsFromSchema(schema, fields) {
    if (!schema) {
        return schema;
    }
    if (!Array.isArray(fields)) {
        return schema;
    }
    let result = JSON.parse(JSON.stringify(schema));
    for (const field of fields !== null && fields !== void 0 ? fields : []) {
        if (field) {
            result = setSchemaAtLocator(result, field, undefined);
        }
    }
    return result;
}
function getRequiredFieldsFromSchema(schema) {
    var _a, _b;
    if (!schema) {
        return [];
    }
    if (schema.type === 'object') {
        const requiredFields = [...((_a = schema.required) !== null && _a !== void 0 ? _a : [])];
        for (const [key, propertySchema] of Object.entries((_b = schema.properties) !== null && _b !== void 0 ? _b : {})) {
            requiredFields.push(...getRequiredFieldsFromSchema(propertySchema).map((field) => `${key}.${field}`));
        }
        return requiredFields;
    }
    else {
        return [];
    }
}
function addRequiredFieldsToSchema(schema, fields) {
    if (!schema) {
        return undefined;
    }
    if (!Array.isArray(fields)) {
        return schema;
    }
    const newSchema = JSON.parse(JSON.stringify(schema));
    for (const field of fields) {
        if (!isValidLocator(field)) {
            continue;
        }
        const steps = locatorToSteps(field);
        const lastStep = steps.pop();
        if (lastStep.type === exports.DataLocatorStepType.OBJECT_PROPERTY) {
            const objectLocator = stepsToLocator(steps);
            const objectSchema = getSchemaByLocator(newSchema, objectLocator);
            if (objectSchema) {
                objectSchema.required = [
                    ...(objectSchema.required || []),
                    lastStep.propertyName,
                ];
                setSchemaAtLocator(newSchema, objectLocator, objectSchema);
            }
        }
    }
    return newSchema;
}
function removeRequiredFieldsFromSchema(schema) {
    var _a;
    if (!schema)
        return schema;
    const newSchema = JSON.parse(JSON.stringify(schema));
    if (newSchema.type === 'object') {
        delete newSchema.required;
        for (const [key, propertySchema] of Object.entries((_a = newSchema.properties) !== null && _a !== void 0 ? _a : {})) {
            setSchemaAtLocator(newSchema, key, removeRequiredFieldsFromSchema(propertySchema));
        }
    }
    return newSchema;
}
function getMissingRequiredFields(schema, value) {
    if (!schema) {
        return [];
    }
    const requiredFields = getRequiredFieldsFromSchema(schema);
    const missingFields = [];
    for (const field of requiredFields) {
        if (getValueByLocator(value, field) === undefined) {
            missingFields.push(field);
        }
    }
    return missingFields;
}
function populateSchemaTitles(schema) {
    var _a;
    if (!schema) {
        return schema;
    }
    if (schema.type === 'object') {
        for (const field of Object.keys((_a = schema.properties) !== null && _a !== void 0 ? _a : {})) {
            const fieldSchema = getSchemaByLocator(schema, field);
            if (fieldSchema && !fieldSchema.title) {
                fieldSchema.title = getNameForLocator(schema, field);
                setSchemaAtLocator(schema, field, populateSchemaTitles(fieldSchema));
            }
        }
    }
    else if (schema.type === 'array') {
        if (schema.items) {
            schema.items = populateSchemaTitles(schema.items);
        }
    }
    return schema;
}
function generateExampleFromSchema(schema) {
    var _a;
    if (!schema || typeof schema !== 'object') {
        return undefined;
    }
    switch (schema.type) {
        case 'array':
            return schema.items ? [generateExampleFromSchema(schema.items)] : [];
        case 'object':
            const result = {};
            for (const [key, propertySchema] of Object.entries((_a = schema.properties) !== null && _a !== void 0 ? _a : {})) {
                result[key] = generateExampleFromSchema(propertySchema);
            }
            return result;
        default:
            return '';
    }
}
function isSchemaEmpty(schema) {
    if (!schema || typeof schema !== 'object' || !schema.type) {
        return true;
    }
    const isObject = schema.type === 'object';
    if (!isObject) {
        return false;
    }
    return !(schema.properties && Object.keys(schema.properties).length > 0);
}
function compressDataSchema(schema) {
    var _a, _b, _c;
    if (!schema || typeof schema !== 'object') {
        return schema;
    }
    if (schema.type === 'object') {
        const result = {
            type: 'object',
            properties: {},
        };
        for (const [key, propertySchema] of Object.entries((_a = schema.properties) !== null && _a !== void 0 ? _a : {})) {
            const compressedSchema = compressDataSchema(propertySchema);
            if (compressedSchema) {
                result.properties[key] = compressedSchema;
            }
        }
        return result;
    }
    else if (schema.type === 'array') {
        return {
            type: 'array',
            items: compressDataSchema(schema.items),
        };
    }
    else {
        return {
            type: schema.type,
            title: schema.title,
            description: schema.description
                ? `${(_b = schema.description) === null || _b === void 0 ? void 0 : _b.substring(0, 300)}${((_c = schema.description) === null || _c === void 0 ? void 0 : _c.length) > 50 ? '...' : ''}`
                : undefined,
        };
    }
}
function getReferenceCollectionPointerForSchema(schema) {
    if (schema === null || schema === void 0 ? void 0 : schema.referenceCollection) {
        return schema.referenceCollection;
    }
    else if (schema === null || schema === void 0 ? void 0 : schema.referenceCollectionPath) {
        return parseDataLocationPath(schema.referenceCollectionPath);
    }
    else if (schema === null || schema === void 0 ? void 0 : schema.referenceCollectionUri) {
        return parseDataLocationPath(schema.referenceCollectionUri);
    }
    else {
        return undefined;
    }
}
function getReferenceCollectionPathForSchema(schema) {
    const pointer = getReferenceCollectionPointerForSchema(schema);
    return makeDataLocationPath(pointer);
}
function walkSchema(schema, callback, locator = '$') {
    if (!schema) {
        return undefined;
    }
    let result = schema;
    try {
        result = callback(result, locator);
        if (!result) {
            return undefined;
        }
        if (result.type === 'object') {
            if (result.properties) {
                for (const [propertyKey, propertySchema] of Object.entries(result.properties)) {
                    try {
                        const propertyResult = walkSchema(propertySchema, callback, makeObjectPropertyLocator(locator, propertyKey));
                        if (propertyResult) {
                            result.properties[propertyKey] = propertyResult;
                        }
                        else {
                            delete result.properties[propertyKey];
                        }
                    }
                    catch (e) {
                        if (e instanceof StopWalkError) {
                            continue;
                        }
                        else {
                            throw e;
                        }
                    }
                }
            }
        }
        else if (result.type === 'array') {
            if (result.items) {
                result.items = walkSchema(schema.items, callback, `${locator}[0]`);
            }
        }
        return result;
    }
    catch (e) {
        if (e instanceof StopWalkError) {
            return result;
        }
        else {
            throw e;
        }
    }
}
class StopWalkError extends Error {
}

const OPERATORS = {
    is: {
        name: 'is',
        handler: (value, operand) => value == operand,
        applicableToSchema: (schema) => schemaIsScalar(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => schema,
    },
    is_not: {
        name: 'is not',
        handler: (value, operand) => value != operand,
        applicableToSchema: (schema) => schemaIsScalar(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => schema,
    },
    is_one_of: {
        name: 'is one of',
        handler: (value, operand) => Array.isArray(operand) && operand.includes(value),
        applicableToSchema: (schema) => schemaIsScalar(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => ({ type: 'array', items: schema }),
    },
    is_not_one_of: {
        name: 'is not one of',
        handler: (value, operand) => !Array.isArray(operand) || !operand.includes(value),
        applicableToSchema: (schema) => schemaIsScalar(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => ({ type: 'array', items: schema }),
    },
    is_true: {
        name: 'is true',
        handler: (value) => !!value,
        applicableToSchema: (schema) => schema.type === 'boolean',
        getOperandSchema: () => null,
    },
    is_false: {
        name: 'is false',
        handler: (value) => value === false,
        applicableToSchema: (schema) => schema.type === 'boolean',
        getOperandSchema: () => null,
    },
    contains: {
        name: 'contains',
        handler: (value, operand) => value ? value.toString().includes(operand) : false,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'string' && schemaAllowsCustomValue(schema),
        getOperandSchema: () => ({ type: 'string' }),
    },
    does_not_contain: {
        name: 'does not contain',
        handler: (value, operand) => value ? !value.toString().includes(operand) : false,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'string' && schemaAllowsCustomValue(schema),
        getOperandSchema: () => ({ type: 'string' }),
    },
    array_includes: {
        name: 'includes',
        handler: (value, operand) => Array.isArray(value) && value.indexOf(operand) !== -1,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' && schema.items,
        getOperandSchema: (schema) => schema.items,
    },
    array_does_not_include: {
        name: 'does not include',
        handler: (value, operand) => !Array.isArray(value) || value.indexOf(operand) === -1,
        applicableToSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' && schema.items,
        getOperandSchema: (schema) => schema.items,
    },
    less_than: {
        name: 'less than',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) < parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    less_than_or_equal: {
        name: 'less than or equal',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) <= parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    more_than: {
        name: 'more than',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) > parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    more_than_or_equal: {
        name: 'more than or equal',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) >= parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    is_not_empty: {
        name: 'is not empty',
        handler: (value) => {
            if (Array.isArray(value)) {
                return value.length > 0;
            }
            else if (typeof value === 'object') {
                return value !== null && Object.keys(value).length > 0;
            }
            else {
                return value !== undefined && value !== '';
            }
        },
        applicableToSchema: () => true,
        getOperandSchema: () => null,
    },
    is_empty: {
        name: 'is empty',
        handler: (value) => {
            if (Array.isArray(value)) {
                return value.length === 0;
            }
            else if (typeof value === 'object') {
                return value === null || Object.keys(value).length === 0;
            }
            else {
                return value === undefined || value === '';
            }
        },
        applicableToSchema: () => true,
        getOperandSchema: () => null,
    },
};

function backwardCompatibleFilterMatch(filter, variables) {
    var _a;
    if (Array.isArray(filter)) {
        return doesMatchFilter(variables, filter);
    }
    else {
        return (_a = buildData(filter, variables)) !== null && _a !== void 0 ? _a : true;
    }
}
function doesMatchFilter(data, filter) {
    if (filter && Array.isArray(filter)) {
        for (const condition of filter) {
            const operator = OPERATORS[condition.operator];
            if (!operator) {
                continue;
            }
            let fieldValues = getFilterFieldValuesByLocator(data, condition.field);
            if (!(fieldValues === null || fieldValues === void 0 ? void 0 : fieldValues.length)) {
                fieldValues = [undefined];
            }
            const conditionMatches = fieldValues.some((fieldValue) => operator.handler(fieldValue, condition.value));
            if (!conditionMatches) {
                return false;
            }
        }
        return true;
    }
    else {
        return true;
    }
}
class DataFilterCondition {
    constructor(field, operator, value) {
        this.field = field;
        this.operator = operator;
        this.value = value;
    }
}
function getOperatorsBySchema(schema) {
    if (!schema || typeof schema !== 'object') {
        return [];
    }
    const results = [];
    for (const [type, operator] of Object.entries(OPERATORS)) {
        if (operator.applicableToSchema(schema)) {
            results.push({
                type,
                name: operator.name,
                operandSchema: operator.getOperandSchema(schema),
            });
        }
    }
    return results;
}
function getFilterFieldValuesByLocator(data, locator) {
    const locatorSteps = locatorToSteps(locator);
    const result = [];
    let curValue = data;
    for (let idx = 0; idx < locatorSteps.length; ++idx) {
        if (curValue === null || curValue === undefined) {
            return [];
        }
        const locatorStep = locatorSteps[idx];
        switch (locatorStep.type) {
            case exports.DataLocatorStepType.ARRAY_ITEM:
                if (Array.isArray(curValue)) {
                    curValue = curValue[locatorStep.index];
                    break;
                }
                else {
                    return [];
                }
            case exports.DataLocatorStepType.OBJECT_PROPERTY:
                if (Array.isArray(curValue)) {
                    for (const val of curValue) {
                        result.push(...getFilterFieldValuesByLocator(val, locatorSteps.slice(idx)));
                    }
                    return result;
                }
                else {
                    curValue =
                        curValue[locatorStep.propertyName];
                    break;
                }
        }
    }
    if (curValue !== null && curValue !== undefined) {
        result.push(curValue);
    }
    return result;
}

class DataBuilderFormulaCase extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.CASE, value);
        if (!value && !Array.isArray(value) && typeof value !== 'object') {
            this.value = {
                cases: [],
                default: undefined,
            };
        }
        else if (Array.isArray(value)) {
            this.value = {
                cases: value,
                default: undefined,
            };
        }
        else if (typeof value === 'object' && Array.isArray(value === null || value === void 0 ? void 0 : value.cases)) {
            this.value = value;
        }
    }
    getValue(variables) {
        var _a;
        if (!this.isValueValid())
            return undefined;
        for (const item of this.value.cases) {
            if (!item || typeof item !== 'object')
                continue;
            let filterMatched = true;
            if (item.filter) {
                filterMatched = backwardCompatibleFilterMatch(item.filter, variables);
            }
            if (filterMatched) {
                return processValue(item.value, variables);
            }
        }
        return (_a = processValue(this.value.default, variables)) !== null && _a !== void 0 ? _a : undefined;
    }
    getSchema(variablesSchema) {
        if (!this.isValueValid())
            return undefined;
        const schemas = this.value.cases
            .map((item) => item.value)
            .filter((value) => value !== undefined)
            .map((value) => buildDataSchema(value, variablesSchema));
        if (this.value.default) {
            schemas.push(buildDataSchema(this.value.default, variablesSchema));
        }
        return mergeSchemas(schemas);
    }
    isValueValid() {
        var _a;
        return (this.value &&
            typeof this.value === 'object' &&
            Array.isArray((_a = this.value) === null || _a === void 0 ? void 0 : _a.cases));
    }
    transformVars(transformations) {
        const transformedCases = this.value.cases
            .map((item) => transformVars(item, transformations))
            .filter((item) => (item === null || item === void 0 ? void 0 : item.filter) !== undefined);
        const transformedDefault = transformVars(this.value.default, transformations);
        if ((transformedCases === null || transformedCases === void 0 ? void 0 : transformedCases.length) > 0) {
            const result = {
                $case: {
                    cases: transformedCases,
                },
            };
            if (transformedDefault !== undefined) {
                result.$case.default = transformedDefault;
            }
            return result;
        }
        else {
            return transformVars(this.value.default, transformations);
        }
    }
}

const DEFAULT_DELIMITER = '';
class DataBuilderFormulaConcat extends DataBuilderFormulaBase {
    constructor(options) {
        var _a, _b;
        super(exports.DataBuilderFormulaType.CONCAT, options);
        this.options = options;
        this.delimiter = DEFAULT_DELIMITER;
        this.values = [];
        if (!options) {
            return;
        }
        this.values = Array.isArray(options) ? options : ((_a = options === null || options === void 0 ? void 0 : options.values) !== null && _a !== void 0 ? _a : []);
        this.delimiter = (_b = options === null || options === void 0 ? void 0 : options.delimiter) !== null && _b !== void 0 ? _b : DEFAULT_DELIMITER;
    }
    getValue(variables) {
        const processedValues = processValue(this.values, variables);
        if (!Array.isArray(processedValues) || !processedValues.length) {
            return undefined;
        }
        const processedDelimiter = processValue(this.delimiter, variables);
        return processedValues
            .filter((v) => v !== null && v !== undefined && v.toString() !== '')
            .join(processedDelimiter);
    }
    getSchema() {
        return { type: 'string' };
    }
    toString(variablesSchema) {
        const valueStrings = this.values.map((value) => valueToString(value, variablesSchema));
        if (valueStrings.length) {
            return `Concatenate(${valueStrings.join(', ')})`;
        }
        else {
            return `Concatenate()`;
        }
    }
}

class DataBuilderFormulaCopy extends DataBuilderFormulaBase {
    constructor(locator) {
        super(exports.DataBuilderFormulaType.COPY, locator);
        this.locator = locator;
    }
    getValue(variables) {
        return {
            $copy: processValue(this.locator, variables),
        };
    }
    getSchema() {
        return null;
    }
}

class DomainFromEmail extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.DOMAIN_FROM_EMAIL, value);
        this.value = value;
    }
    getValue(variables) {
        const value = processValue(this.value, variables);
        if (typeof value !== 'string') {
            return undefined;
        }
        const emailParts = value.split('@');
        if (emailParts.length !== 2) {
            return undefined;
        }
        return emailParts[1];
    }
    getSchema() {
        return { type: 'string' };
    }
}

class Eval extends DataBuilderFormulaBase {
    constructor(args, formulaValue) {
        super(exports.DataBuilderFormulaType.EVAL, args);
        this.value = args;
        const keys = Object.keys(formulaValue);
        this.operatorKey = keys[1];
        this.operand = formulaValue[this.operatorKey];
    }
    getAvailableOperators(variablesSchema) {
        const operators = [];
        const valueSchema = getSchemaFromValue(this.value, variablesSchema);
        for (const key in OPERATOR_SPECS) {
            const operatorSpec = OPERATOR_SPECS[key];
            if (operatorSpec.applicableToSchema(valueSchema)) {
                const operandSchema = operatorSpec.getOperandSchema(valueSchema);
                operators.push({
                    key,
                    name: operatorSpec.name,
                    operandSchema: operandSchema,
                    hasOperand: !!operandSchema,
                });
            }
        }
        return operators;
    }
    getOperator(variablesSchema) {
        const valueSchema = getSchemaFromValue(this.value, variablesSchema);
        const operatorSpec = OPERATOR_SPECS[this.operatorKey];
        if (operatorSpec) {
            const operandSchema = operatorSpec.getOperandSchema(valueSchema);
            return {
                key: this.operatorKey,
                name: operatorSpec.name,
                operandSchema: operandSchema,
                hasOperand: !!operandSchema,
            };
        }
        else {
            return null;
        }
    }
    getValue(variables) {
        const value = processValue(this.value, variables);
        const operatorSpec = OPERATOR_SPECS[this.operatorKey];
        if (operatorSpec) {
            const operand = processValue(this.operand, variables);
            return operatorSpec.handler(value, operand);
        }
        else {
            return true;
        }
    }
    getSchema() {
        return { type: 'boolean' };
    }
    toObject() {
        const object = {
            $eval: this.value,
        };
        if (this.operatorKey) {
            object[this.operatorKey] = this.operand;
        }
        return object;
    }
    transformVars(transformations) {
        const transformedValue = processValue(this.value, transformations);
        if (transformedValue !== undefined) {
            const transformedOperand = processValue(this.operand, transformations);
            return {
                $eval: transformedValue,
                [this.operatorKey]: transformedOperand,
            };
        }
        else {
            return undefined;
        }
    }
}
const OPERATOR_SPECS = {
    is: {
        name: 'is',
        handler: (value, operand) => value == operand,
        applicableToSchema: (schema) => schemaIsScalar(schema),
        getOperandSchema: (schema) => schema,
    },
    isNot: {
        name: 'is not',
        handler: (value, operand) => value != operand,
        applicableToSchema: (schema) => schemaIsScalar(schema),
        getOperandSchema: (schema) => schema,
    },
    oneOf: {
        name: 'is one of',
        handler: (value, operand) => Array.isArray(operand) && operand.includes(value),
        applicableToSchema: (schema) => schemaIsScalar(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => ({ type: 'array', items: schema }),
    },
    noneOf: {
        name: 'is not one of',
        handler: (value, operand) => !Array.isArray(operand) || !operand.includes(value),
        applicableToSchema: (schema) => schemaIsScalar(schema) && schema.type !== 'boolean',
        getOperandSchema: (schema) => ({ type: 'array', items: schema }),
    },
    contains: {
        name: 'contains',
        handler: (value, operand) => {
            var _a;
            return value
                ? Array.isArray(value)
                    ? value.includes(operand)
                    : value
                        .toString()
                        .toLowerCase()
                        .includes((_a = operand === null || operand === void 0 ? void 0 : operand.toString()) === null || _a === void 0 ? void 0 : _a.toLowerCase())
                : false;
        },
        applicableToSchema: (schema) => ((schema === null || schema === void 0 ? void 0 : schema.type) === 'string' && schemaAllowsCustomValue(schema)) ||
            (schema === null || schema === void 0 ? void 0 : schema.type) === 'array',
        getOperandSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' ? schema.items : { type: 'string' },
    },
    doesNotContain: {
        name: 'does not contain',
        handler: (value, operand) => {
            var _a;
            return value
                ? Array.isArray(value)
                    ? !value.includes(operand)
                    : !value
                        .toString()
                        .toLowerCase()
                        .includes((_a = operand === null || operand === void 0 ? void 0 : operand.toString()) === null || _a === void 0 ? void 0 : _a.toLowerCase())
                : true;
        },
        applicableToSchema: (schema) => ((schema === null || schema === void 0 ? void 0 : schema.type) === 'string' && schemaAllowsCustomValue(schema)) ||
            (schema === null || schema === void 0 ? void 0 : schema.type) === 'array',
        getOperandSchema: (schema) => (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' ? schema.items : { type: 'string' },
    },
    lt: {
        name: 'less than',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) < parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    lte: {
        name: 'less than or equal',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) <= parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    gt: {
        name: 'more than',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) > parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    gte: {
        name: 'more than or equal',
        handler: (value, operand) => {
            return isNaN(parseFloat(value)) || isNaN(parseFloat(operand))
                ? false
                : parseFloat(value) >= parseFloat(operand);
        },
        applicableToSchema: (schema) => schemaIsNumber(schema),
        getOperandSchema: () => ({ type: 'number' }),
    },
    isNotEmpty: {
        name: 'is not empty',
        handler: (value) => {
            if (Array.isArray(value)) {
                return value.length > 0;
            }
            else if (typeof value === 'object') {
                return value !== null && Object.keys(value).length > 0;
            }
            else {
                return value !== undefined && value !== '';
            }
        },
        applicableToSchema: () => true,
        getOperandSchema: () => null,
    },
    isEmpty: {
        name: 'is empty',
        handler: (value) => {
            if (Array.isArray(value)) {
                return value.length === 0;
            }
            else if (typeof value === 'object') {
                return value === null || Object.keys(value).length === 0;
            }
            else {
                return value === undefined || value === '';
            }
        },
        applicableToSchema: () => true,
        getOperandSchema: () => null,
    },
};

function parseDatetime(str) {
    if (typeof process !== 'undefined') {
        process.env.TZ = 'UTC';
    }
    const timestamp = Date.parse(str);
    if (!isNaN(timestamp)) {
        return new Date(timestamp);
    }
    else {
        return null;
    }
}

class DataBuilderFormulaExtractDate extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.EXTRACT_DATE, value);
        this.value = value;
    }
    getValue(variables) {
        const value = processValue(this.value, variables);
        const date = parseDatetime(value);
        if (date) {
            return date.toISOString().substring(0, 10);
        }
        else {
            return undefined;
        }
    }
    getSchema() {
        return {
            type: 'string',
            format: 'date',
        };
    }
}

class DataBuilderFormulaExtractTime extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.EXTRACT_TIME, value);
        this.value = value;
    }
    getValue(variables) {
        const value = processValue(this.value, variables);
        const date = parseDatetime(value);
        if (date) {
            return date.toISOString().substring(11, 19);
        }
        else {
            return undefined;
        }
    }
    getSchema() {
        return {
            type: 'string',
            format: 'time',
        };
    }
}

class DataBuilderFormulaFindAppRecordId extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.FIND_APP_RECORD_ID, args);
        this.args = args;
    }
    getValue(variables) {
        return {
            $findAppRecordId: processValue(this.args, variables),
        };
    }
    getSchema() {
        return {
            type: 'string',
        };
    }
}

class DataBuilderFormulaFindExternalRecordId extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.FIND_EXTERNAL_RECORD_ID, args);
        this.args = args;
    }
    getValue(variables) {
        return {
            $findExternalRecordId: processValue(this.args, variables),
        };
    }
    getSchema() {
        return {
            type: 'string',
        };
    }
}

class DataBuilderFormulaFirstName extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.FIRST_NAME, value);
        this.value = value;
    }
    getValue(variables) {
        var _a;
        const value = processValue(this.value, variables);
        const { firstName, lastName } = humanparser.parseName((_a = value === null || value === void 0 ? void 0 : value.toString()) !== null && _a !== void 0 ? _a : '');
        if (lastName) {
            return firstName;
        }
        else {
            return undefined;
        }
    }
    getSchema() {
        return { type: 'string' };
    }
}

class FirstNotEmpty extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.FIRST_NOT_EMPTY, args);
    }
    getValue(variables) {
        const values = processValue(this.args, variables);
        if (!Array.isArray(values)) {
            return undefined;
        }
        for (const value of values) {
            if (value !== undefined && value !== null) {
                return value;
            }
        }
        return undefined;
    }
    getSchema(variablesSchema) {
        if (Array.isArray(this.args)) {
            return buildDataSchema(this.args[0], variablesSchema);
        }
        else {
            return undefined;
        }
    }
}

class FormulaFormula extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.FORMULA, args);
    }
    getValue(variables) {
        const varLocators = getVariableLocators(this.args);
        const result = this.args;
        for (const locator of varLocators) {
            const valueAtLocator = processValue(getValueAtLocator(result, locator), variables);
            setValueAtLocator(result, locator, valueAtLocator);
        }
        return result;
    }
    getSchema() {
        return undefined;
    }
    transformVars(transformations) {
        return transformVars(this.args, transformations);
    }
}

class DataBuilderFormulaIterate extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.ITERATE, args);
        this.args = args;
        this.source = args === null || args === void 0 ? void 0 : args.source;
        this.item = args === null || args === void 0 ? void 0 : args.item;
    }
    getValue(variables) {
        const source = processValue(this.source, variables);
        if (!Array.isArray(source)) {
            return undefined;
        }
        const result = [];
        for (let index = 0; index < source.length; index++) {
            const newItem = processValue(this.item, {
                item: source[index],
                parent: variables,
                index,
            });
            if (newItem) {
                result.push(newItem);
            }
        }
        if (result.length > 0) {
            return result;
        }
        else {
            return undefined;
        }
    }
    getSchema(variablesSchema) {
        var _a;
        const itemVariablesSchema = {
            type: 'object',
            properties: {
                parent: variablesSchema,
                item: (_a = buildDataSchema(this.source, variablesSchema)) === null || _a === void 0 ? void 0 : _a.items,
                index: { type: 'number' },
            },
        };
        return {
            type: 'array',
            items: buildDataSchema(this.item, itemVariablesSchema),
        };
    }
    getVariableLocators() {
        const sourceLocators = getVariableLocators(this.source);
        return sourceLocators.map((locator) => `$.$iterate.source${locator.replace(/^\$/, '')}`);
    }
    transformVars(transformations) {
        const source = transformVars(this.source, transformations);
        if (source !== undefined) {
            return {
                $iterate: {
                    ...this.args,
                    source,
                },
            };
        }
        else {
            return undefined;
        }
    }
}

class JsonataFormula extends DataBuilderFormulaBase {
    constructor(expression) {
        super(exports.DataBuilderFormulaType.JSONATA, expression);
        this.expression = expression;
    }
    getValue(variables) {
        if (!this.expression)
            return undefined;
        try {
            const expression = jsonata(processValue(this.expression, variables));
            const value = expression.evaluate(variables);
            return value;
        }
        catch (_e) {
            return undefined;
        }
    }
    getSchema() {
        return getSchemaFromValue(this.getValue(null), null, true);
    }
}

class DataBuilderFormulaLastName extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.LAST_NAME, value);
        this.value = value;
    }
    getValue(variables) {
        var _a;
        const value = processValue(this.value, variables);
        const { firstName, lastName } = humanparser.parseName((_a = value === null || value === void 0 ? void 0 : value.toString()) !== null && _a !== void 0 ? _a : '');
        if (lastName) {
            return lastName;
        }
        if (firstName) {
            return firstName;
        }
        return undefined;
    }
    getSchema() {
        return { type: 'string' };
    }
    toString(variablesSchema) {
        return `ExtractLastName(${valueToString(this.value, variablesSchema)})`;
    }
}

class DataBuilderFormulaLookup extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.LOOKUP, value);
        this.value = value;
    }
    getValue(variables) {
        return {
            $lookup: processValue(this.value, variables),
        };
    }
    getSchema() {
        return {
            type: 'string',
        };
    }
}

class DataBuilderFormulaMap extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.MAP, args);
        this.args = args;
    }
    getValue(variables) {
        if (!this.args || typeof this.args !== 'object') {
            return;
        }
        const value = processValue(this.args.value, variables);
        if (Array.isArray(this.args.mapping)) {
            for (const mappingItem of this.args.mapping) {
                const from = processValue(mappingItem.from, variables);
                if (deepEqual(value, from) || value == from) {
                    return processValue(mappingItem.to, variables);
                }
            }
        }
        return processValue(this.args.default, variables);
    }
    getSchema(variablesSchema) {
        var _a;
        return getSchemaFromValue((_a = this.args) === null || _a === void 0 ? void 0 : _a.value, variablesSchema);
    }
}

class MergeObjects extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.MERGE_OBJECTS, args);
    }
    getValue(variables) {
        const objects = processValue(this.args, variables);
        if (!Array.isArray(objects)) {
            return undefined;
        }
        const result = {};
        for (const object of objects) {
            if (object && typeof object === 'object') {
                Object.assign(result, object);
            }
        }
        return Object.keys(result).length > 0 ? result : undefined;
    }
    getSchema(variablesSchema) {
        if (!Array.isArray(this.args)) {
            return { type: 'object' };
        }
        const schemas = this.args.map((arg) => buildDataSchema(arg, variablesSchema));
        const result = {
            type: 'object',
            properties: {},
        };
        for (const schema of schemas) {
            if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'object') {
                Object.assign(result.properties, schema.properties);
            }
        }
        return result;
    }
}

class Or extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.OR, args);
    }
    getValue(variables) {
        const args = processValue(this.args, variables);
        if (Array.isArray(args) &&
            args.some((arg) => arg !== null && arg !== undefined)) {
            return args.some((arg) => !!arg);
        }
        else {
            return undefined;
        }
    }
    getSchema() {
        return { type: 'boolean' };
    }
}

class DataBuilderFormulaPlain extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.PLAIN, value);
        this.value = value;
    }
    getValue() {
        return this.value;
    }
    getSchema() {
        return getSchemaFromValue(this.value, null, true);
    }
}

class DataBuilderFormulaRecord extends DataBuilderFormulaBase {
    constructor(record) {
        super(exports.DataBuilderFormulaType.RECORD, record);
        this.record = record;
    }
    getValue() {
        var _a;
        return (_a = this.record) === null || _a === void 0 ? void 0 : _a.id;
    }
    getSchema() {
        return {
            type: 'string',
        };
    }
}

class DataBuilderFormulaTpl extends DataBuilderFormulaBase {
    constructor(args) {
        super(exports.DataBuilderFormulaType.TPL, args);
        this.args = args;
    }
    getValue(variables) {
        var _a, _b, _c;
        let result = (_a = this.args) === null || _a === void 0 ? void 0 : _a.template;
        if (typeof result !== 'string') {
            return result;
        }
        for (const key of Object.keys((_c = (_b = this.args) === null || _b === void 0 ? void 0 : _b.values) !== null && _c !== void 0 ? _c : {})) {
            const value = processValue(this.args.values[key], variables);
            result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), value !== null && value !== void 0 ? value : '');
        }
        return result;
    }
    getSchema() {
        return {
            type: 'string',
        };
    }
}

class DataBuilderFormulaVar extends DataBuilderFormulaBase {
    constructor(locator) {
        super(exports.DataBuilderFormulaType.VAR, locator);
        this.locator = locator;
    }
    getValue(variables) {
        if (!isValidLocator(this.locator)) {
            return null;
        }
        return getValueByLocator(variables, locatorToSteps(this.locator));
    }
    getSchema(variablesSchema) {
        return getSchemaByLocator(variablesSchema, this.locator);
    }
    toString(variablesSchema) {
        var _a;
        return (_a = getFullNameForLocator(variablesSchema, this.locator)) !== null && _a !== void 0 ? _a : this.locator;
    }
    getVariableLocators() {
        return ['$'];
    }
    transformVars(transformations) {
        if (!transformations || !isValidLocator(this.locator) || !this.locator) {
            return undefined;
        }
        let curValue = transformations;
        const locatorSteps = locatorToSteps(this.locator);
        while (true) {
            const formula = getFormula(curValue);
            if (formula) {
                const remainingLocator = stepsToLocator(locatorSteps);
                if (formula.type === exports.DataBuilderFormulaType.VAR) {
                    const varFormula = formula;
                    return {
                        $var: `${varFormula.locator}${remainingLocator.replace('$', '')}`,
                    };
                }
                else {
                    return undefined;
                }
            }
            const locatorStep = locatorSteps.shift();
            if (!locatorStep) {
                return curValue;
            }
            switch (locatorStep.type) {
                case exports.DataLocatorStepType.OBJECT_PROPERTY:
                    const propStep = locatorStep;
                    if (typeof curValue == 'object' &&
                        curValue !== null &&
                        curValue !== undefined &&
                        curValue[propStep.propertyName] !== undefined) {
                        curValue = curValue[propStep.propertyName];
                    }
                    else {
                        return undefined;
                    }
                    break;
                case exports.DataLocatorStepType.ARRAY_ITEM:
                    const itemStep = locatorStep;
                    if (Array.isArray(curValue) &&
                        curValue[itemStep.index] !== undefined) {
                        curValue = curValue[itemStep.index];
                    }
                    else {
                        return undefined;
                    }
                    break;
                default:
                    throw new Error(`Unknown locator step type: ${locatorStep.type}`);
            }
            if (locatorSteps.length === 0) {
                return curValue;
            }
        }
    }
}

class DataSchemaRef extends DataBuilderFormulaBase {
    constructor(value) {
        super(exports.DataBuilderFormulaType.DATA_SCHEMA_REF, value);
        this.value = value;
    }
    getValue() {
        return undefined;
    }
    async resolveValue(params) {
        var _a;
        const args = await resolveValue(this.args, params);
        if ((args === null || args === void 0 ? void 0 : args.type) === 'data-collection') {
            return this.resolveDataCollection(args, params);
        }
        else if (((_a = this.args) === null || _a === void 0 ? void 0 : _a.type) === 'internal-data-schema') {
            return this.resolveInternalDataSchema(args, params);
        }
        else {
            return undefined;
        }
    }
    async resolveDataCollection(args, params) {
        if (!params.getDataCollection) {
            return undefined;
        }
        const spec = await params.getDataCollection(args.key, args.parameters);
        return spec.fieldsSchema;
    }
    async resolveInternalDataSchema(args, params) {
        if (!params.getInternalDataSchema) {
            return undefined;
        }
        return params.getInternalDataSchema(args.key);
    }
    getSchema() {
        return {
            type: 'object',
        };
    }
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    And: And,
    Base: DataBuilderFormulaBase,
    Case: DataBuilderFormulaCase,
    Concat: DataBuilderFormulaConcat,
    Copy: DataBuilderFormulaCopy,
    DataSchemaRef: DataSchemaRef,
    DomainFromEmail: DomainFromEmail,
    Eval: Eval,
    ExtractDate: DataBuilderFormulaExtractDate,
    ExtractTime: DataBuilderFormulaExtractTime,
    FindAppRecordId: DataBuilderFormulaFindAppRecordId,
    FindExternalRecordId: DataBuilderFormulaFindExternalRecordId,
    FirstName: DataBuilderFormulaFirstName,
    FirstNotEmpty: FirstNotEmpty,
    Formula: FormulaFormula,
    Iterate: DataBuilderFormulaIterate,
    Jsonata: JsonataFormula,
    LastName: DataBuilderFormulaLastName,
    Lookup: DataBuilderFormulaLookup,
    Map: DataBuilderFormulaMap,
    MergeObjects: MergeObjects,
    Or: Or,
    Plain: DataBuilderFormulaPlain,
    Record: DataBuilderFormulaRecord,
    Tpl: DataBuilderFormulaTpl,
    Var: DataBuilderFormulaVar
});

function mergeWithFormulas(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
        const length = Math.max(a.length, b.length);
        const merged = [];
        for (let i = 0; i < length; i++) {
            merged.push(mergeWithFormulas(a[i], b[i]));
        }
        return merged;
    }
    if (isObject(a) && isObject(b)) {
        if (isFormula(a) || isFormula(b)) {
            return typeof b === 'undefined' ? a : b;
        }
        const merged = { ...a };
        for (const key in b) {
            merged[key] = mergeWithFormulas(a[key], b[key]);
        }
        return merged;
    }
    return typeof b === 'undefined' ? a : b;
}
function isObject(value) {
    return (!!value &&
        typeof value === 'object' &&
        !Array.isArray(value) &&
        !(value instanceof Number) &&
        !(value instanceof String) &&
        !(value instanceof Boolean));
}

exports.FieldMappingDirection = void 0;
(function (FieldMappingDirection) {
    FieldMappingDirection["IMPORT"] = "import";
    FieldMappingDirection["EXPORT"] = "export";
    FieldMappingDirection["BOTH"] = "both";
})(exports.FieldMappingDirection || (exports.FieldMappingDirection = {}));

exports.ActionType = void 0;
(function (ActionType) {
    ActionType["ListDataRecords"] = "list-data-records";
    ActionType["FindDataRecordById"] = "find-data-record-by-id";
    ActionType["MatchDataRecord"] = "match-data-record";
    ActionType["CreateDataRecord"] = "create-data-record";
    ActionType["FindOrCreateDataRecord"] = "find-or-create-data-record";
    ActionType["UpdateDataRecord"] = "update-data-record";
    ActionType["DeleteDataRecord"] = "delete-data-record";
    ActionType["SearchDataRecords"] = "search-data-record";
    ActionType["ConnectorOperation"] = "connector-operation";
    ActionType["ApiRequestToExternalApp"] = "api-request-to-external-app";
    ActionType["ApiRequestToYourApp"] = "api-request-to-your-app";
    ActionType["HttpRequest"] = "http-request";
    ActionType["RunJavascript"] = "run-javascript";
    ActionType["ApiRequest"] = "api-request";
})(exports.ActionType || (exports.ActionType = {}));
function isDataActionType(type) {
    var _a;
    return (_a = ACTIONS[type]) === null || _a === void 0 ? void 0 : _a.isDataAction;
}
const ACTIONS = {
    [exports.ActionType.ListDataRecords]: {
        name: 'List Data Records',
        description: 'Return a list of all the data records in the collection, page by page',
        isDataAction: true,
        direction: exports.FieldMappingDirection.IMPORT,
    },
    [exports.ActionType.FindDataRecordById]: {
        name: 'Find Data Record by ID',
        description: 'Find record in a data collection by ID',
        isDataAction: true,
        direction: exports.FieldMappingDirection.IMPORT,
    },
    [exports.ActionType.MatchDataRecord]: {
        name: 'Match Data Record',
        description: 'Find a matching record in a data collection given its field(s) values',
        isDataAction: true,
        direction: exports.FieldMappingDirection.IMPORT,
    },
    [exports.ActionType.CreateDataRecord]: {
        name: 'Create Data Record',
        description: 'Create a new record in a data collection',
        isDataAction: true,
        direction: exports.FieldMappingDirection.EXPORT,
    },
    [exports.ActionType.FindOrCreateDataRecord]: {
        name: 'Find or Create Data Record',
        description: 'Find record in a data collection or create a new one if it does not exist yet',
        isDataAction: true,
        direction: exports.FieldMappingDirection.EXPORT,
    },
    [exports.ActionType.UpdateDataRecord]: {
        name: 'Update Data Record',
        description: 'Update data record by ID',
        isDataAction: true,
        direction: exports.FieldMappingDirection.EXPORT,
    },
    [exports.ActionType.DeleteDataRecord]: {
        name: 'Delete Data Record',
        description: 'Delete a data record by ID',
        isDataAction: true,
        direction: exports.FieldMappingDirection.EXPORT,
    },
    [exports.ActionType.SearchDataRecords]: {
        name: 'Search Data Records',
        description: 'Search records in a data collection using a text query',
        isDataAction: true,
        direction: exports.FieldMappingDirection.IMPORT,
    },
    [exports.ActionType.ConnectorOperation]: {
        name: 'Connector Operation',
        description: 'Perform a custom operation on a connector',
    },
    [exports.ActionType.ApiRequestToExternalApp]: {
        name: 'API Request to External App',
        description: 'Make an API request to an external app',
    },
    [exports.ActionType.ApiRequestToYourApp]: {
        name: 'API Request to Your App',
        description: 'Make an API request to your app',
    },
    [exports.ActionType.HttpRequest]: {
        name: 'HTTP Request',
        description: 'Make an arbitrary HTTP request to any endpoint',
    },
    [exports.ActionType.RunJavascript]: {
        name: 'Run Javascript',
        description: 'Run custom Javascript code',
    },
    [exports.ActionType.ApiRequest]: {
        name: 'API Request',
        description: 'Make an API request',
        isDeprecated: true,
    },
};

exports.ActionDependencyType = void 0;
(function (ActionDependencyType) {
    ActionDependencyType["FieldMapping"] = "FieldMapping";
    ActionDependencyType["DataSource"] = "DataSource";
})(exports.ActionDependencyType || (exports.ActionDependencyType = {}));

class AppDataSchemasAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'app-data-schemas');
    }
}
class AppDataSchemaAccessor extends ElementAccessor {
    constructor(client, idOrKey) {
        super({
            client,
            path: 'app-data-schema',
            selector: idOrKey,
        });
    }
}
class AppDataSchemaInstancesAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'app-data-schema-instances');
    }
}
class AppDataSchemaInstanceAccessor extends ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            instancePath: 'app-data-schema-instance',
            selector,
        });
        this.client = client;
    }
    async setup() {
        await this.client.post(this.getPath('setup'));
    }
}

class AppEventTypesAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'app-event-types');
    }
}
class AppEventTypeAccessor extends ElementAccessor {
    constructor(client, idOrKey) {
        super({
            client,
            path: 'app-event-type',
            selector: idOrKey,
        });
    }
}
class AppEventSubscriptionsAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'app-event-subscriptions');
    }
}
class AppEventSubscriptionAccessor extends ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            instancePath: 'app-event-subscription',
            selector,
        });
    }
    async subscribe() {
        return this.options.client.post(this.getPath('subscribe'));
    }
}
class AppEventsAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'app-events');
    }
}

class SelfAccessor {
    constructor(client) {
        this.client = client;
    }
    async get() {
        return this.client.get('self');
    }
    async patch(data) {
        return this.client.patch('self', data);
    }
}

var ConnectionType;
(function (ConnectionType) {
    ConnectionType["IFRAME"] = "iframe";
    ConnectionType["POPUP"] = "popup";
    ConnectionType["REDIRECT"] = "redirect";
})(ConnectionType || (ConnectionType = {}));
async function createOrUpdateConnection(options) {
    const { connectionId, integrationId, name, parameters, allowMultipleConnections, authOptionKey, connectorSpec, apiUri, token, redirectUri, } = options !== null && options !== void 0 ? options : {};
    const connectionType = getConnectionType({
        connectorSpec,
        authOptionKey,
        redirectUri,
    });
    const popupPath = connectionId
        ? `connection-popup?connectionId=${connectionId}`
        : `connection-popup?integrationId=${integrationId}`;
    return new Promise((resolve, reject) => {
        const connectionUrl = urljoin(apiUri, popupPath);
        const requestId = (Math.random() + 1).toString(36).substring(0, 12);
        const payload = {
            token,
            connectionParameters: parameters,
            name,
            authOptionKey,
            allowMultipleConnections,
            requestId,
            redirectUri,
        };
        const listenerFunc = async (event) => {
            var _a;
            const message = event.data || {};
            if (message.source == 'integration.app' &&
                (message.requestId == requestId || !message.requestId)) {
                cleanup();
                if (message.type == 'newConnectionCreated') {
                    resolve(message.connection);
                }
                else if (message.type == 'newConnectionCancel') {
                    resolve(undefined);
                }
                else if (message.type == 'newConnectionFailure') {
                    const error = new IntegrationAppError((_a = message.errorData) !== null && _a !== void 0 ? _a : message.error);
                    reject(error);
                }
            }
        };
        let cancelCheckInterval;
        function cleanup() {
            clearInterval(cancelCheckInterval);
            window.removeEventListener('message', listenerFunc);
        }
        const targetElementId = `connection-request-${requestId}`;
        try {
            window.addEventListener('message', listenerFunc);
            const form = document.createElement('form');
            form.method = 'POST';
            form.action = connectionUrl;
            form.target = targetElementId;
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = 'payload';
            input.value = JSON.stringify(payload);
            form.appendChild(input);
            document.body.appendChild(form);
            if (connectionType === ConnectionType.IFRAME) {
                const iframeElement = document.createElement('iframe');
                iframeElement.id = targetElementId;
                iframeElement.name = targetElementId;
                iframeElement.style.position = 'absolute';
                iframeElement.style.top = '-100';
                iframeElement.style.left = '-100';
                iframeElement.style.width = '1';
                iframeElement.style.height = '1';
                iframeElement.style.border = 'none';
                iframeElement.style.backgroundColor = 'transparent';
                document.body.appendChild(iframeElement);
                form.submit();
                document.body.removeChild(form);
            }
            if (connectionType === ConnectionType.REDIRECT) {
                form.target = '_self';
                form.submit();
                document.body.removeChild(form);
            }
            if (connectionType === ConnectionType.POPUP) {
                const width = Math.min(Math.round(screen.width * 0.7), 1000);
                const height = Math.min(Math.round(screen.height * 0.6), 800);
                const left = Math.round((screen.width - width) / 2);
                const top = Math.round((screen.height - height) / 2);
                let popup;
                setTimeout(() => {
                    popup = window.open('', targetElementId, `popup,width=${width},height=${height},left=${left},top=${top}`);
                    form.submit();
                    document.body.removeChild(form);
                }, 0);
                setTimeout(() => {
                    if (!popup) {
                        cleanup();
                        reject({
                            message: 'Popup has been blocked.',
                        });
                    }
                }, 1000);
                cancelCheckInterval = setInterval(() => {
                    if (popup === null || popup === void 0 ? void 0 : popup.closed) {
                        cleanup();
                        resolve(null);
                    }
                }, 1000);
            }
        }
        catch (e) {
            reject(e);
        }
    });
}
const getConnectionType = ({ connectorSpec, authOptionKey, redirectUri, }) => {
    var _a, _b;
    const authSpec = authOptionKey
        ? (_b = (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b[authOptionKey]
        : connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth;
    if ((authSpec === null || authSpec === void 0 ? void 0 : authSpec.type) === 'client-credentials') {
        return ConnectionType.IFRAME;
    }
    if (redirectUri) {
        return ConnectionType.REDIRECT;
    }
    return ConnectionType.POPUP;
};

class DataSourcesAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'data-sources');
    }
}
class DataSourceAccessor extends ElementAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            path: 'data-source',
        });
    }
    async apply(integrationKeys) {
        return await this.options.client.post(this.getPath('apply'), {
            integrationKeys,
        });
    }
    async reset() {
        return await this.options.client.post(this.getPath('reset'));
    }
}
class DataSourceInstancesAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'data-source-instances');
    }
}
class DataSourceInstanceAccessor extends ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            instancePath: 'data-source-instance',
            selector,
        });
        this.client = client;
    }
    async setup() {
        await this.client.post(this.getPath('setup'));
    }
    async reset() {
        await this.client.post(this.getPath('reset'));
    }
    async openConfiguration({ onClose = () => { }, } = {}) {
        const id = await this.getId();
        const uri = await this.client.getEmbedUri(`data-source-instances/${id}/configuration`);
        return openIframe(uri, {
            onClose,
        });
    }
    async unifiedFieldsToNative(unifiedFields) {
        return this.client.post(this.getPath('unified-fields-to-native'), unifiedFields);
    }
    async getCollection() {
        return this.client.get(this.getPath('collection'));
    }
    async listRecords(request = {}) {
        return this.client.post(this.getPath('collection/list'), request);
    }
    async matchRecord(request) {
        return this.client.post(this.getPath('collection/match'), request);
    }
    async searchRecords(request) {
        return this.client.post(this.getPath('collection/search'), request);
    }
    async findRecordById(request) {
        const data = typeof request === 'string' ? { id: request } : request;
        return this.client.post(this.getPath('collection/find-by-id'), data);
    }
    async createRecord(request) {
        return this.client.post(this.getPath('collection/create'), request);
    }
    async updateRecord(request) {
        return this.client.post(this.getPath(`collection/update`), request);
    }
    async deleteRecord(request) {
        const data = typeof request === 'string' ? { id: request } : request;
        return this.client.post(this.getPath(`collection/delete`), data);
    }
    async findRecords(request = {}) {
        return this.client.post(this.getPath('collection/find'), request);
    }
}
class IntegrationLevelDataSourceAccessor extends IntegrationLevelElementAccessor {
    constructor(client, integrationSelector, dataSourceSelector) {
        super(client, integrationSelector, dataSourceSelector, 'data-sources');
        this.client = client;
        this.integrationSelector = integrationSelector;
        this.dataSourceSelector = dataSourceSelector;
    }
}
class IntegrationLevelDataSourcesListAccessor extends IntegrationLevelElementsListAccessor {
    constructor(client, integrationSelector) {
        super(client, integrationSelector, 'data-sources');
        this.client = client;
        this.integrationSelector = integrationSelector;
    }
}
class ConnectionLevelDataSourceAccessor extends ConnectionLevelElementAccessor {
    constructor(client, connectionSelector, dataSourceSelector, query) {
        super(client, connectionSelector, dataSourceSelector, 'data-sources', query);
        this.client = client;
        this.connectionSelector = connectionSelector;
        this.dataSourceSelector = dataSourceSelector;
        this.query = query;
    }
    async openConfiguration(options) {
        var _a;
        const instance = await this.get({ autoCreate: true });
        const uri = await this.client.getEmbedUri(`data-source-instances/${instance.id}/configuration`);
        const onClose = (_a = options === null || options === void 0 ? void 0 : options.onClose) !== null && _a !== void 0 ? _a : (() => { });
        return openIframe(uri, { onClose });
    }
}
class ConnectionLevelDataSourcesAccessor extends ConnectionLevelElementsListAccessor {
    constructor(client, connectionSelector) {
        super(client, connectionSelector, 'data-sources');
        this.client = client;
        this.connectionSelector = connectionSelector;
    }
}

const DEFAULT_PULL_UPDATES_INTERVAL_SECONDS = 60 * 5;
const DEFAULT_FULL_SYNC_INTERVAL_SECONDS = 60 * 60 * 3;
const MIN_FULL_SYNC_INTERVAL_SECONDS = 1 * 60;
const MIN_PULL_UPDATES_INTERVAL_SECONDS = 1 * 60;

exports.FlowNodeRunStatus = void 0;
(function (FlowNodeRunStatus) {
    FlowNodeRunStatus["COMPLETED"] = "completed";
    FlowNodeRunStatus["FAILED"] = "failed";
    FlowNodeRunStatus["SKIPPED"] = "skipped";
})(exports.FlowNodeRunStatus || (exports.FlowNodeRunStatus = {}));

class FlowRunsAccessor {
    constructor(client) {
        this.client = client;
    }
    async find(query) {
        return this.client.get('/flow-runs', query);
    }
    async create(request) {
        return this.client.post('/flow-runs', request);
    }
}
class FlowRunAccessor {
    constructor(client, id) {
        this.client = client;
        this.id = id;
        this.baseUri = `/flow-runs/${id}`;
    }
    async get() {
        return this.client.get(this.baseUri);
    }
    async stop() {
        await this.client.post(`${this.baseUri}/stop`);
    }
    async getOutput() {
        return this.client.get(`${this.baseUri}/output`);
    }
    async getNodeRuns(nodeKey, parameters) {
        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/runs/${qs.stringify(parameters)}`);
    }
    async getNodeRun(nodeKey, runId) {
        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/runs/${runId}`);
    }
    async getNodeOutputs(nodeKey, parameters) {
        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/outputs?${qs.stringify(parameters)}`);
    }
    async getNodeOutput(nodeKey, outputId) {
        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/output/${outputId}`);
    }
    async repeat() {
        const flowRun = await this.get();
        if (flowRun.state === exports.FlowRunState.RUNNING) {
            throw new BadRequestError('Cannot repeat a running flow run.');
        }
        const flowInstanceAccessor = new FlowInstanceAccessor(this.client, flowRun.flowInstanceId);
        return flowInstanceAccessor.startRun({
            nodeKey: flowRun.startNodeKey,
            input: flowRun.input,
        });
    }
}

exports.FlowRunState = void 0;
(function (FlowRunState) {
    FlowRunState["QUEUED"] = "queued";
    FlowRunState["RUNNING"] = "running";
    FlowRunState["COMPLETED"] = "completed";
    FlowRunState["STOPPED"] = "stopped";
    FlowRunState["FAILED"] = "failed";
})(exports.FlowRunState || (exports.FlowRunState = {}));
exports.FlowRunNodeState = void 0;
(function (FlowRunNodeState) {
    FlowRunNodeState["RUNNING"] = "running";
    FlowRunNodeState["COMPLETED"] = "completed";
    FlowRunNodeState["STOPPED"] = "stopped";
    FlowRunNodeState["FAILED"] = "failed";
})(exports.FlowRunNodeState || (exports.FlowRunNodeState = {}));
exports.FlowRunLaunchedByTrigger = void 0;
(function (FlowRunLaunchedByTrigger) {
    FlowRunLaunchedByTrigger["ApiTrigger"] = "api-trigger";
    FlowRunLaunchedByTrigger["ScheduleTrigger"] = "schedule-trigger";
    FlowRunLaunchedByTrigger["AppEventTrigger"] = "app-event-trigger";
    FlowRunLaunchedByTrigger["DataSourceTrigger"] = "data-source-trigger";
    FlowRunLaunchedByTrigger["ExternalEvent"] = "external-event";
})(exports.FlowRunLaunchedByTrigger || (exports.FlowRunLaunchedByTrigger = {}));

const MAX_POLLING_ERRORS = 10;
class FlowsAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'flows');
    }
}
class FlowAccessor extends ElementAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            path: 'flow',
        });
    }
    async apply(integrationKeys) {
        return await this.options.client.post(this.getPath('apply'), {
            integrationKeys,
        });
    }
    async reset() {
        return await this.options.client.post(this.getPath('reset'));
    }
}
class FlowInstancesAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'flow-instances');
    }
    async create(data) {
        return this.client.post('/flow-instances', data);
    }
}
class FlowInstanceAccessor extends ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            instancePath: 'flow-instance',
            type: exports.WorkspaceElementType.FlowInstance,
        });
        this.client = client;
        this.selector = selector;
    }
    async enable() {
        return this.patch({ enabled: true });
    }
    async disable() {
        return this.patch({ enabled: false });
    }
    async updateToLatestFlow() {
        const id = await this.getId();
        return this.client.post(`/flow-instances/${id}/update-to-latest-flow`);
    }
    async setup() {
        const id = await this.getId();
        return this.client.post(`/flow-instances/${id}/setup`);
    }
    async reset(options) {
        const id = await this.getId();
        return this.client.post(`/flow-instances/${id}/reset`, options);
    }
    async openConfiguration({ nodeKey, onClose = () => { }, } = {}) {
        const id = await this.getId();
        const uri = await this.client.getEmbedUri(`flow-instances/${id}/configuration`, {
            nodeKey,
        });
        return openIframe(uri, {
            onClose,
        });
    }
    async openEditor({ onClose = () => { } } = {}) {
        const id = await this.getId();
        const uri = await this.client.getEmbedUri(`flow-instances/${id}/editor`);
        return openIframe(uri, {
            onClose,
        });
    }
    async startRun(options = {}) {
        const id = await this.getId();
        const flowRunsAccessor = new FlowRunsAccessor(this.client);
        const flowRun = await flowRunsAccessor.create({
            flowInstanceId: id,
            nodeKey: options.nodeKey,
            input: options.input,
        });
        return flowRun;
    }
    async run(options = {}) {
        function onUpdate(flowRun) {
            var _a;
            (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, flowRun);
        }
        const flowRun = await this.startRun(options);
        onUpdate(flowRun);
        let checkFlowRunInterval;
        function cleanup() {
            if (checkFlowRunInterval) {
                clearInterval(checkFlowRunInterval);
            }
        }
        return new Promise((resolve, reject) => {
            const handleFlowRunUpdate = async (flowRun) => {
                var _a, _b;
                onUpdate(flowRun);
                if (flowRun.state === exports.FlowRunState.COMPLETED) {
                    cleanup();
                    resolve(flowRun);
                }
                else if (flowRun.state === exports.FlowRunState.FAILED) {
                    cleanup();
                    reject(new Error(`Flow run ${flowRun.id} failed: ${(_b = (_a = flowRun.errors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.message}`));
                }
            };
            const fetchFlowRun = async () => {
                const flowRunAccessor = new FlowRunAccessor(this.client, flowRun.id);
                await handleFlowRunUpdate(await flowRunAccessor.get());
            };
            let pollingFlowRun = false;
            let errors = 0;
            checkFlowRunInterval = setInterval(async () => {
                if (!pollingFlowRun) {
                    pollingFlowRun = true;
                    try {
                        await fetchFlowRun();
                        errors = 0;
                    }
                    finally {
                        errors += 1;
                        if (errors > MAX_POLLING_ERRORS) {
                            cleanup();
                            reject(new Error(`Got ${errors} errors while polling flow run ${flowRun.id} state - aborting`));
                        }
                        pollingFlowRun = false;
                    }
                }
            }, 1000);
        });
    }
}
class IntegrationLevelFlowAccessor extends IntegrationLevelElementAccessor {
    constructor(client, integrationSelector, flowSelector) {
        super(client, integrationSelector, flowSelector, 'flows');
        this.client = client;
        this.integrationSelector = integrationSelector;
        this.flowSelector = flowSelector;
    }
}
class IntegrationLevelFlowsListAccessor extends IntegrationLevelElementsListAccessor {
    constructor(client, integrationSelector) {
        super(client, integrationSelector, 'flows');
        this.client = client;
        this.integrationSelector = integrationSelector;
    }
}
class ConnectionLevelFlowAccessor extends ConnectionLevelElementAccessor {
    constructor(client, connectionSelector, flowSelector, query) {
        super(client, connectionSelector, flowSelector, 'flows', query);
        this.client = client;
        this.connectionSelector = connectionSelector;
        this.flowSelector = flowSelector;
        this.query = query;
    }
    async enable() {
        return this.patch({ enabled: true });
    }
    async disable() {
        return this.patch({ enabled: false });
    }
    async run(options) {
        return await this.client.post(this.uri('/run'), options);
    }
    async openConfiguration(options) {
        var _a;
        const instance = await this.get({ autoCreate: true });
        const uri = await this.client.getEmbedUri(`flow-instances/${instance.id}/configuration`, {
            nodeKey: options === null || options === void 0 ? void 0 : options.nodeKey,
        });
        const onClose = (_a = options === null || options === void 0 ? void 0 : options.onClose) !== null && _a !== void 0 ? _a : (() => { });
        return openIframe(uri, { onClose });
    }
    async openEditor(options) {
        var _a;
        const instance = await this.get({ autoCreate: true });
        const uri = await this.client.getEmbedUri(`flow-instances/${instance.id}/editor`);
        const onClose = (_a = options === null || options === void 0 ? void 0 : options.onClose) !== null && _a !== void 0 ? _a : (() => { });
        return openIframe(uri, { onClose });
    }
}
class ConnectionLevelFlowsAccessor extends ConnectionLevelElementsListAccessor {
    constructor(client, connectionSelector) {
        super(client, connectionSelector, 'flows');
        this.client = client;
        this.connectionSelector = connectionSelector;
    }
}

class FlowNodeSpec {
    constructor(args) {
        Object.assign(this, args);
    }
}

var ApiRequestToExternalApp = new FlowNodeSpec({
    name: 'API Request to External App',
    description: 'Send an arbitrary API request to the external application',
    requiresIntegration: true,
});

var ApiRequestToYourApp = new FlowNodeSpec({
    name: 'API Request to Your App',
    description: 'Send an API request to my application',
});

var ApiTrigger = new FlowNodeSpec({
    name: 'API Trigger',
    description: 'Launch flow via API',
    isTrigger: true,
});

var AppEventTrigger = new FlowNodeSpec({
    name: 'App Event Trigger',
    description: 'Trigger flow when a matching App Event is received',
    isTrigger: true,
});

var connectorEventTrigger = new FlowNodeSpec({
    name: 'Connector Event Trigger',
    description: "Trigger flow on one of the events defined by the external app's connector.",
    isTrigger: true,
    requiresIntegration: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var CreateDataLink = new FlowNodeSpec({
    name: 'Create Data Link',
    description: 'Link records between your app and external app',
});

var CreateDataRecord = new FlowNodeSpec({
    name: 'Create Data Record',
    description: 'Create a new data record in a collection',
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.EXPORT,
});

var CustomHttpRequest = new FlowNodeSpec({
    name: 'Custom HTTP Request',
    description: 'Send an API request',
});

var DataRecordCreatedTrigger = new FlowNodeSpec({
    name: 'Data Record Created Trigger',
    description: 'Launch flow when a data record is created in a remote data collection',
    isTrigger: true,
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var DataRecordDeletedTrigger = new FlowNodeSpec({
    name: 'Data Record Deleted Trigger',
    description: 'Launch flow when a data record is deleted in a remote data collection',
    isTrigger: true,
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var DataRecordUpdatedTrigger = new FlowNodeSpec({
    name: 'Data Record Updated Trigger',
    description: 'Launch flow when a data record is updated in a remote data collection',
    isTrigger: true,
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var DeleteDataLink = new FlowNodeSpec({
    name: 'Delete Data Link',
    description: 'Unlink records between your app and external app',
});

var DeleteDataRecord = new FlowNodeSpec({
    name: 'Delete Data Record',
    description: 'Delete a new data record from a collection using its id',
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.EXPORT,
});

var Filter = new FlowNodeSpec({
    name: 'Filter',
    description: 'Filter records that go forward through the flow',
});

var FindDataLink = new FlowNodeSpec({
    name: 'Find Data Link',
    description: 'Find a link between records in your app and external app',
});

var FindDataRecordById = new FlowNodeSpec({
    name: 'Find Data Record By Id',
    description: 'Find a single data record by id',
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var FindDataRecords = new FlowNodeSpec({
    name: 'Find Data Records',
    description: 'Find records in a data collection by their field values',
    isDeprecated: true,
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var FindOrCreateDataRecord = new FlowNodeSpec({
    name: 'Find or Create Data Record',
    description: 'Find a matching data record or create a new one if nothing found.',
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.EXPORT,
});

var ForEach = new FlowNodeSpec({
    name: 'For Each',
    description: 'Execute one or more steps for each item on a list.',
});

var ForEachV2 = new FlowNodeSpec({
    name: 'For Each',
    description: 'Execute one or more steps for each item on a list.',
    getSubFlowRootNodeKey: (node) => { var _a; return (_a = node.config) === null || _a === void 0 ? void 0 : _a.rootNodeKey; },
});

var IntegrationSpecificOperation = new FlowNodeSpec({
    name: 'Integration-specific Operation',
    description: 'Node that executes operation specific to an integration flow is created for.',
    requiresIntegration: true,
});

var ListDataRecords = new FlowNodeSpec({
    name: 'List Data Records',
    description: 'List all records from a data collection with an optional filter',
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var LookupDataRecord = new FlowNodeSpec({
    name: 'Lookup Data Record',
    description: 'Find a one data record by its fields',
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.IMPORT,
});

var RunAction = new FlowNodeSpec({
    name: 'Run Action',
    description: 'Run prebuilt action.',
});

var RunJavascript = new FlowNodeSpec({
    name: 'Run JavaScript',
    description: 'Run custom JavaScript code',
});

var ScheduleTrigger = new FlowNodeSpec({
    name: 'Schedule Trigger',
    description: 'Run flow on schedule',
    isTrigger: true,
});

var SearchDataRecords = new FlowNodeSpec({
    name: 'Search Data Records',
    description: 'Search records by query.',
    direction: exports.FieldMappingDirection.IMPORT,
});

var TransformData = new FlowNodeSpec({
    name: 'Transform Data',
    description: 'Create a data structure of any shape by combining and transforming inputs',
    requiresDataSpec: false,
});

var UpdateDataRecord = new FlowNodeSpec({
    name: 'Update Data Record',
    description: 'Update a new data record in a collection using its id',
    requiresDataSpec: true,
    direction: exports.FieldMappingDirection.EXPORT,
});

exports.FlowNodeType = void 0;
(function (FlowNodeType) {
    FlowNodeType["ApiTrigger"] = "api-trigger";
    FlowNodeType["ScheduleTrigger"] = "schedule-trigger";
    FlowNodeType["AppEventTrigger"] = "app-event-trigger";
    FlowNodeType["DataRecordCreatedTrigger"] = "data-record-created-trigger";
    FlowNodeType["DataRecordUpdatedTrigger"] = "data-record-updated-trigger";
    FlowNodeType["DataRecordDeletedTrigger"] = "data-record-deleted-trigger";
    FlowNodeType["ConnectorEventTrigger"] = "connector-event-trigger";
    FlowNodeType["SearchDataRecords"] = "search-data-records";
    FlowNodeType["ListDataRecords"] = "list-data-records";
    FlowNodeType["FindOrCreateDataRecord"] = "find-or-create-data-record";
    FlowNodeType["LookupDataRecord"] = "lookup-data-record";
    FlowNodeType["FindDataRecordById"] = "find-data-record-by-id";
    FlowNodeType["CreateDataRecord"] = "create-data-record";
    FlowNodeType["UpdateDataRecord"] = "update-data-record";
    FlowNodeType["DeleteDataRecord"] = "delete-data-record";
    FlowNodeType["CreateDataLink"] = "create-data-link";
    FlowNodeType["FindDataLink"] = "find-data-link";
    FlowNodeType["DeleteDataLink"] = "delete-data-link";
    FlowNodeType["TransformData"] = "transform-data";
    FlowNodeType["Filter"] = "filter";
    FlowNodeType["ForEachV2"] = "for-each-v2";
    FlowNodeType["RunJavascript"] = "run-javascript";
    FlowNodeType["IntegrationSpecificOperation"] = "integration-specific-operation";
    FlowNodeType["ApiRequestToYourApp"] = "api-request-to-your-app";
    FlowNodeType["ApiRequestToExernalApp"] = "api-request-to-external-app";
    FlowNodeType["CustomHttpRequest"] = "custom-http-request";
    FlowNodeType["RunAction"] = "run-action";
    FlowNodeType["ApiRequest"] = "api-request";
    FlowNodeType["CustomApiRequest"] = "custom-api-request";
    FlowNodeType["HttpRequest"] = "http-request";
    FlowNodeType["ForEach"] = "for-each";
    FlowNodeType["FindDataRecords"] = "find-data-records";
})(exports.FlowNodeType || (exports.FlowNodeType = {}));
const FLOW_NODE_SPECS = {
    [exports.FlowNodeType.ApiTrigger]: ApiTrigger,
    [exports.FlowNodeType.ScheduleTrigger]: ScheduleTrigger,
    [exports.FlowNodeType.AppEventTrigger]: AppEventTrigger,
    [exports.FlowNodeType.ConnectorEventTrigger]: connectorEventTrigger,
    [exports.FlowNodeType.DataRecordCreatedTrigger]: DataRecordCreatedTrigger,
    [exports.FlowNodeType.DataRecordUpdatedTrigger]: DataRecordUpdatedTrigger,
    [exports.FlowNodeType.DataRecordDeletedTrigger]: DataRecordDeletedTrigger,
    [exports.FlowNodeType.SearchDataRecords]: SearchDataRecords,
    [exports.FlowNodeType.ListDataRecords]: ListDataRecords,
    [exports.FlowNodeType.LookupDataRecord]: LookupDataRecord,
    [exports.FlowNodeType.FindOrCreateDataRecord]: FindOrCreateDataRecord,
    [exports.FlowNodeType.FindDataRecords]: {
        ...FindDataRecords,
        isDeprecated: true,
    },
    [exports.FlowNodeType.FindDataRecordById]: FindDataRecordById,
    [exports.FlowNodeType.CreateDataRecord]: CreateDataRecord,
    [exports.FlowNodeType.UpdateDataRecord]: UpdateDataRecord,
    [exports.FlowNodeType.DeleteDataRecord]: DeleteDataRecord,
    [exports.FlowNodeType.TransformData]: TransformData,
    [exports.FlowNodeType.Filter]: Filter,
    [exports.FlowNodeType.CreateDataLink]: CreateDataLink,
    [exports.FlowNodeType.FindDataLink]: FindDataLink,
    [exports.FlowNodeType.DeleteDataLink]: DeleteDataLink,
    [exports.FlowNodeType.ForEach]: {
        ...ForEach,
        isDeprecated: true,
    },
    [exports.FlowNodeType.ForEachV2]: ForEachV2,
    [exports.FlowNodeType.RunJavascript]: RunJavascript,
    [exports.FlowNodeType.IntegrationSpecificOperation]: IntegrationSpecificOperation,
    [exports.FlowNodeType.ApiRequestToYourApp]: ApiRequestToYourApp,
    [exports.FlowNodeType.HttpRequest]: {
        ...ApiRequestToYourApp,
        isDeprecated: true,
    },
    [exports.FlowNodeType.ApiRequestToExernalApp]: ApiRequestToExternalApp,
    [exports.FlowNodeType.CustomApiRequest]: {
        ...ApiRequestToExternalApp,
        isDeprecated: true,
    },
    [exports.FlowNodeType.CustomHttpRequest]: CustomHttpRequest,
    [exports.FlowNodeType.ApiRequest]: {
        ...CustomHttpRequest,
        isDeprecated: true,
    },
    [exports.FlowNodeType.RunAction]: RunAction,
};

exports.FlowInstanceNodeState = void 0;
(function (FlowInstanceNodeState) {
    FlowInstanceNodeState["SETTING_UP"] = "SETTING_UP";
    FlowInstanceNodeState["SETUP_FAILED"] = "SETUP_FAILED";
    FlowInstanceNodeState["READY"] = "READY";
})(exports.FlowInstanceNodeState || (exports.FlowInstanceNodeState = {}));

function getFlowNode(flow, nodeKey) {
    var _a;
    return (_a = flow.nodes) === null || _a === void 0 ? void 0 : _a[nodeKey];
}
function getFlowNodeTitle(flow, nodeKey) {
    var _a, _b, _c, _d, _e;
    const node = getFlowNode(flow, nodeKey);
    if (!node) {
        return undefined;
    }
    if (!node.type) {
        return undefined;
    }
    return ((_e = (_c = (_b = (_a = node.ui) === null || _a === void 0 ? void 0 : _a.title) !== null && _b !== void 0 ? _b : node.name) !== null && _c !== void 0 ? _c : (_d = FLOW_NODE_SPECS[node.type]) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : jsConvertCase.toHeaderCase(nodeKey));
}
function getFlowNodeDescription(flow, nodeKey) {
    var _a;
    const node = getFlowNode(flow, nodeKey);
    return (_a = node.ui) === null || _a === void 0 ? void 0 : _a.description;
}
function getFlowNodeSpec(node) {
    if (!node) {
        throw new Error(`getFlowNodeSpec called without a node`);
    }
    if (!node.type) {
        throw new Error(`getFlowNodeSpec called on a node without a type`);
    }
    const spec = FLOW_NODE_SPECS[node.type];
    if (!spec) {
        throw new Error(`Unknow flow node type: ${node.type}`);
    }
    return spec;
}
function getFlowInstanceNodeDependency({ dependencies }, type) {
    return dependencies === null || dependencies === void 0 ? void 0 : dependencies.find((dep) => dep.type === type);
}
function getRootNodeKeys({ nodes, }) {
    var _a;
    const allNodeKeys = Object.keys(nodes !== null && nodes !== void 0 ? nodes : {});
    const allLinkKeys = Object.values(nodes !== null && nodes !== void 0 ? nodes : {})
        .flatMap((n) => { var _a, _b; return (_b = (_a = n.links) === null || _a === void 0 ? void 0 : _a.map((l) => l.key)) !== null && _b !== void 0 ? _b : []; })
        .filter(Boolean);
    const allSubFlowRootNodeKeys = [];
    for (const nodeKey of allNodeKeys) {
        const node = nodes === null || nodes === void 0 ? void 0 : nodes[nodeKey];
        if (!node || !node.type)
            continue;
        if ((_a = FLOW_NODE_SPECS[node.type]) === null || _a === void 0 ? void 0 : _a.getSubFlowRootNodeKey) {
            const subFlowRootNodeKey = FLOW_NODE_SPECS[node.type].getSubFlowRootNodeKey(node);
            if (subFlowRootNodeKey) {
                allSubFlowRootNodeKeys.push(subFlowRootNodeKey);
            }
        }
    }
    const allNonRootNodeKeys = allLinkKeys.concat(allSubFlowRootNodeKeys);
    return allNodeKeys.filter((k) => !allNonRootNodeKeys.includes(k));
}
function getChildNodeKeys(flow, nodeKey) {
    const node = getFlowNode(flow, nodeKey);
    const nodeLinks = (node === null || node === void 0 ? void 0 : node.links) || [];
    return (nodeLinks
        .map((nodeLink) => nodeLink.key)
        .filter(Boolean)
        .filter((k) => { var _a; return !!((_a = flow.nodes) === null || _a === void 0 ? void 0 : _a[k]); }));
}
function getDownstreamNodeKeys(flow, nodeKey) {
    const linkedKeys = getChildNodeKeys(flow, nodeKey);
    return linkedKeys.concat(linkedKeys.map((k) => getChildNodeKeys(flow, k)).flat());
}
function getParentNodeKeys(flow, nodeKey) {
    return Object.keys(flow.nodes || {}).filter((key) => {
        var _a;
        const node = getFlowNode(flow, key);
        return (_a = node === null || node === void 0 ? void 0 : node.links) === null || _a === void 0 ? void 0 : _a.some((link) => link.key === nodeKey);
    });
}
function getUpstreamNodeKeys(flow, nodeKey) {
    const parentKeys = getParentNodeKeys(flow, nodeKey);
    return parentKeys.concat(parentKeys.map((n) => getUpstreamNodeKeys(flow, n)).flat());
}
function hasCycles(nodes) {
    if (!nodes) {
        return false;
    }
    let hasCycles = false;
    const allVisited = new Set();
    function visitNode(nodeKey, visited) {
        var _a;
        if (!nodeKey)
            return visited;
        if (visited.includes(nodeKey)) {
            hasCycles = true;
            return visited;
        }
        const node = nodes === null || nodes === void 0 ? void 0 : nodes[nodeKey];
        if (!node)
            return visited;
        visited = [...visited, nodeKey];
        allVisited.add(nodeKey);
        if (node.type && ((_a = FLOW_NODE_SPECS[node.type]) === null || _a === void 0 ? void 0 : _a.getSubFlowRootNodeKey)) {
            visited = [
                ...visited,
                ...visitNode(FLOW_NODE_SPECS[node.type].getSubFlowRootNodeKey(node), visited),
            ];
        }
        if (node && node.links) {
            let visitedSubNodes = [];
            for (const link of node.links) {
                if (link.key) {
                    visitedSubNodes = [
                        ...visitedSubNodes,
                        ...visitNode(link.key, visited),
                    ];
                }
            }
            visited = [...visited, ...Array.from(new Set(visitedSubNodes))];
        }
        return visited;
    }
    const rootNodeKeys = getRootNodeKeys({ nodes });
    for (const nodeKey of rootNodeKeys) {
        visitNode(nodeKey, []);
    }
    if (allVisited.size !== Object.keys(nodes).length) {
        hasCycles = true;
    }
    return hasCycles;
}

class ConnectionsAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'connections');
    }
    create(data) {
        return this.client.post('/connections', data);
    }
}
class ConnectionAccessor {
    constructor(client, connectionSelector) {
        this.client = client;
        this.connectionSelector = connectionSelector;
    }
    get actions() {
        return new ConnectionLevelActionsAccessor(this.client, this.connectionSelector);
    }
    action(actionSelector, query) {
        return new ConnectionLevelActionAccessor(this.client, this.connectionSelector, actionSelector, query !== null && query !== void 0 ? query : {});
    }
    get flows() {
        return new ConnectionLevelFlowsAccessor(this.client, this.connectionSelector);
    }
    flow(flowSelector, query) {
        return new ConnectionLevelFlowAccessor(this.client, this.connectionSelector, flowSelector, query !== null && query !== void 0 ? query : {});
    }
    get dataSources() {
        return new ConnectionLevelDataSourcesAccessor(this.client, this.connectionSelector);
    }
    dataSource(dataSourceSelector, query) {
        return new ConnectionLevelDataSourceAccessor(this.client, this.connectionSelector, dataSourceSelector, query !== null && query !== void 0 ? query : {});
    }
    get fieldMappings() {
        return new ConnectionLevelFieldMappingsAccessor(this.client, this.connectionSelector);
    }
    fieldMapping(fieldMappingSelector, query) {
        return new ConnectionLevelFieldMappingAccessor(this.client, this.connectionSelector, fieldMappingSelector, query !== null && query !== void 0 ? query : {});
    }
    async get(query = { includeSecrets: false }) {
        return this.client.get(`/connections/${this.connectionSelector}`, query);
    }
    async patch(data) {
        return this.client.patch(`/connections/${this.connectionSelector}`, data);
    }
    async put(data) {
        return this.client.put(`/connections/${this.connectionSelector}`, data);
    }
    async archive() {
        return this.client.delete(`/connections/${this.connectionSelector}`);
    }
    async request(path, data = null) {
        const pathWithoutSlash = path.startsWith('/') ? path.slice(1) : path;
        return this.client.post(`/connections/${this.connectionSelector}/api/${pathWithoutSlash}`, data);
    }
    get proxy() {
        return new ConnectionProxy(this);
    }
    operation(key) {
        return new ConnectionOperationAccessor(this.client, this, key);
    }
    dataCollection(key, parameters) {
        return new ConnectionDataCollectionAccessor(this.client, this, key, parameters);
    }
    dataDirectory(key, parameters) {
        return new ConnectionDataDirectoryAccessor(this.client, this, key, parameters);
    }
    async reconnect({ parameters, authOptionKey, } = {}) {
        const connection = await this.get();
        const connectorSpec = await this.client.get(`/integrations/${connection.integrationId}/connector-spec`);
        return createOrUpdateConnection({
            connectionId: connection.id,
            connectorSpec,
            parameters,
            authOptionKey,
            apiUri: this.client.apiUri,
            token: await this.client.getToken(),
        });
    }
    async openReconnectUI({} = {}) {
        const uri = await this.client.getEmbedUri(`connections/${this.connectionSelector}/refresh`);
        return new Promise((resolve) => {
            void openIframe(uri, {
                onClose: () => resolve(null),
                onSuccess: (connection) => resolve(connection),
            });
        });
    }
    async refreshCredentials() {
        return this.client.post(`connections/${this.connectionSelector}/refresh-credentials`);
    }
    getPath(subpath, query) {
        const queryString = new URLSearchParams(omitBy(query !== null && query !== void 0 ? query : {}, isEmptyValue)).toString();
        return (urljoin(`/connections/${this.connectionSelector}`, subpath !== null && subpath !== void 0 ? subpath : '') +
            (queryString ? `?${queryString}` : ''));
    }
}
class ConnectionOperationAccessor {
    constructor(client, connectionAccessor, key) {
        this.client = client;
        this.connectionAccessor = connectionAccessor;
        this.key = key;
    }
    async get() {
        return this.client.get(this.connectionAccessor.getPath(`operations/${this.key}`));
    }
    async run(request) {
        return this.client.post(this.connectionAccessor.getPath(`operations/${this.key}/run`), request);
    }
}
class ConnectionDataDirectoryAccessor {
    constructor(client, connectionAccessor, key, parameters) {
        this.client = client;
        this.connectionAccessor = connectionAccessor;
        this.key = key;
        this.parameters = parameters;
    }
    async list(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/list`, this.parameters), request);
    }
}
class ConnectionDataCollectionAccessor {
    constructor(client, connectionAccessor, key, parameters) {
        this.client = client;
        this.connectionAccessor = connectionAccessor;
        this.key = key;
        this.parameters = parameters;
    }
    async get() {
        return this.client.get(this.connectionAccessor.getPath(`data/${this.key}`, this.parameters));
    }
    async findById(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/find-by-id`, this.parameters), request);
    }
    async list(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/list`, this.parameters), request);
    }
    async search(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/search`, this.parameters), request);
    }
    async match(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/match`, this.parameters), request);
    }
    async create(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/create`, this.parameters), request);
    }
    async update(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/update`, this.parameters), request);
    }
    async delete(request) {
        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/delete`, this.parameters), request);
    }
}
class ConnectionProxy {
    constructor(connection) {
        this.connection = connection;
    }
    async get(path) {
        return this.connection.client.get(this.getProxyPath(path));
    }
    async post(path, data) {
        return this.connection.client.post(this.getProxyPath(path), data);
    }
    async put(path, data) {
        return this.connection.client.put(this.getProxyPath(path), data);
    }
    async patch(path, data) {
        return this.connection.client.patch(this.getProxyPath(path), data);
    }
    async delete(path) {
        return this.connection.client.delete(this.getProxyPath(path));
    }
    getProxyPath(path) {
        return urljoin(`/connections/${this.connection.connectionSelector}/proxy`, path);
    }
}

class PaginationResponse {
}

class CreateConnectionRequest {
}
class UpdateConnectionRequest {
}
class FindConnectionsResponse extends PaginationResponse {
}

class Connection {
}
class ConnectionSpec {
    constructor(opts) {
        Object.assign(this, opts);
    }
}

exports.ConnectorCopilotSuggestionType = void 0;
(function (ConnectorCopilotSuggestionType) {
    ConnectorCopilotSuggestionType["AuthType"] = "auth-type";
    ConnectorCopilotSuggestionType["AuthImplementation"] = "auth-implementation";
    ConnectorCopilotSuggestionType["AuthConnectionParameters"] = "auth-connection-parameters";
    ConnectorCopilotSuggestionType["AuthApiClient"] = "auth-api-client";
    ConnectorCopilotSuggestionType["DataCollection"] = "data-collection";
    ConnectorCopilotSuggestionType["DataCollectionOperationApiRequests"] = "data-location-operation-api-requests";
    ConnectorCopilotSuggestionType["DataCollectionOperationApiRequestMapping"] = "data-location-operation-api-request-mapping";
    ConnectorCopilotSuggestionType["DataCollectionFieldsSchema"] = "data-location-fields-schema";
    ConnectorCopilotSuggestionType["UdmList"] = "udm-list";
    ConnectorCopilotSuggestionType["UdmFieldsMapping"] = "udm-fields-mapping";
    ConnectorCopilotSuggestionType["UdmFieldsMappingToCollection"] = "udm-fields-mapping-to-collection";
    ConnectorCopilotSuggestionType["UdmFieldsMappingFromCollection"] = "udm-fields-mapping-from-collection";
})(exports.ConnectorCopilotSuggestionType || (exports.ConnectorCopilotSuggestionType = {}));
exports.ConnectorCopilotFileChunkTopicKey = void 0;
(function (ConnectorCopilotFileChunkTopicKey) {
    ConnectorCopilotFileChunkTopicKey["AuthType"] = "auth-type";
    ConnectorCopilotFileChunkTopicKey["AuthImplementation"] = "auth-implementation";
    ConnectorCopilotFileChunkTopicKey["AuthConnectionParameters"] = "auth-connection-parameters";
    ConnectorCopilotFileChunkTopicKey["AuthApiClient"] = "auth-api-client";
})(exports.ConnectorCopilotFileChunkTopicKey || (exports.ConnectorCopilotFileChunkTopicKey = {}));
exports.CopilotTaskType = void 0;
(function (CopilotTaskType) {
    CopilotTaskType["GenerateAuthType"] = "generate-auth-type";
    CopilotTaskType["GenerateOAuthConfiguration"] = "generate-oauth-configuration";
    CopilotTaskType["GenerateAuthConnectionParameters"] = "generate-auth-connection-parameters";
    CopilotTaskType["GenerateAuthApiClient"] = "generate-auth-api-client";
    CopilotTaskType["GenerateDataCollections"] = "generate-data-collections";
    CopilotTaskType["GenerateDataCollectionRecordFromFields"] = "generate-data-collection-record-from-fields";
    CopilotTaskType["GenerateDataCollectionOperationApiRequests"] = "generate-data-collection-operation-api-requests";
    CopilotTaskType["GenerateDataCollectionOperationApiRequestMapping"] = "generate-data-collection-operation-api-request-mapping";
    CopilotTaskType["GenerateDataCollectionFieldsSchema"] = "generate-data-collection-fields-schema";
    CopilotTaskType["GenerateUdmList"] = "generate-udm-list";
    CopilotTaskType["GenerateUdmFieldsMapping"] = "generate-udm-fields-mapping";
})(exports.CopilotTaskType || (exports.CopilotTaskType = {}));
exports.CopilotTaskStatus = void 0;
(function (CopilotTaskStatus) {
    CopilotTaskStatus["Pending"] = "pending";
    CopilotTaskStatus["Running"] = "running";
    CopilotTaskStatus["Completed"] = "completed";
    CopilotTaskStatus["Failed"] = "failed";
})(exports.CopilotTaskStatus || (exports.CopilotTaskStatus = {}));
exports.CopilotActionType = void 0;
(function (CopilotActionType) {
    CopilotActionType["PatchConnectorFile"] = "patch";
    CopilotActionType["PutConnectorFile"] = "put";
    CopilotActionType["PatchConnectorDataSchema"] = "patch-data-schema";
    CopilotActionType["PatchConnectorFieldMapping"] = "patch-field-mapping";
    CopilotActionType["SetConnectorAuthType"] = "set-connector-auth-type";
})(exports.CopilotActionType || (exports.CopilotActionType = {}));
exports.CopilotActionStatus = void 0;
(function (CopilotActionStatus) {
    CopilotActionStatus["Suggested"] = "suggested";
    CopilotActionStatus["Executed"] = "executed";
    CopilotActionStatus["Rejected"] = "rejected";
})(exports.CopilotActionStatus || (exports.CopilotActionStatus = {}));
exports.CopilotActivityType = void 0;
(function (CopilotActivityType) {
    CopilotActivityType["Task"] = "task";
})(exports.CopilotActivityType || (exports.CopilotActivityType = {}));
const CopilotActivityScope = {
    connector: (connectorId) => new CopilotActivityScopeConnector(connectorId),
};
class CopilotActivityScopeConnector {
    constructor(connectorId) {
        this.connectorId = connectorId;
        this.auth = () => new CopilotActivityScopeConnectorAuth(this);
        this.data = (key) => new CopilotActivityScopeConnectorData(this, key);
        this.udm = (key) => new CopilotActivityScopeConnectorUdm(this, key);
    }
    toString() {
        return `connectors/${this.connectorId}`;
    }
}
class CopilotActivityScopeConnectorAuth {
    constructor(connectorScope) {
        this.connectorScope = connectorScope;
    }
    toString() {
        return `${this.connectorScope.toString()}/auth`;
    }
}
class CopilotActivityScopeConnectorData {
    constructor(connectorScope, dataCollectionKey) {
        this.connectorScope = connectorScope;
        this.dataCollectionKey = dataCollectionKey;
        this.method = (key) => new CopilotActivityScopeConnectorDataMethod(this, key);
    }
    toString() {
        let scope = `${this.connectorScope.toString()}/data`;
        if (this.dataCollectionKey) {
            scope += `/${this.dataCollectionKey}`;
        }
        return scope;
    }
}
class CopilotActivityScopeConnectorDataMethod {
    constructor(collectionScope, methodKey) {
        this.collectionScope = collectionScope;
        this.methodKey = methodKey;
    }
    toString() {
        return `${this.collectionScope.toString()}/methods/${this.methodKey}`;
    }
}
class CopilotActivityScopeConnectorUdm {
    constructor(connectorScope, key) {
        this.connectorScope = connectorScope;
        this.key = key;
        this.collection = (key) => new CopilotActivityScopeConnectorUdmCollection(this, key);
    }
    toString() {
        let scope = `${this.connectorScope.toString()}/udm`;
        if (this.key) {
            scope += `/${this.key}`;
        }
        return scope;
    }
}
class CopilotActivityScopeConnectorUdmCollection {
    constructor(udmScope, key) {
        this.udmScope = udmScope;
        this.key = key;
    }
    toString() {
        return `${this.udmScope.toString()}/collection/${this.key}`;
    }
}

class DataForm {
    constructor(args) {
        Object.assign(this, args);
    }
    getFields() {
        var _a;
        switch (this.schema.type) {
            case 'object':
                return Object.entries((_a = this.schema.properties) !== null && _a !== void 0 ? _a : {}).map(([key, schema]) => this.makeDataField(key, schema));
            case 'array':
                return [];
            default:
                return [this.makeDataField(null, this.schema)];
        }
    }
    getFieldValueOptions(field) {
        var _a, _b, _c;
        const options = [];
        const defaultValue = (_a = field.schema) === null || _a === void 0 ? void 0 : _a.default;
        if (defaultValue !== undefined) {
            options.push({
                name: valueToString(field.schema.default, this.variablesSchema),
                value: field.schema.default,
            });
        }
        if (((_b = this.variablesSchema) === null || _b === void 0 ? void 0 : _b.type) === 'object') {
            for (const locator of Object.keys((_c = this.variablesSchema.properties) !== null && _c !== void 0 ? _c : {})) {
                const formula = new DataBuilderFormulaVar(locator);
                const value = formula.toObject();
                if (!deepEqual(value, defaultValue)) {
                    options.push({
                        name: formula.toString(this.variablesSchema),
                        value,
                    });
                }
            }
        }
        options.forEach((option) => {
            option.selected = deepEqual(option.value, field.value);
        });
        return options;
    }
    setFieldValue(field, value) {
        return setValueAtLocator(this.value, field.locator, value);
    }
    makeDataField(key, schema) {
        var _a;
        return {
            name: (_a = schema === null || schema === void 0 ? void 0 : schema.title) !== null && _a !== void 0 ? _a : jsConvertCase.toHeaderCase(key),
            locator: key,
            schema,
            value: getValueAtLocator(this.value, key),
        };
    }
}

class DataLinkTablesAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'data-link-tables');
    }
}
class DataLinkTableAccessor extends ElementAccessor {
    constructor(client, idOrKey) {
        super({
            client,
            path: 'data-link-table',
            selector: idOrKey,
        });
    }
}
class DataLinkTableInstancesAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'data-link-table-instances');
    }
}
class DataLinkTableInstanceAccessor extends ElementInstanceAccessor {
    constructor(client, selector) {
        super({
            client,
            instancePath: 'data-link-table-instance',
            selector,
        });
        this.client = client;
    }
    async findLinks(query) {
        const queryString = query ? qs.stringify(query) : '';
        return this.client.get(this.getPath('links') + (queryString ? `&${queryString}` : ''));
    }
    async createLink(data) {
        return this.client.post(this.getPath('links'), data);
    }
    async deleteLink(data) {
        return this.client.delete(this.getPath('links'), data);
    }
}

exports.DataLinkDirection = void 0;
(function (DataLinkDirection) {
    DataLinkDirection["IMPORT"] = "import";
    DataLinkDirection["EXPORT"] = "export";
    DataLinkDirection["BOTH"] = "both";
})(exports.DataLinkDirection || (exports.DataLinkDirection = {}));

function parseDate(value) {
    let timestamp;
    if (typeof value === 'number') {
        timestamp = value;
    }
    else if (typeof value === 'string') {
        timestamp = Date.parse(value);
        if (isNaN(timestamp)) {
            timestamp = undefined;
        }
        if (!timestamp && Number(value) > 1000000000) {
            timestamp = Number(value);
        }
    }
    if (timestamp) {
        return timestampToDate(timestamp);
    }
    else {
        return undefined;
    }
}
function timestampToDate(value) {
    if (Math.round(value).toString().length < 13) {
        return new Date(value * 1000);
    }
    else {
        return new Date(value);
    }
}

exports.ExternalEventType = void 0;
(function (ExternalEventType) {
    ExternalEventType["DataRecordCreated"] = "data-record-created";
    ExternalEventType["DataRecordUpdated"] = "data-record-updated";
    ExternalEventType["DataRecordDeleted"] = "data-record-deleted";
    ExternalEventType["ConnectorEvent"] = "connector-event";
})(exports.ExternalEventType || (exports.ExternalEventType = {}));
exports.ExternalEventSubscriptionStatus = void 0;
(function (ExternalEventSubscriptionStatus) {
    ExternalEventSubscriptionStatus["Subscribed"] = "subscribed";
    ExternalEventSubscriptionStatus["Unsubscribed"] = "unsubscribed";
    ExternalEventSubscriptionStatus["Error"] = "error";
})(exports.ExternalEventSubscriptionStatus || (exports.ExternalEventSubscriptionStatus = {}));
exports.ExternalEventPullStatus = void 0;
(function (ExternalEventPullStatus) {
    ExternalEventPullStatus["RUNNING"] = "running";
    ExternalEventPullStatus["SUCCESS"] = "success";
    ExternalEventPullStatus["ERROR"] = "error";
    ExternalEventPullStatus["QUEUED"] = "queued";
})(exports.ExternalEventPullStatus || (exports.ExternalEventPullStatus = {}));
exports.IncomingWebhooksState = void 0;
(function (IncomingWebhooksState) {
    IncomingWebhooksState["QUEUED"] = "queued";
    IncomingWebhooksState["RUNNING"] = "running";
    IncomingWebhooksState["SUCCESS"] = "success";
    IncomingWebhooksState["ERROR"] = "error";
})(exports.IncomingWebhooksState || (exports.IncomingWebhooksState = {}));
exports.ExternalEventSubscriptionType = void 0;
(function (ExternalEventSubscriptionType) {
    ExternalEventSubscriptionType["DataRecordCreated"] = "data-record-created";
    ExternalEventSubscriptionType["DataRecordUpdated"] = "data-record-updated";
    ExternalEventSubscriptionType["DataRecordDeleted"] = "data-record-deleted";
    ExternalEventSubscriptionType["ConnectorEvent"] = "connector-event";
})(exports.ExternalEventSubscriptionType || (exports.ExternalEventSubscriptionType = {}));

class ExternalEventSubscriptionsAccessor extends ElementInstanceListAccessor {
    constructor(client) {
        super(client, 'external-event-subscriptions');
    }
}
class ExternalEventSubscriptionAccessor {
    constructor(client, id) {
        this.client = client;
        this.id = id;
    }
    async get() {
        return this.client.get(this.getPath());
    }
    async setup() {
        await this.client.post(this.getPath('setup'));
    }
    async subscribe() {
        await this.client.post(this.getPath('subscribe'));
    }
    async unsubscribe() {
        await this.client.post(this.getPath('unsubscribe'));
    }
    async resubscribe() {
        await this.client.post(this.getPath('resubscribe'));
    }
    async pullEvents() {
        await this.client.post(this.getPath('pull-events'));
    }
    getPath(operation = '') {
        return `external-event-subscriptions/${this.id}${operation ? '/' + operation : ''}`;
    }
}

function externalEventTypeToDataCollectionEventType(type) {
    switch (type) {
        case exports.ExternalEventType.DataRecordCreated:
            return exports.DataCollectionEventType.CREATED;
        case exports.ExternalEventType.DataRecordUpdated:
            return exports.DataCollectionEventType.UPDATED;
        case exports.ExternalEventType.DataRecordDeleted:
            return exports.DataCollectionEventType.DELETED;
        default:
            throw new InternalError(`Cannot convert ExternalEventType "${type}" to DataCollectionEventType`);
    }
}
function dataCollectionEventTypeToExternalEventType(type) {
    switch (type) {
        case exports.DataCollectionEventType.CREATED:
            return exports.ExternalEventType.DataRecordCreated;
        case exports.DataCollectionEventType.UPDATED:
            return exports.ExternalEventType.DataRecordUpdated;
        case exports.DataCollectionEventType.DELETED:
            return exports.ExternalEventType.DataRecordDeleted;
        default:
            throw new InternalError(`Cannot convert DataCollectionEventType "${type}" to ExternalEventType`);
    }
}
function externalEventTypeToSubscriptionType(type) {
    switch (type) {
        case exports.ExternalEventType.DataRecordCreated:
            return exports.ExternalEventSubscriptionType.DataRecordCreated;
        case exports.ExternalEventType.DataRecordUpdated:
            return exports.ExternalEventSubscriptionType.DataRecordUpdated;
        case exports.ExternalEventType.DataRecordDeleted:
            return exports.ExternalEventSubscriptionType.DataRecordDeleted;
        case exports.ExternalEventType.ConnectorEvent:
            return exports.ExternalEventSubscriptionType.ConnectorEvent;
        default:
            throw new InternalError(`Cannot convert ExternalEventType "${type}" to ExternalEventSubscriptionType`);
    }
}

exports.HttpRequestMethod = void 0;
(function (HttpRequestMethod) {
    HttpRequestMethod["GET"] = "GET";
    HttpRequestMethod["POST"] = "POST";
    HttpRequestMethod["PATCH"] = "PATCH";
    HttpRequestMethod["PUT"] = "PUT";
    HttpRequestMethod["DELETE"] = "DELETE";
})(exports.HttpRequestMethod || (exports.HttpRequestMethod = {}));
const HTTP_REQUEST_SCHEMA = {
    type: 'object',
    properties: {
        uri: { type: 'string' },
        method: {
            type: 'string',
            enum: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
        },
        body: {},
        query: {
            type: 'object',
            section: true,
            additionalProperties: true,
        },
        headers: {
            type: 'object',
            section: true,
            additionalProperties: true,
        },
    },
};

exports.IntegrationElementLevel = void 0;
(function (IntegrationElementLevel) {
    IntegrationElementLevel["UNIVERSAL"] = "universal";
    IntegrationElementLevel["CONNECTOR"] = "connector";
    IntegrationElementLevel["CONNECTION"] = "connection";
})(exports.IntegrationElementLevel || (exports.IntegrationElementLevel = {}));
exports.IntegrationElementType = void 0;
(function (IntegrationElementType) {
    IntegrationElementType["APP_DATA_SCHEMA"] = "app-data-schema";
    IntegrationElementType["APP_EVENT_TYPE"] = "app-event-type";
    IntegrationElementType["DATA_SOURCE"] = "data-source";
    IntegrationElementType["SCHEMA"] = "schema";
    IntegrationElementType["FIELD_MAPPING"] = "field-mapping";
    IntegrationElementType["FLOW"] = "flow";
    IntegrationElementType["INTEGRATION"] = "integration";
    IntegrationElementType["ACTION"] = "action";
    IntegrationElementType["DATA_LINK_TABLE"] = "data-link-table";
    IntegrationElementType["EXTERNAL_EVENT"] = "external-event";
})(exports.IntegrationElementType || (exports.IntegrationElementType = {}));

class IntegrationsAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'integrations');
    }
}
class IntegrationAccessor extends ElementAccessor {
    constructor(client, integrationSelector) {
        super({
            client,
            path: 'integration',
            selector: integrationSelector,
        });
        this.client = client;
        this.integrationSelector = integrationSelector;
    }
    get actions() {
        return new IntegrationLevelActionsListAccessor(this.client, this.integrationSelector);
    }
    action(actionSelector) {
        return new IntegrationLevelActionAccessor(this.client, this.integrationSelector, actionSelector);
    }
    get flows() {
        return new IntegrationLevelFlowsListAccessor(this.client, this.integrationSelector);
    }
    flow(flowSelector) {
        return new IntegrationLevelFlowAccessor(this.client, this.integrationSelector, flowSelector);
    }
    get dataSources() {
        return new IntegrationLevelDataSourcesListAccessor(this.client, this.integrationSelector);
    }
    dataSource(dataSourceSelector) {
        return new IntegrationLevelDataSourceAccessor(this.client, this.integrationSelector, dataSourceSelector);
    }
    get fieldMappings() {
        return new IntegrationLevelFieldMappingsListAccessor(this.client, this.integrationSelector);
    }
    fieldMapping(fieldMappingSelector) {
        return new IntegrationLevelFieldMappingAccessor(this.client, this.integrationSelector, fieldMappingSelector);
    }
    async setup() {
        return this.client.post(`/integrations/${this.integrationSelector}/setup`);
    }
    async resetParameters() {
        return this.client.post(`/integrations/${this.integrationSelector}/reset-parameters`);
    }
    async getConnectorSpec() {
        return this.client.get(`/integrations/${this.integrationSelector}/connector-spec`);
    }
    async open({ onClose = () => { }, } = {}) {
        const integration = await this.get();
        const uri = await this.client.getEmbedUri(`integrations/${integration.id}`);
        return openIframe(uri, {
            onClose,
        });
    }
    async openNewConnection({ allowMultipleConnections, name, } = {}) {
        const uri = await this.client.getEmbedUri(`integrations/${this.integrationSelector}/connect`, {
            allowMultipleConnections: allowMultipleConnections ? '1' : '',
            name,
        });
        return new Promise((resolve) => {
            return openIframe(uri, {
                onClose: () => resolve(null),
                onSuccess: (connection) => resolve(connection),
            });
        });
    }
    async connect({ name, parameters, authOptionKey, allowMultipleConnections, redirectUri, sameWindow, } = {}) {
        const integration = await this.get();
        const connectorSpec = await this.getConnectorSpec();
        return createOrUpdateConnection({
            integrationId: integration.id,
            connectorSpec,
            name,
            parameters,
            authOptionKey,
            allowMultipleConnections,
            apiUri: this.client.apiUri,
            token: await this.client.getToken(),
            redirectUri: sameWindow ? redirectUri : undefined,
        });
    }
    async createConnection({ parameters, name, }) {
        return this.connect({ parameters, name });
    }
    async disconnect() {
        return this.client.post(`/integrations/${this.integrationSelector}/disconnect`);
    }
    async getOperations() {
        return this.client.get(this.getPath('operations'));
    }
    async getOperation(key) {
        return this.client.get(this.getPath(`operations/${key}`));
    }
    async getDataCollections() {
        return this.client.get(this.getPath('data'));
    }
    async getDataCollection(key) {
        return this.client.get(this.getPath(`data/${key}`));
    }
    async getDataLocations() {
        return this.client.get(this.getPath('data'));
    }
    async getDataLocation(key) {
        return this.client.get(this.getPath(`data/${key}`));
    }
}

class ScreensAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'screens');
    }
}
class ScreenAccessor extends ElementAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            path: 'screen',
        });
    }
}

exports.ScreenType = void 0;
(function (ScreenType) {
    ScreenType["Integration"] = "integration";
})(exports.ScreenType || (exports.ScreenType = {}));
exports.ScreenBlockType = void 0;
(function (ScreenBlockType) {
    ScreenBlockType["Flow"] = "flow";
    ScreenBlockType["FieldMapping"] = "field-mapping";
    ScreenBlockType["DataSource"] = "data-source";
    ScreenBlockType["Action"] = "action";
})(exports.ScreenBlockType || (exports.ScreenBlockType = {}));

exports.UsageType = void 0;
(function (UsageType) {
    UsageType["FLOW_RUNS_DURATION"] = "flow-runs-duration";
    UsageType["FLOW_RUNS_NUMBER"] = "flow-runs-number";
    UsageType["FLOW_RUNS_LOG_SIZE"] = "flow-runs-log-size";
    UsageType["API_LOGS_NUMBER"] = "api-logs-number";
    UsageType["API_LOGS_SIZE"] = "api-logs-size";
    UsageType["WEBHOOK_LOGS_NUMBER"] = "webhook-logs-number";
    UsageType["WEBHOOK_LOGS_SIZE"] = "webhook-logs-size";
    UsageType["EVENT_LOGS_NUMBER"] = "event-logs-number";
    UsageType["EVENT_LOGS_SIZE"] = "event-logs-size";
    UsageType["EVENT_LOGS_DURATION"] = "event-logs-duration";
    UsageType["EXTERNAL_EVENTS_PULL_DURATION"] = "external-events-pull-duration";
    UsageType["EXTERNAL_EVENT_PULL_NUMBER"] = "external-event-pull-number";
    UsageType["EXTERNAL_EVENT_PULL_LOG_SIZE"] = "external-event-pull-log-size";
    UsageType["APP_EVENTS_NUMBER"] = "app-events-number";
    UsageType["APP_EVENTS_SIZE"] = "app-events-size";
    UsageType["FILES_UPLOAD_NUMBER"] = "files-upload-number";
    UsageType["FILES_UPLOAD_SIZE"] = "files-upload-size";
    UsageType["CUSTOM_CODE_RUNTIME_DURATION"] = "custom-code-runtime-duration";
})(exports.UsageType || (exports.UsageType = {}));

class CustomersAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'customers');
    }
}
class CustomerAccessor extends ElementAccessor {
    constructor(client, selector) {
        super({
            path: 'customer',
            client,
            selector,
        });
    }
}

class ScenariosAccessor extends ElementListAccessor {
    constructor(client) {
        super(client, 'scenarios');
    }
}
class ScenarioAccessor extends ElementAccessor {
    constructor(client, selector) {
        super({
            client,
            selector,
            path: 'scenario',
        });
    }
}

function getNodeInputSchema(flow, nodeKey) {
    const schema = {
        type: 'object',
        properties: {},
    };
    getUpstreamNodeKeys(flow, nodeKey).forEach((prevNodeKey) => {
        const prevNode = flow.nodes[prevNodeKey];
        if (prevNode.outputSchema) {
            const prevNodeSchema = JSON.parse(JSON.stringify(prevNode.outputSchema));
            if (!prevNodeSchema.title) {
                prevNodeSchema.title = prevNode.name;
            }
            schema.properties[prevNodeKey] = prevNodeSchema;
        }
    });
    return schema;
}
function getFlowNodeConfigTimeVariablesSchema({ parametersSchema, userSchema, }) {
    return {
        type: 'object',
        properties: {
            flowInstance: getFlowInstanceVariableSchema({ parametersSchema }),
            user: userSchema,
        },
    };
}
function getActionRunTimeVariablesSchema({ inputSchema, userSchema, }) {
    return {
        type: 'object',
        properties: {
            input: inputSchema,
            user: userSchema,
            actionInstance: getActionInstanceVariableSchema(),
            connection: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    name: { type: 'string' },
                },
            },
            integration: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    name: { type: 'string' },
                },
            },
        },
    };
}
function getActionInstanceVariableSchema() {
    return {
        type: 'object',
        properties: {
            id: { type: 'string ' },
            instanceKey: { type: 'string' },
        },
    };
}
function getFlowNodeRunTimeVariablesSchema({ parametersSchema, inputSchema, userSchema, }) {
    return {
        type: 'object',
        properties: {
            input: inputSchema,
            user: userSchema,
            flowRun: getFlowRunVariableSchema(),
            flowInstance: getFlowInstanceVariableSchema({ parametersSchema }),
            connection: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    name: { type: 'string' },
                },
            },
            integration: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    key: { type: 'string' },
                    name: { type: 'string' },
                },
            },
        },
    };
}
function getFlowInstanceVariableSchema({ parametersSchema, }) {
    return {
        type: 'object',
        properties: {
            id: { type: 'string ' },
            instanceKey: { type: 'string' },
            flowId: { type: 'string' },
            parameters: parametersSchema,
        },
    };
}
function getFlowRunVariableSchema() {
    return {
        type: 'object',
        properties: {
            id: { type: 'string ' },
        },
    };
}

exports.WorkspaceOnboardingStep = void 0;
(function (WorkspaceOnboardingStep) {
    WorkspaceOnboardingStep["AddConnectors"] = "add-connectors";
    WorkspaceOnboardingStep["ConnectYourApp"] = "connect-your-app";
    WorkspaceOnboardingStep["BuildIntegrations"] = "build-integrations";
    WorkspaceOnboardingStep["Completed"] = "completed";
})(exports.WorkspaceOnboardingStep || (exports.WorkspaceOnboardingStep = {}));
exports.WorkspaceNotificationType = void 0;
(function (WorkspaceNotificationType) {
    WorkspaceNotificationType["WorkspaceUpdate"] = "workspace-update";
    WorkspaceNotificationType["CopilotActivity"] = "copilot-activity";
})(exports.WorkspaceNotificationType || (exports.WorkspaceNotificationType = {}));
exports.WorkspaceType = void 0;
(function (WorkspaceType) {
    WorkspaceType["PRODUCTION"] = "production";
    WorkspaceType["DEVELOPMENT"] = "development";
})(exports.WorkspaceType || (exports.WorkspaceType = {}));

const PARALLEL_EXECUTION_LIMITS = [
    'parallelEventPulls',
    'parallelIncrementalEventPullsPerConnection',
    'parallelFullSyncEventPullsPerConnection',
    'parallelFlowRuns',
    'parallelFlowRunsPerConnection',
    'parallelApiRequests',
    'parallelBackgroundJobs',
    'parallelEventLogRecordsProcessing',
    'parallelEventLogRecordsProcessingPerConnection',
];
const RATE_LIMITS = [
    'fileUploadsMbPerHour',
    'apiRequestsPerSecond',
    'apiRequestsPerHour',
    'webhookRequestsPerSecond',
    'webhookRequestsPerHour',
    'workspaceElementCreationsPerHour',
    'workspaceElementCreationsPerSecond',
];
const WORKSPACE_SIZE_LIMITS = [
    'totalNumberOfCustomers',
    'totalNumberOfConnections',
    'totalNumberOfWorkspaceElements',
];
const EDITABLE_LIMITS = [
    'parallelApiRequestsPerCustomer',
    'parallelBackgroundJobsPerCustomer',
    'apiRequestsPerCustomerPerSecond',
    'apiRequestsPerCustomerPerHour',
    'webhookRequestsPerCustomerPerSecond',
    'webhookRequestsPerCustomerPerHour',
];

exports.OrgLimitsType = void 0;
(function (OrgLimitsType) {
    OrgLimitsType["NUMBER_OF_WORKSPACES"] = "numberOfWorkspaces";
    OrgLimitsType["TODAY_USAGE"] = "todayUsage";
    OrgLimitsType["LAST_THIRTY_DAY_USAGE"] = "lastThirtyDayUsage";
})(exports.OrgLimitsType || (exports.OrgLimitsType = {}));
exports.OrgUserRole = void 0;
(function (OrgUserRole) {
    OrgUserRole["Admin"] = "admin";
    OrgUserRole["Member"] = "member";
})(exports.OrgUserRole || (exports.OrgUserRole = {}));
exports.OrgUserStatus = void 0;
(function (OrgUserStatus) {
    OrgUserStatus["Invited"] = "invited";
    OrgUserStatus["Active"] = "active";
})(exports.OrgUserStatus || (exports.OrgUserStatus = {}));

exports.WebhookTypeEnum = void 0;
(function (WebhookTypeEnum) {
    WebhookTypeEnum["USER_INVITED_TO_ORG"] = "user-invited-to-org";
})(exports.WebhookTypeEnum || (exports.WebhookTypeEnum = {}));

function decodeJWT(token) {
    if (typeof token !== 'string') {
        return undefined;
    }
    try {
        if (typeof window === 'undefined') {
            return JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
        }
        else {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(window
                .atob(base64)
                .split('')
                .map(function (c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            })
                .join(''));
            return JSON.parse(jsonPayload);
        }
    }
    catch (_e) {
        return undefined;
    }
}

const axiosGlobal = ((axiosOriginal === null || axiosOriginal === void 0 ? void 0 : axiosOriginal.default) || axiosOriginal);
const axios = axiosGlobal.create();
const DEFAULT_API_URI = 'https://api.integration.app';
const DEFAULT_UI_URI = 'https://ui.integration.app';
const REFETCH_EXPIRATION_THRESHOLD = 10 * 1000;
function decodeToken(token) {
    const payload = decodeJWT(token);
    if (!payload) {
        throw new Error('Access token should be a valid JWT token.');
    }
    return payload;
}
class IntegrationAppApiClient {
    constructor({ uiUri, apiUri, accessToken, token, fetchToken, fetchCredentials, credentials, } = {}) {
        this.apiUri = apiUri !== null && apiUri !== void 0 ? apiUri : DEFAULT_API_URI;
        this.uiUri = uiUri !== null && uiUri !== void 0 ? uiUri : DEFAULT_UI_URI;
        this.token = token !== null && token !== void 0 ? token : accessToken;
        this.fetchToken = fetchToken;
        if (fetchCredentials) {
            void fetchCredentials().then((c) => this.setCredentials(c));
        }
        else if (credentials) {
            void this.setCredentials(credentials);
        }
    }
    async setCredentials(credentials) {
        return this.patch('/self', { credentials });
    }
    async getToken() {
        if (this.fetchToken) {
            if (!this.token) {
                this.token = await this.fetchToken();
            }
            else {
                const payload = decodeToken(this.token);
                if (payload.exp) {
                    const willExpireSoon = new Date(payload.exp * 1000).getTime() - new Date().getTime() <
                        REFETCH_EXPIRATION_THRESHOLD;
                    if (willExpireSoon) {
                        this.token = await this.fetchToken();
                    }
                }
            }
        }
        if (!this.token) {
            throw new Error('Access token is not provided.');
        }
        decodeToken(this.token);
        return this.token;
    }
    async get(uri, queryParams, options) {
        if (queryParams) {
            uri += `${uri.includes('?') ? '&' : '?'}${new URLSearchParams(omitBy(queryParams, isEmptyValue)).toString()}`;
        }
        return this.makeApiRequest('GET', { ...(options !== null && options !== void 0 ? options : {}), url: uri });
    }
    async post(uri, data, options) {
        return this.makeApiRequest('POST', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
    }
    async put(uri, data, options) {
        return this.makeApiRequest('PUT', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
    }
    async patch(uri, data, options) {
        return this.makeApiRequest('PATCH', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
    }
    async delete(uri, data, options) {
        return this.makeApiRequest('DELETE', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
    }
    async getEmbedUri(page, params) {
        var _a;
        const paramsWithToken = { token: await this.getToken(), ...(params !== null && params !== void 0 ? params : {}) };
        const queryParams = qs.stringify(paramsWithToken);
        const baseUriWithoutSlash = (_a = this.uiUri) === null || _a === void 0 ? void 0 : _a.replace(/\/$/, '');
        const pageWithoutSlash = page.replace(/^\//, '');
        return `${baseUriWithoutSlash}/embed/${pageWithoutSlash}${queryParams ? `?${queryParams}` : ''}`;
    }
    async makeApiRequest(method, params = {}) {
        const token = await this.getToken();
        params.method = method;
        params.baseURL = this.apiUri;
        params.headers = {
            ...(params.headers || {}),
            Authorization: `Bearer ${token}`,
        };
        params.withCredentials = false;
        let response;
        try {
            response = await axios.request(params);
        }
        catch (err) {
            this.handleRequestError(err);
        }
        return response.data;
    }
    handleRequestError(err) {
        var _a, _b;
        if (axiosGlobal.isAxiosError(err) && ((_b = (_a = err.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.type)) {
            const error = getErrorFromData(err.response.data);
            if (error)
                throw error;
        }
        throw err;
    }
}

class IntegrationAppClient extends IntegrationAppApiClient {
    constructor(options) {
        super(options);
    }
    get self() {
        return new SelfAccessor(this);
    }
    get flows() {
        return new FlowsAccessor(this);
    }
    async open({ onClose = () => { }, } = {}) {
        const uri = await this.getEmbedUri('main', {});
        return openIframe(uri, {
            onClose,
        });
    }
    action(selector) {
        return new ActionAccessor(this, selector);
    }
    get actions() {
        return new ActionsAccessor(this);
    }
    screen(selector) {
        return new ScreenAccessor(this, selector);
    }
    get screens() {
        return new ScreensAccessor(this);
    }
    actionInstance(selector) {
        return new ActionInstanceAccessor(this, selector);
    }
    get actionInstances() {
        return new ActionInstancesAccessor(this);
    }
    flow(selector) {
        return new FlowAccessor(this, selector);
    }
    get flowInstances() {
        return new FlowInstancesAccessor(this);
    }
    flowInstance(selector) {
        return new FlowInstanceAccessor(this, selector);
    }
    get dataSourceInstances() {
        return new DataSourceInstancesAccessor(this);
    }
    get dataSources() {
        return new DataSourcesAccessor(this);
    }
    dataSource(selector) {
        return new DataSourceAccessor(this, selector);
    }
    dataSourceInstance(selector) {
        return new DataSourceInstanceAccessor(this, selector);
    }
    get fieldMappings() {
        return new FieldMappingsAccessor(this);
    }
    fieldMapping(selector) {
        return new FieldMappingAccessor(this, selector);
    }
    get fieldMappingInstances() {
        return new FieldMappingInstancesAccessor(this);
    }
    fieldMappingInstance(selector) {
        return new FieldMappingInstanceAccessor(this, selector);
    }
    get dataLinkTables() {
        return new DataLinkTablesAccessor(this);
    }
    dataLinkTable(idOrKey) {
        return new DataLinkTableAccessor(this, idOrKey);
    }
    get dataLinkTableInstances() {
        return new DataLinkTableInstancesAccessor(this);
    }
    dataLinkTableInstance(selector) {
        return new DataLinkTableInstanceAccessor(this, selector);
    }
    get integrations() {
        return new IntegrationsAccessor(this);
    }
    externalEventSubscriptions() {
        return new ExternalEventSubscriptionsAccessor(this);
    }
    externalEventSubscription(id) {
        return new ExternalEventSubscriptionAccessor(this, id);
    }
    integration(identifier) {
        return new IntegrationAccessor(this, identifier);
    }
    get connections() {
        return new ConnectionsAccessor(this);
    }
    connection(connectionSelector) {
        return new ConnectionAccessor(this, connectionSelector);
    }
    get appEventTypes() {
        return new AppEventTypesAccessor(this);
    }
    appEventType(id) {
        return new AppEventTypeAccessor(this, id);
    }
    get appEventSubscriptions() {
        return new AppEventSubscriptionsAccessor(this);
    }
    appEventSubscription(selector) {
        return new AppEventSubscriptionAccessor(this, selector);
    }
    get appEvents() {
        return new AppEventsAccessor(this);
    }
    get flowRuns() {
        return new FlowRunsAccessor(this);
    }
    flowRun(id) {
        return new FlowRunAccessor(this, id);
    }
    get appDataSchemas() {
        return new AppDataSchemasAccessor(this);
    }
    appDataSchema(id) {
        return new AppDataSchemaAccessor(this, id);
    }
    get appDataSchemaInstances() {
        return new AppDataSchemaInstancesAccessor(this);
    }
    appDataSchemaInstance(selector) {
        return new AppDataSchemaInstanceAccessor(this, selector);
    }
    customer(selector) {
        return new CustomerAccessor(this, selector);
    }
    get customers() {
        return new CustomersAccessor(this);
    }
    scenario(selector) {
        return new ScenarioAccessor(this, selector);
    }
    get scenarios() {
        return new ScenariosAccessor(this);
    }
    async connectionRequest(connectionId, uri, data) {
        return this.post(`connections/${connectionId}/execute-request`, {
            key: uri,
            payload: data,
        });
    }
}

exports.ACTIONS = ACTIONS;
exports.AccessDeniedError = AccessDeniedError;
exports.ActionAccessor = ActionAccessor;
exports.ActionInstanceAccessor = ActionInstanceAccessor;
exports.ActionInstanceSetupError = ActionInstanceSetupError;
exports.ActionInstancesAccessor = ActionInstancesAccessor;
exports.ActionRunError = ActionRunError;
exports.ActionsAccessor = ActionsAccessor;
exports.AppDataSchemaAccessor = AppDataSchemaAccessor;
exports.AppDataSchemaInstanceAccessor = AppDataSchemaInstanceAccessor;
exports.AppDataSchemaInstancesAccessor = AppDataSchemaInstancesAccessor;
exports.AppDataSchemasAccessor = AppDataSchemasAccessor;
exports.AppEventSubscriptionAccessor = AppEventSubscriptionAccessor;
exports.AppEventSubscriptionsAccessor = AppEventSubscriptionsAccessor;
exports.AppEventTypeAccessor = AppEventTypeAccessor;
exports.AppEventTypesAccessor = AppEventTypesAccessor;
exports.AppEventsAccessor = AppEventsAccessor;
exports.BadRequestError = BadRequestError;
exports.CONNECTOR_AUTH_TYPES = CONNECTOR_AUTH_TYPES;
exports.CONNECTOR_CATEGORIES = CONNECTOR_CATEGORIES;
exports.CONNECTOR_DATA_DIR = CONNECTOR_DATA_DIR;
exports.CONNECTOR_DOCS_DIR = CONNECTOR_DOCS_DIR;
exports.CONNECTOR_EVENTS_DIR = CONNECTOR_EVENTS_DIR;
exports.CONNECTOR_GLOBAL_WEBHOOKS_DIR = CONNECTOR_GLOBAL_WEBHOOKS_DIR;
exports.CONNECTOR_METHOD_IMPLEMENTATION_SUFFIXES = CONNECTOR_METHOD_IMPLEMENTATION_SUFFIXES;
exports.CONNECTOR_OPERATIONS_DIR = CONNECTOR_OPERATIONS_DIR;
exports.ConcurrencyError = ConcurrencyError;
exports.ConfigurationError = ConfigurationError;
exports.Connection = Connection;
exports.ConnectionAccessor = ConnectionAccessor;
exports.ConnectionDataCollectionAccessor = ConnectionDataCollectionAccessor;
exports.ConnectionDataDirectoryAccessor = ConnectionDataDirectoryAccessor;
exports.ConnectionError = ConnectionError;
exports.ConnectionLevelActionAccessor = ConnectionLevelActionAccessor;
exports.ConnectionLevelActionsAccessor = ConnectionLevelActionsAccessor;
exports.ConnectionLevelDataSourceAccessor = ConnectionLevelDataSourceAccessor;
exports.ConnectionLevelDataSourcesAccessor = ConnectionLevelDataSourcesAccessor;
exports.ConnectionLevelFieldMappingAccessor = ConnectionLevelFieldMappingAccessor;
exports.ConnectionLevelFieldMappingsAccessor = ConnectionLevelFieldMappingsAccessor;
exports.ConnectionLevelFlowAccessor = ConnectionLevelFlowAccessor;
exports.ConnectionLevelFlowsAccessor = ConnectionLevelFlowsAccessor;
exports.ConnectionOperationAccessor = ConnectionOperationAccessor;
exports.ConnectionProxy = ConnectionProxy;
exports.ConnectionSpec = ConnectionSpec;
exports.ConnectionsAccessor = ConnectionsAccessor;
exports.ConnectorAuthMethodTypes = ConnectorAuthMethodTypes;
exports.ConnectorDataCollectionEventImplementationType = ConnectorDataCollectionEventImplementationType;
exports.ConnectorDataCollectionMethodKeys = ConnectorDataCollectionMethodKeys;
exports.ConnectorDataDirectoryMethodKeys = ConnectorDataDirectoryMethodKeys;
exports.ConnectorDataLocationTypes = ConnectorDataLocationTypes;
exports.ConnectorEventHandlerMethods = ConnectorEventHandlerMethods;
exports.ConnectorOperationMethodImplementationTypes = ConnectorOperationMethodImplementationTypes;
exports.CopilotActivityScope = CopilotActivityScope;
exports.CreateConnectionRequest = CreateConnectionRequest;
exports.CustomerAccessor = CustomerAccessor;
exports.CustomersAccessor = CustomersAccessor;
exports.DATA_RECORD_SCHEMA = DATA_RECORD_SCHEMA;
exports.DEFAULT_FULL_SYNC_INTERVAL_SECONDS = DEFAULT_FULL_SYNC_INTERVAL_SECONDS;
exports.DEFAULT_PULL_UPDATES_INTERVAL_SECONDS = DEFAULT_PULL_UPDATES_INTERVAL_SECONDS;
exports.DataField = DataField;
exports.DataFilterCondition = DataFilterCondition;
exports.DataForm = DataForm;
exports.DataLinkTableAccessor = DataLinkTableAccessor;
exports.DataLinkTableInstanceAccessor = DataLinkTableInstanceAccessor;
exports.DataLinkTableInstancesAccessor = DataLinkTableInstancesAccessor;
exports.DataLinkTablesAccessor = DataLinkTablesAccessor;
exports.DataLocationMethodImplementationTypes = DataLocationMethodImplementationTypes;
exports.DataLocationTypeCollection = DataLocationTypeCollection;
exports.DataLocationTypeDirectory = DataLocationTypeDirectory;
exports.DataLocatorStep = DataLocatorStep;
exports.DataLocatorStepArrayItem = DataLocatorStepArrayItem;
exports.DataLocatorStepObjectProperty = DataLocatorStepObjectProperty;
exports.DataSourceAccessor = DataSourceAccessor;
exports.DataSourceInstanceAccessor = DataSourceInstanceAccessor;
exports.DataSourceInstancesAccessor = DataSourceInstancesAccessor;
exports.DataSourcesAccessor = DataSourcesAccessor;
exports.DependencyError = DependencyError;
exports.EDITABLE_LIMITS = EDITABLE_LIMITS;
exports.ElementAccessor = ElementAccessor;
exports.ElementInstanceAccessor = ElementInstanceAccessor;
exports.ElementInstanceListAccessor = ElementInstanceListAccessor;
exports.ElementListAccessor = ElementListAccessor;
exports.ErrorData = ErrorData;
exports.ExternalEventSubscriptionAccessor = ExternalEventSubscriptionAccessor;
exports.ExternalEventSubscriptionsAccessor = ExternalEventSubscriptionsAccessor;
exports.FLOW_NODE_SPECS = FLOW_NODE_SPECS;
exports.FieldMappingAccessor = FieldMappingAccessor;
exports.FieldMappingInstanceAccessor = FieldMappingInstanceAccessor;
exports.FieldMappingInstancesAccessor = FieldMappingInstancesAccessor;
exports.FieldMappingsAccessor = FieldMappingsAccessor;
exports.FindConnectionsResponse = FindConnectionsResponse;
exports.FlowAccessor = FlowAccessor;
exports.FlowInstanceAccessor = FlowInstanceAccessor;
exports.FlowInstanceSetupError = FlowInstanceSetupError;
exports.FlowInstancesAccessor = FlowInstancesAccessor;
exports.FlowNodeSpec = FlowNodeSpec;
exports.FlowRunAccessor = FlowRunAccessor;
exports.FlowRunError = FlowRunError;
exports.FlowRunsAccessor = FlowRunsAccessor;
exports.FlowsAccessor = FlowsAccessor;
exports.Formula = index;
exports.HTTP_REQUEST_SCHEMA = HTTP_REQUEST_SCHEMA;
exports.IDataField = IDataField;
exports.IntegrationAccessor = IntegrationAccessor;
exports.IntegrationAppClient = IntegrationAppClient;
exports.IntegrationAppError = IntegrationAppError;
exports.IntegrationLevelActionAccessor = IntegrationLevelActionAccessor;
exports.IntegrationLevelActionsListAccessor = IntegrationLevelActionsListAccessor;
exports.IntegrationLevelDataSourceAccessor = IntegrationLevelDataSourceAccessor;
exports.IntegrationLevelDataSourcesListAccessor = IntegrationLevelDataSourcesListAccessor;
exports.IntegrationLevelFieldMappingAccessor = IntegrationLevelFieldMappingAccessor;
exports.IntegrationLevelFieldMappingsListAccessor = IntegrationLevelFieldMappingsListAccessor;
exports.IntegrationLevelFlowAccessor = IntegrationLevelFlowAccessor;
exports.IntegrationLevelFlowsListAccessor = IntegrationLevelFlowsListAccessor;
exports.IntegrationsAccessor = IntegrationsAccessor;
exports.InternalError = InternalError;
exports.InvalidLocatorError = InvalidLocatorError;
exports.MIN_FULL_SYNC_INTERVAL_SECONDS = MIN_FULL_SYNC_INTERVAL_SECONDS;
exports.MIN_PULL_UPDATES_INTERVAL_SECONDS = MIN_PULL_UPDATES_INTERVAL_SECONDS;
exports.NotAuthenticatedError = NotAuthenticatedError;
exports.NotFoundError = NotFoundError;
exports.OAUTH1_CONFIG_SCHEMA = OAUTH1_CONFIG_SCHEMA;
exports.OAUTH_CONFIG_SCHEMA = OAUTH_CONFIG_SCHEMA;
exports.PARALLEL_EXECUTION_LIMITS = PARALLEL_EXECUTION_LIMITS;
exports.PaginationResponse = PaginationResponse;
exports.RATE_LIMITS = RATE_LIMITS;
exports.RateLimitExceededError = RateLimitExceededError;
exports.ScenarioAccessor = ScenarioAccessor;
exports.ScenariosAccessor = ScenariosAccessor;
exports.ScreenAccessor = ScreenAccessor;
exports.ScreensAccessor = ScreensAccessor;
exports.SelfAccessor = SelfAccessor;
exports.UNIFIED_DATA_MODELS = UNIFIED_DATA_MODELS;
exports.UnitRunError = UnitRunError;
exports.UpdateConnectionRequest = UpdateConnectionRequest;
exports.WORKSPACE_SIZE_LIMITS = WORKSPACE_SIZE_LIMITS;
exports.WorkspaceElementSpecs = WorkspaceElementSpecs;
exports.addRequiredFieldsToSchema = addRequiredFieldsToSchema;
exports.addUdmFallbackFields = addUdmFallbackFields;
exports.backwardCompatibleFilterMatch = backwardCompatibleFilterMatch;
exports.buildData = buildData;
exports.buildDataSchema = buildDataSchema;
exports.buildUserFriendlyErrorMessage = buildUserFriendlyErrorMessage;
exports.compressDataSchema = compressDataSchema;
exports.createCompoundSchema = createCompoundSchema;
exports.createFlowInstanceSchema = createFlowInstanceSchema;
exports.createObjectFromLocators = createObjectFromLocators;
exports.createSchema = createSchema;
exports.dataCollectionEventTypeToExternalEventType = dataCollectionEventTypeToExternalEventType;
exports.dataLocationParametersMatch = dataLocationParametersMatch;
exports.doesMatchFilter = doesMatchFilter;
exports.excludeFieldsFromSchema = excludeFieldsFromSchema;
exports.excludeFieldsFromValue = excludeFieldsFromValue;
exports.excludeReadOnlyFieldsFromSchema = excludeReadOnlyFieldsFromSchema;
exports.excludeWriteOnlyFieldsFromSchema = excludeWriteOnlyFieldsFromSchema;
exports.externalEventTypeToDataCollectionEventType = externalEventTypeToDataCollectionEventType;
exports.externalEventTypeToSubscriptionType = externalEventTypeToSubscriptionType;
exports.extractFieldLocator = extractFieldLocator;
exports.extractIntegrationAppErrorData = extractIntegrationAppErrorData;
exports.findUdmCollectionMapping = findUdmCollectionMapping;
exports.findUdmDefaultCollection = findUdmDefaultCollection;
exports.findUdmRootLocation = findUdmRootLocation;
exports.findValueLocators = findValueLocators;
exports.generateExampleFromSchema = generateExampleFromSchema;
exports.getActionInstanceVariableSchema = getActionInstanceVariableSchema;
exports.getActionRunTimeVariablesSchema = getActionRunTimeVariablesSchema;
exports.getAllEventMethodFilePaths = getAllEventMethodFilePaths;
exports.getChildNodeKeys = getChildNodeKeys;
exports.getDataCollectionCreateFields = getDataCollectionCreateFields;
exports.getDataCollectionUpdateFields = getDataCollectionUpdateFields;
exports.getDataLocationMethodPath = getDataLocationMethodPath;
exports.getDownstreamNodeKeys = getDownstreamNodeKeys;
exports.getErrorFromData = getErrorFromData;
exports.getEventMethodFileKey = getEventMethodFileKey;
exports.getFilterFieldValuesByLocator = getFilterFieldValuesByLocator;
exports.getFlowInstanceNodeDependency = getFlowInstanceNodeDependency;
exports.getFlowNode = getFlowNode;
exports.getFlowNodeConfigTimeVariablesSchema = getFlowNodeConfigTimeVariablesSchema;
exports.getFlowNodeDescription = getFlowNodeDescription;
exports.getFlowNodeRunTimeVariablesSchema = getFlowNodeRunTimeVariablesSchema;
exports.getFlowNodeSpec = getFlowNodeSpec;
exports.getFlowNodeTitle = getFlowNodeTitle;
exports.getFormula = getFormula;
exports.getFormulaLocators = getFormulaLocators;
exports.getFullNameForLocator = getFullNameForLocator;
exports.getFullTitleForLocator = getFullTitleForLocator;
exports.getIconUriForLocator = getIconUriForLocator;
exports.getLocatorsFromData = getLocatorsFromData;
exports.getLocatorsFromSchema = getLocatorsFromSchema;
exports.getMissingRequiredFields = getMissingRequiredFields;
exports.getNameComponentsForLocator = getNameComponentsForLocator;
exports.getNameForLocator = getNameForLocator;
exports.getNodeInputSchema = getNodeInputSchema;
exports.getOperatorsBySchema = getOperatorsBySchema;
exports.getParentNodeKeys = getParentNodeKeys;
exports.getReferenceCollectionPathForSchema = getReferenceCollectionPathForSchema;
exports.getReferenceCollectionPointerForSchema = getReferenceCollectionPointerForSchema;
exports.getRequiredFieldsFromSchema = getRequiredFieldsFromSchema;
exports.getRootNodeKeys = getRootNodeKeys;
exports.getSchemaByLocator = getSchemaByLocator;
exports.getSchemaFromValue = getSchemaFromValue;
exports.getUpstreamNodeKeys = getUpstreamNodeKeys;
exports.getValueAtLocator = getValueAtLocator;
exports.getValueByLocator = getValueByLocator;
exports.getVariableLocators = getVariableLocators;
exports.getWritableFieldsSchema = getWritableFieldsSchema;
exports.hasCycles = hasCycles;
exports.hasFormulas = hasFormulas;
exports.isDataActionType = isDataActionType;
exports.isDataLocationMethodSupported = isDataLocationMethodSupported;
exports.isFormula = isFormula;
exports.isIntegrationAppError = isIntegrationAppError;
exports.isObject = isObject;
exports.isSameDataLocation = isSameDataLocation;
exports.isSchemaEmpty = isSchemaEmpty;
exports.isStream = isStream;
exports.isValidLocator = isValidLocator;
exports.locatorToField = locatorToField;
exports.locatorToSteps = locatorToSteps;
exports.locatorToString = locatorToString;
exports.makeDataLocationOperationPath = makeDataLocationOperationPath;
exports.makeDataLocationPath = makeDataLocationPath;
exports.makeDataRecordSchema = makeDataRecordSchema;
exports.makeObjectPropertyLocator = makeObjectPropertyLocator;
exports.makeSchemaForLocator = makeSchemaForLocator;
exports.mergeSchemas = mergeSchemas;
exports.mergeWithFormulas = mergeWithFormulas;
exports.nonEmptyObjectProperties = nonEmptyObjectProperties;
exports.parseDataLocationPath = parseDataLocationPath;
exports.parseDate = parseDate;
exports.patchSchema = patchSchema;
exports.pickFieldsFromSchema = pickFieldsFromSchema;
exports.pickFieldsFromValue = pickFieldsFromValue;
exports.populateSchemaTitles = populateSchemaTitles;
exports.processCopy = processCopy;
exports.processValue = processValue;
exports.removeNonExistentVars = removeNonExistentVars;
exports.removeRequiredFieldsFromSchema = removeRequiredFieldsFromSchema;
exports.resolveFormulas = resolveFormulas;
exports.resolveValue = resolveValue;
exports.schemaAllowsCustomValue = schemaAllowsCustomValue;
exports.schemaHasFixedValues = schemaHasFixedValues;
exports.schemaHasProperties = schemaHasProperties;
exports.schemaIsNumber = schemaIsNumber;
exports.schemaIsScalar = schemaIsScalar;
exports.schemaTypeFromValue = schemaTypeFromValue;
exports.schemaWithTitle = schemaWithTitle;
exports.setSchemaAtLocator = setSchemaAtLocator;
exports.setValueAtLocator = setValueAtLocator;
exports.stepsToLocator = stepsToLocator;
exports.streamToString = streamToString;
exports.transformVariablesWith = transformVariablesWith;
exports.transformVars = transformVars;
exports.truncateData = truncateData;
exports.unwrapSchema = unwrapSchema;
exports.unwrapSchemas = unwrapSchemas;
exports.updateFlowInstanceSchema = updateFlowInstanceSchema;
exports.updateImpliedSchema = updateImpliedSchema;
exports.valueToSchema = valueToSchema;
exports.valueToString = valueToString;
exports.walkSchema = walkSchema;
exports.wrapAnyOfSchema = wrapAnyOfSchema;
//# sourceMappingURL=index.js.map
