import { AxiosRequestConfig } from 'axios';
import { z } from 'zod';

interface IntegrationAppClientOptions {
    token?: string;
    fetchToken?: () => Promise<string>;
    credentials?: any;
    fetchCredentials?: () => Promise<any>;
    apiUri?: string;
    uiUri?: string;
    accessToken?: string;
}
declare class IntegrationAppApiClient {
    apiUri: string;
    uiUri: string;
    token?: string;
    protected fetchToken?: () => Promise<string>;
    constructor({ uiUri, apiUri, accessToken, token, fetchToken, fetchCredentials, credentials, }?: IntegrationAppClientOptions);
    setCredentials(credentials: any): Promise<any>;
    getToken(): Promise<string>;
    get(uri: string, queryParams?: Record<string, any>, options?: AxiosRequestConfig): Promise<any>;
    post(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    put(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    patch(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    delete(uri: string, data?: any, options?: AxiosRequestConfig): Promise<any>;
    getEmbedUri(page: string, params?: Record<string, any>): Promise<string>;
    private makeApiRequest;
    private handleRequestError;
}

type CommonListElementsQuery = SearchQuery & PaginationQuery & IncludeArchivedQuery;
type CommonInstancesListQuery = CommonListElementsQuery & {
    userId?: string;
    instanceKey?: string;
};
type CommonIntegrationOrConnectionQuery = {
    connectionId?: string;
    integrationId?: string;
    integrationKey?: string;
};
type IncludeArchivedQuery = {
    includeArchived?: boolean;
};
type SearchQuery = {
    search?: string;
};
type PaginationQuery = {
    limit?: number;
    cursor?: string;
};
declare class PaginationResponse<T> {
    items: T[];
    cursor?: string;
}

declare enum ErrorDoc {
    AuthenticationTokenErrors = "authentication-token-errors",
    DataSourceNoCollectionSelected = "data-source-no-collection-selected",
    FlowInstanceSetupFailed = "flow-instance-setup-failed",
    FlowInstanceSetupTimeout = "flow-instance-setup-timeout",
    WebhookCannotFindUser = "webhook-cannot-find-user"
}

declare enum ErrorType {
    BAD_REQUEST = "bad_request",
    CONNECTION = "connection",
    CONFIGURATION = "configuration",
    DEPENDENCY_ERROR = "dependency_error",
    FLOW_RUN = "flow_run",
    FLOW_INSTANCE_SETUP = "flow_instance_setup",
    CONCURRENCY = "concurrency",
    INTERNAL = "internal",
    ACTION_RUN = "action_run",
    ACTION_INSTANCE_SETUP = "action_instance_setup",
    UNIT_RUN = "unit_run"
}
interface ErrorDataFields {
    type?: ErrorType;
    key?: string;
    message: string;
    data?: any;
    doc?: ErrorDoc;
    stack?: any;
    causedByError?: ErrorData;
    logs?: any[];
}
type ErrorConstructorArg = string | ErrorDataFields | Error;
declare class ErrorData implements ErrorDataFields {
    constructor(arg: ErrorConstructorArg);
}
interface ErrorData extends ErrorDataFields {
}

declare enum WorkspaceElementType {
    Customer = "customer",
    Connector = "connector",
    Integration = "integration",
    Flow = "flow",
    FlowInstance = "flow-instance",
    FlowRun = "flow-run",
    Action = "action",
    Scenario = "scenario",
    ActionInstance = "action-instance",
    Connection = "connection",
    FieldMapping = "field-mapping",
    FieldMappingInstance = "field-mapping-instance",
    DataSource = "data-source",
    DataSourceInstance = "data-source-instance",
    DataLinkTable = "data-link-table",
    DataLinkTableInstance = "data-link-table-instance",
    AppEventType = "app-event-type",
    AppEventSubscription = "app-event-subscription",
    AppDataSchema = "app-data-schema",
    AppDataSchemaInstance = "app-data-schema-instance",
    ExternalEventSubscription = "external-event-subscription",
    ExternalEventLogRecord = "external-event-log-record",
    ExternalEventPull = "external-event-pull",
    Screen = "screen"
}
declare enum WorkspaceElementState {
    SETTING_UP = "SETTING_UP",
    CONFIGURATION_ERROR = "CONFIGURATION_ERROR",
    SETUP_FAILED = "SETUP_FAILED",
    READY = "READY"
}
declare enum WorkspaceElementDependencyType {
    Configuration = "CONFIGURATION",
    Parent = "PARENT"
}
interface WorkspaceElementReference {
    type: WorkspaceElementType;
    id: string;
}
interface WorkspaceElementDependency extends WorkspaceElementReference {
    dependencyType: WorkspaceElementDependencyType;
    data?: unknown;
}

interface BaseElementInstance {
    id: string;
}
interface ElementInstanceSelector {
    id?: string;
    autoCreate?: boolean;
    instanceKey?: string;
    userId?: string;
    parentKey?: string;
    parentId?: string;
}
interface IntegrationSpecificElementSelector {
    id?: string;
    key?: string;
    integrationId?: string;
    integrationKey?: string;
}
type SelectorType = {
    id?: string;
} | string;
declare class ElementAccessor<Element, UpdateRequest, Selector extends SelectorType = string> {
    protected options: {
        client: IntegrationAppApiClient;
        path: string;
        selector: string | Selector;
    };
    constructor(options: {
        client: IntegrationAppApiClient;
        path: string;
        selector: string | Selector;
    });
    getUniqueIdentifier(): string;
    get(): Promise<Element>;
    put(data: UpdateRequest): Promise<Element>;
    patch(data: Partial<UpdateRequest>): Promise<Element>;
    archive(): Promise<void>;
    getPath(operation?: string): string;
}
declare class ElementListAccessor<Element, FindQuery, CreateRequest> {
    private client;
    private path;
    constructor(client: IntegrationAppApiClient, path: string);
    find(query?: FindQuery): Promise<PaginationResponse<Element>>;
    findAll(query?: Omit<FindQuery, 'limit'>): Promise<Element[]>;
    create(data: CreateRequest): Promise<Element>;
}
declare class ElementInstanceListAccessor<ElementInstance extends BaseElementInstance, FindQuery> {
    protected client: IntegrationAppApiClient;
    private path;
    constructor(client: IntegrationAppApiClient, path: string);
    find(query?: FindQuery): Promise<PaginationResponse<ElementInstance>>;
}
declare class ElementInstanceAccessor<ElementInstance extends BaseElementInstance, Selector extends {
    id?: string;
}, CreateRequest, UpdateRequest> {
    protected options: {
        client: IntegrationAppApiClient;
        instancePath: string;
        selector: string | Selector;
        type?: WorkspaceElementType;
    };
    private id;
    constructor(options: {
        client: IntegrationAppApiClient;
        instancePath: string;
        selector: string | Selector;
        type?: WorkspaceElementType;
    });
    getUniqueIdentifier(): string;
    get(): Promise<ElementInstance>;
    getId(): Promise<string>;
    create(data?: CreateRequest): Promise<ElementInstance>;
    put(data: CreateRequest): Promise<ElementInstance>;
    patch(data: UpdateRequest): Promise<ElementInstance>;
    archive(): Promise<void>;
    delete(): Promise<void>;
    protected getPath(operation?: string): string;
    private getSelector;
}

interface FindConnectionsQuery extends PaginationQuery {
    userId?: string;
    isTest?: boolean;
    integrationKey?: string;
    integrationId?: string;
    includeArchived?: boolean;
}
declare class CreateConnectionRequest {
    name: string;
    integrationId: string;
    credentials?: string;
}
declare class UpdateConnectionRequest {
    name?: string;
    credentials?: string;
    accessToken?: string;
}
interface ConnectionSelector {
    id?: string;
    integrationKey?: string;
    integrationId?: string;
    connectionId?: string;
}

interface DataRecord {
    id: string;
    name?: string;
    uri?: string;
    iconUri?: string;
    fields?: Record<string, any>;
    udm?: string;
    unifiedFields?: Record<string, any>;
    rawFields?: Record<string, any>;
    createdTime?: string;
    updatedTime?: string;
    deletedTime?: string;
    createdById?: string;
    updatedById?: string;
}
declare enum DataCollectionEventType {
    CREATED = "created",
    UPDATED = "updated",
    DELETED = "deleted"
}

interface DataSchema {
    title?: string;
    description?: string;
    type?: string | string[];
    format?: string;
    properties?: {
        [key: string]: DataSchema;
    };
    items?: DataSchema;
    additionalProperties?: boolean | DataSchema;
    enum?: string[];
    referenceRecords?: DataRecord[];
    referenceCollection?: {
        key: any;
        parameters?: Record<string, any>;
    };
    referenceUdm?: string;
    default?: any;
    allowCustom?: boolean;
    $ref?: string;
    required?: string[];
    minLength?: number;
    maxLength?: number;
    minimum?: number;
    maximum?: number;
    maxItems?: number;
    readOnly?: boolean;
    writeOnly?: boolean;
    examples?: any[];
    anyOf?: DataSchema[];
    isImplied?: boolean;
    referenceCollectionPath?: string;
    referenceCollectionUri?: string;
}

declare enum HttpRequestMethod {
    GET = "GET",
    POST = "POST",
    PATCH = "PATCH",
    PUT = "PUT",
    DELETE = "DELETE"
}
interface HttpRequestSpec {
    method?: HttpRequestMethod;
    uri: any;
    headers?: Record<string, any>;
    query?: Record<string, any>;
    body?: any;
}

interface GraphQLApiMapping {
    path: string;
    operationType: 'query' | 'mutation';
    requestMapping: GraphQLFieldMapping[];
    responseMapping?: any;
}
interface GraphQLFieldMapping {
    field: string;
    args?: Record<string, any>;
    subFields?: GraphQLFieldMapping[];
}

interface OperationBase {
    key: string;
    name: string;
    isReadOnly?: boolean;
    description?: string;
    tags?: string[];
}
interface OperationListItem extends OperationBase {
}
interface OperationSpec extends OperationBase {
    inputSchema?: any;
    outputSchema?: any;
    isReadOnly?: boolean;
}
interface OperationRunRequest {
    input: any;
}
interface OperationRunResponse {
    output?: any;
}
interface OperationMapping {
    operationKey: string;
    inputMapping?: any;
    outputMapping?: any;
}

type ConnectorOperationMethod<ImplementationFields extends ConnectorMethodImplementation | ConnectorMethodImplementationBase = ConnectorMethodImplementationBase> = {
    isIncomplete?: boolean;
} & ImplementationFields;
interface ConnectorOperationHandler extends OperationSpec {
    methods?: Record<'run', ConnectorOperationMethod>;
}

interface RestApiMapping {
    path: string;
    method: string;
    requestMapping: {
        pathParameters?: any;
        query?: any;
        data?: any;
        headers?: any;
    };
    responseMapping?: any;
}

declare enum ConnectorMethodImplementationType {
    mapping = "mapping",
    operationMapping = "operation-mapping",
    restApiMapping = "rest-api-mapping",
    graphqlApiMapping = "graphql-api-mapping",
    javascript = "javascript",
    notSupported = "not-supported"
}
type ConnectorMethodImplementation = ConnectorMethodImplementationBase | ConnectorMethodImplementationMapping | ConnectorMethodImplementationOperationMapping | ConnectorMethodImplementationRestApiMapping | ConnectorMethodImplementationGraphqlApiMapping | ConnectorMethodImplementationJavascript | ConnectorMethodImplementationNotSupported;
interface ConnectorMethodImplementationBase {
    implementationType?: ConnectorMethodImplementationType;
    filePath?: string;
    inheritedFromPath?: string[];
    isIncomplete?: boolean;
    parametersSchema?: DataSchema;
}
interface ConnectorMethodImplementationMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.mapping;
    mapping: any;
}
interface ConnectorMethodImplementationOperationMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.operationMapping;
    mapping: OperationMapping;
}
interface ConnectorMethodImplementationRestApiMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.restApiMapping;
    mapping: RestApiMapping;
}
interface ConnectorMethodImplementationGraphqlApiMapping extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.graphqlApiMapping;
    mapping: GraphQLApiMapping;
}
interface ConnectorMethodImplementationJavascript extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.javascript;
    code: string;
}
interface ConnectorMethodImplementationNotSupported extends ConnectorMethodImplementationBase {
    implementationType: ConnectorMethodImplementationType.notSupported;
}

type DataLocationSpec = DataCollectionSpec | DataDirectorySpec;
declare enum DataLocationType {
    directory = "directory",
    collection = "collection"
}
interface DataLocationListItem {
    key: string;
    name: string;
    type: DataLocationType;
    isHidden?: boolean;
}
interface DataLocationPointer {
    key: string;
    parameters?: Record<string, any>;
    type?: DataLocationType;
}
interface DataLocation {
    key?: string;
    parameters?: any;
    path?: string;
    name?: string;
    type?: DataLocationType;
    isDefault?: boolean;
    read?: boolean;
    write?: boolean;
}
interface DataLocationSpecBase {
    type: DataLocationType;
    key?: string;
    name: string;
    parametersSchema?: DataSchema;
}
interface DataCollectionSpec extends DataLocationSpecBase {
    fieldsSchema?: DataSchema;
    list?: DataCollectionListSpec;
    search?: DataCollectionSearchSpec;
    match?: DataCollectionMatchSpec;
    findById?: DataCollectionFindByIdSpec;
    create?: DataCollectionCreateSpec;
    update?: DataCollectionUpdateSpec;
    delete?: DataCollectionDeleteSpec;
    events?: DataCollectionEventsSpec;
    customFields?: boolean;
    udm?: DataCollectionUdmsSpec;
    find?: DataCollectionFindSpec;
}
interface ApiRequestSpec {
    path: any;
    method: any;
}
interface DataDirectorySpec extends DataLocationSpecBase {
    locations?: DataLocation[];
}
interface DataCollectionMethodSpec {
    apiRequests?: ApiRequestSpec[];
}
interface DataCollectionFindSpec extends DataCollectionMethodSpec {
    queryFields?: string[];
}
interface DataCollectionMatchSpec extends DataCollectionMethodSpec {
    fields?: string[];
}
interface DataCollectionListSpec extends DataCollectionMethodSpec {
    filterFields?: string[];
}
interface DataCollectionSearchSpec extends DataCollectionMethodSpec {
}
interface DataCollectionFindByIdSpec extends DataCollectionMethodSpec {
}
interface DataCollectionCreateSpec extends DataCollectionMethodSpec {
    fields?: string[];
    requiredFields?: string[];
    excludedFields?: string[];
}
interface DataCollectionUpdateSpec extends DataCollectionMethodSpec {
    fields?: string[];
    excludedFields?: string[];
}
interface DataCollectionDeleteSpec extends DataCollectionMethodSpec {
}
type DataCollectionUdmSpec = {
    fields?: string[];
    extract?: Record<string, any>;
    parse?: Record<string, any>;
};
type DataCollectionUdmsSpec = Record<string, DataCollectionUdmSpec>;
type DataCollectionEventTypeSpec = {
    type: 'push' | 'pull';
    isFullScan?: boolean;
    isIdOnly?: boolean;
};
type DataCollectionEventsSpec = {
    [value in DataCollectionEventType]: DataCollectionEventTypeSpec;
} & {
    all?: DataCollectionEventTypeSpec;
};
interface DataCollectionMethodRequest {
    parameters?: Record<string, any>;
}
interface DataCollectionFindRequest {
    query?: any;
    cursor?: string;
}
interface DataCollectionFindResponse {
    records: DataRecord[];
    cursor?: string;
}
interface DataCollectionListRequest extends DataCollectionMethodRequest {
    filter?: any;
    unifiedFilter?: any;
    cursor?: string;
}
interface DataCollectionListResponseDrilldown {
    parameters?: Record<string, any>;
    filter?: Record<string, any>;
}
interface DataCollectionListResponse {
    records: DataRecord[];
    drilldowns?: Array<DataCollectionListResponseDrilldown>;
    cursor?: string;
}
interface DataCollectionSearchRequest extends DataCollectionMethodRequest {
    query: string;
    cursor?: string;
}
interface DataCollectionSearchResponse {
    records: DataRecord[];
    cursor?: string;
}
interface DataCollectionFindByIdRequest extends DataCollectionMethodRequest {
    id: string;
    udm?: string;
}
interface DataCollectionFindByIdResponse {
    record: DataRecord;
}
interface DataCollectionMatchRequest extends DataCollectionMethodRequest {
    query: Record<string, any>;
}
interface DataCollectionMatchResponse {
    record?: DataRecord;
}
interface DataCollectionCreateRequest extends DataCollectionMethodRequest {
    fields: Record<string, any>;
}
interface DataCollectionCreateResponse {
    id: string;
}
interface DataCollectionUpdateRequest extends DataCollectionMethodRequest {
    id: string;
    fields: Record<string, any>;
}
interface DataCollectionUpdateResponse {
    id: string;
}
interface DataCollectionDeleteRequest extends DataCollectionMethodRequest {
    id: string;
}
interface DataCollectionDeleteResponse {
}
interface DataDirectoryListRequest {
    cursor?: string;
}
interface DataDirectoryListResponse {
    locations: DataLocation[];
    cursor?: string;
}

declare enum UDM {
    ACTIVITIES = "activities",
    BILLS = "bills",
    CAMPAIGN_MEMBERS = "campaign-members",
    CAMPAIGNS = "campaigns",
    COMPANIES = "companies",
    CONTACTS = "contacts",
    CONTACT_LISTS = "contact-lists",
    CREDIT_NOTES = "credit-notes",
    CUSTOMERS = "customers",
    DEAL_PRODUCTS = "deal-products",
    DEALS = "deals",
    DEAL_STAGES = "deal-stages",
    DOCUMENTS = "documents",
    DRIVES = "drives",
    DRIVE_ITEMS = "drive-items",
    EEOCS = "eeocs",
    EMAILS = "emails",
    EMPLOYEES = "employees",
    FILES = "files",
    FOLDERS = "folders",
    INVOICES = "invoices",
    JOB_APPLICATIONS = "job-applications",
    JOB_CANDIDATES = "job-candidates",
    JOB_INTERVIEWS = "job-interviews",
    JOB_OFFERS = "job-offers",
    JOBS = "jobs",
    JOURNAL_ENTRIES = "journal-entries",
    LEADS = "leads",
    LEDGER_ACCOUNTS = "ledger-accounts",
    MEETINGS = "meetings",
    MESSAGES = "messages",
    NOTES = "notes",
    ORDERS = "orders",
    PAYMENTS = "payments",
    PAYROLLS = "payrolls",
    PRODUCTS = "products",
    PROJECTS = "projects",
    SUPPLIERS = "suppliers",
    TASKS = "tasks",
    TAX_RATES = "tax-rates",
    USERS = "users",
    TIMEOFF_BALANCES = "timeoff-balances",
    TIMEOFF_REQUESTS = "timeoff-requests"
}

interface ConnectorUdmSpec {
    defaultCollection?: DataLocationPointer;
    rootDirectory?: DataLocationPointer;
    collectionMappings: ConnectorUdmCollectionMapping[];
}
interface ConnectorUdmCollectionMapping extends DataLocationPointer {
    fieldsToCollection?: any;
    fieldsFromCollection?: any;
}

interface ConnectorUiSpec {
    schema?: DataSchema;
    description?: string;
    helpUri?: string;
    test?: boolean;
}
type ConnectorDataUdmSpec = {
    rootLocation: DataLocation;
};
type ConnectorDataSpec = {
    rootLocation?: DataLocation;
    locations?: DataLocationSpec[];
    udm?: Partial<Record<UDM, ConnectorDataUdmSpec>>;
    root?: DataLocation;
} & Partial<Record<UDM, DataLocation>>;
type ConnectorApiType = 'openapi' | 'graphql';
interface ConnectorSpec {
    key?: string;
    name?: string;
    appUri?: string;
    logoUri?: string;
    apiDocsUri?: string;
    api?: {
        type: ConnectorApiType;
    };
    ui?: ConnectorUiSpec;
    auth?: ConnectorAuth;
    parametersSchema?: DataSchema;
    data?: ConnectorDataSpec;
    udms?: string[];
    udm?: Record<string, ConnectorUdmSpec>;
    operations?: ConnectorOperationHandler[];
    test?: ConnectorMethodImplementation;
    hasReadme?: boolean;
    appUuid?: string;
    knowledgeBaseUuid?: string;
    workspaceId?: string;
}
type MinimalConnector = {
    id: string;
    key: string;
    name: string;
    logoUri: string;
};

declare const CONNECTOR_AUTH_TYPES: readonly ["integration-app-token", "oauth2", "oauth1", "client-credentials", "proxy"];
type ConnectorAuthType = (typeof CONNECTOR_AUTH_TYPES)[number];
type ConnectorAuthSpec = {
    title?: string;
    description?: string;
    type: ConnectorAuthType;
    ui?: {
        schema?: DataSchema;
        helpUri?: string;
    };
};
interface ConnectorAuthHandlerBase extends ConnectorAuthSpec {
    title?: string;
    type: ConnectorAuthType;
    credentialsSchema?: DataSchema;
    customCredentialsSchema?: DataSchema;
    makeApiClient?: ConnectorMethodImplementationBase;
    refreshCredentials?: ConnectorMethodImplementationBase;
    test?: ConnectorMethodImplementationBase;
    enabled?: any;
}
interface ConnectorAuthOAuth2 extends ConnectorAuthHandlerBase {
    type: 'oauth2';
    getOAuthConfig?: ConnectorMethodImplementation;
    getTokenData?: ConnectorMethodImplementation;
    getCredentialsFromAccessTokenResponse?: ConnectorMethodImplementation;
    getCredentialsFromRefreshTokenResponse?: ConnectorMethodImplementation;
    oAuthConfig?: ConnectorMethodImplementation;
}
interface ConnectorAuthOAuth1 extends ConnectorAuthHandlerBase {
    type: 'oauth1';
    getOAuthConfig?: ConnectorMethodImplementation;
}
interface ConnectorAuthClientCredentials extends ConnectorAuthHandlerBase {
    type: 'client-credentials';
    getCredentialsFromConnectionParameters?: ConnectorMethodImplementationBase;
}
interface ConnectorAuthProxy extends ConnectorAuthHandlerBase {
    type: 'proxy';
    proxyKey: string;
}
interface ConnectorAuthIntegrationAppToken extends ConnectorAuthHandlerBase {
    type: 'integration-app-token';
}
type ConnectorAuth = (ConnectorAuthOAuth2 | ConnectorAuthOAuth1 | ConnectorAuthClientCredentials | ConnectorAuthIntegrationAppToken | ConnectorAuthProxy) & {
    options?: {
        [key: string]: ConnectorAuthOAuth2 | ConnectorAuthOAuth1 | ConnectorAuthClientCredentials | ConnectorAuthIntegrationAppToken | ConnectorAuthProxy;
    };
};

interface OpenConfigurationOptions {
    onClose?: () => void;
    showPoweredBy?: boolean;
}

interface Integration {
    id: string;
    name: string;
    key: string;
    state?: WorkspaceElementState;
    errors?: ErrorData[];
    logoUri: string;
    connectorId?: string;
    connectorVersion?: string;
    authOptions?: IntegrationAuthOption[];
    oAuthCallbackUri?: string;
    parametersSchema?: DataSchema;
    parameters?: any;
    baseUri: string;
    connection?: Connection;
    archivedAt?: string;
    areParametersCustomized?: boolean;
    spec?: ConnectorSpec;
    hasMissingParameters?: boolean;
    hasDefaultParameters?: boolean;
    hasDocumentation?: boolean;
    hasOperations?: boolean;
    hasData?: boolean;
    hasEvents?: boolean;
    hasGlobalWebhooks?: boolean;
    hasUdm?: boolean;
    isTest?: boolean;
    appUuid?: string;
    isDeactivated?: boolean;
    authType?: ConnectorAuthType;
}
type IntegrationAuthOption = ConnectorAuthSpec & {
    key: string;
};
type AppliedToIntegrations<Element> = {
    element: Element;
    integration: Integration;
}[];

interface CreateIntegrationRequest {
    name?: string;
    key: string;
    baseUri: string;
    logoUri: string;
}
interface UpdateIntegrationRequest {
    name?: string;
    key?: string;
    baseUri?: string;
    logoUri?: string;
}
interface FindIntegrationsQuery extends PaginationQuery, SearchQuery {
}
interface OpenNewConnectionOptions extends OpenConfigurationOptions {
    allowMultipleConnections?: boolean;
    name?: string;
}

type CreateCustomerRequest = {
    name?: string;
    internalId: string;
    fields?: any;
    credentials?: any;
};
type UpdateCustomerRequest = {
    name?: string;
    internalId?: string;
    fields?: any;
    credentials?: any;
};
type FindCustomersQuery = PaginationQuery & SearchQuery & {
    isTest?: boolean;
};
type CustomerSelector = {
    id: string;
};

declare class CustomersAccessor extends ElementListAccessor<Customer, FindCustomersQuery, CreateCustomerRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class CustomerAccessor extends ElementAccessor<Customer, UpdateCustomerRequest, CustomerSelector> {
    constructor(client: IntegrationAppApiClient, selector: CustomerSelector | string);
}

type Customer = {
    id: string;
    name: string;
    internalId: string;
    fields?: Record<string, any>;
    credentials?: any;
    lastActiveAt?: string;
    isTest?: boolean;
    isBillable?: boolean;
};
type User = Customer;

interface ListFlowsForIntegrationQuery extends CommonListElementsQuery {
    universalFlowId?: string | 'null';
}
interface FindFlowsQuery extends ListFlowsForIntegrationQuery {
    integrationId?: string | 'null';
}
interface CreateFlowNodeRequest {
    type: string;
    config?: any;
    ui?: any;
    links?: FlowNodeLink[];
}
interface CreateFlowRequest {
    key: string;
    name: string;
    integrationId?: string;
    nodes?: Record<string, CreateFlowNodeRequest>;
    parametersSchema?: DataSchema;
    autoCreateInstances?: boolean;
}
interface UpdateFlowRequest extends CreateFlowRequest {
    archivedAt?: string;
}
interface FlowSelector extends IntegrationSpecificElementSelector {
    autoCreate?: boolean;
}
type ListFlowInstancesForConnectionQuery = CommonInstancesListQuery & {
    flowId?: string;
    flowKey?: string;
    enabled?: boolean;
};
type FindFlowInstancesQuery = ListFlowInstancesForConnectionQuery & CommonIntegrationOrConnectionQuery;
interface FlowInstanceSelector extends ConnectionSelector, ElementInstanceSelector {
    flowId?: string;
    flowKey?: string;
    instanceKey?: string;
    autoUpdate?: boolean;
}
interface ResetFlowInstanceOptions {
    name?: boolean;
    nodes?: Record<string, boolean>;
    allNodes?: boolean;
}
interface RunFlowOptions {
    nodeKey?: string;
    input?: any;
    returnImmediately?: boolean;
    onUpdate?: (...args: any) => void;
}

interface ListFieldMappingsForIntegrationQuery extends CommonListElementsQuery {
    universalFieldMappingId?: string | 'null';
}
interface FindFieldMappingsQuery extends ListFieldMappingsForIntegrationQuery {
    integrationId?: string | 'null';
}
type ListFieldMappingInstancesForConnectionQuery = CommonInstancesListQuery & {
    fieldMappingId?: string;
    universalFieldMappingId?: string;
    dataSourceInstanceId?: string;
};
type FindFieldMappingInstancesQuery = ListFieldMappingInstancesForConnectionQuery & CommonIntegrationOrConnectionQuery;
interface UpdateFieldMappingRequest {
    key?: string;
    name?: string;
    dataSourceKey?: string;
    dataSourceId?: string;
    appSchema?: DataSchema;
    direction?: FieldMappingDirection;
    defaultImportValue?: any;
    exportValue?: any;
    importValue?: any;
    defaultExportValue?: any;
    frozenImportFields?: any;
    frozenExportFields?: any;
    frozenUnifiedExportFields?: any;
    archivedAt?: string;
}
interface CreateFieldMappingRequest extends UpdateFieldMappingRequest {
    key: string;
    name: string;
    integrationId?: string;
}
interface CreateFieldMappingInstanceRequest {
    connectionId: string;
    fieldMappingId?: string;
    instanceKey?: string;
    importValue?: any;
    exportValue?: any;
}
interface UpdateFieldMappingInstanceRequest {
    importValue?: any;
    exportValue?: any;
}
interface FieldMappingInstanceSelector extends ConnectionSelector, FlowInstanceSelector, ElementInstanceSelector {
    fieldMappingKey?: string;
    fieldMappingId?: string;
    instanceKey?: string;
    nodeKey?: string;
}
interface FieldMappingSelector extends IntegrationSpecificElementSelector {
}

type InstanceKeyQuery = {
    instanceKey?: string;
};

declare class ConnectionLevelElementAccessor<Element, UpdateElement> {
    protected client: IntegrationAppApiClient;
    protected connectionSelector: string;
    protected selector: string;
    protected elementKey: string;
    protected query: Record<string, any>;
    protected endpoint: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, selector: string, elementKey: string, query: Record<string, any>);
    protected uri(path?: string, query?: {}): string;
    getUniqueIdentifier(): string;
    get(query?: {
        autoCreate?: boolean;
    }): Promise<Element>;
    create(): Promise<Element>;
    patch(data: Partial<UpdateElement>): Promise<Element>;
    put(data: UpdateElement): Promise<Element>;
    archive(): Promise<void>;
    reset(): Promise<Element>;
    setup(): Promise<Element>;
}
declare class ConnectionLevelElementsListAccessor<Element, Query> {
    protected client: IntegrationAppApiClient;
    protected connectionSelector: string;
    protected elementKey: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, elementKey: string);
    list(query?: Query): Promise<PaginationResponse<Element[]>>;
}

declare class IntegrationLevelElementAccessor<Element, UpdateElementData> {
    protected client: IntegrationAppApiClient;
    protected integrationSelector: string;
    protected elementSelector: string;
    protected elementKey: string;
    protected endpoint: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, elementSelector: string, elementKey: string);
    getUniqueIdentifier(): string;
    get(): Promise<Element>;
    patch(data: Partial<UpdateElementData>): Promise<Element>;
    put(data: UpdateElementData): Promise<Element>;
    archive(): Promise<void>;
    reset(): Promise<Element>;
}
declare class IntegrationLevelElementsListAccessor<Element, Query, CreateElementData> {
    protected client: IntegrationAppApiClient;
    protected integrationSelector: string;
    protected elementKey: string;
    protected endpoint: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, elementKey: string);
    list(query?: Query): Promise<Element[]>;
    create(data: CreateElementData): Promise<Element>;
}

interface OpenFieldMappingInstanceConfigurationOptions extends OpenConfigurationOptions {
}
declare class FieldMappingsAccessor extends ElementListAccessor<FieldMapping, FindFieldMappingsQuery, CreateFieldMappingRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class FieldMappingAccessor extends ElementAccessor<FieldMapping, UpdateFieldMappingRequest, FieldMappingSelector> {
    constructor(client: IntegrationAppApiClient, selector: string | FieldMappingSelector);
    getAppSchema(): Promise<any>;
    apply(integrationKeys: string[]): Promise<FieldMapping[]>;
    reset(): Promise<any>;
}
declare class FieldMappingInstancesAccessor extends ElementInstanceListAccessor<FieldMappingInstance, FindFieldMappingInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class FieldMappingInstanceAccessor extends ElementInstanceAccessor<FieldMappingInstance, FieldMappingInstanceSelector, CreateFieldMappingInstanceRequest, UpdateFieldMappingInstanceRequest> {
    private client;
    constructor(client: IntegrationAppApiClient, selector: string | FieldMappingInstanceSelector);
    setup(): Promise<void>;
    reset(): Promise<void>;
    openConfiguration({ onClose, }?: OpenFieldMappingInstanceConfigurationOptions): Promise<void>;
}
declare class IntegrationLevelFieldMappingAccessor extends IntegrationLevelElementAccessor<FieldMapping, UpdateFieldMappingRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    fieldMappingSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, fieldMappingSelector: string);
}
declare class IntegrationLevelFieldMappingsListAccessor extends IntegrationLevelElementsListAccessor<FieldMapping, ListFieldMappingsForIntegrationQuery, Omit<CreateFieldMappingRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelFieldMappingAccessor extends ConnectionLevelElementAccessor<FieldMappingInstance, UpdateFieldMappingInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    fieldMappingSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, fieldMappingSelector: string, query: InstanceKeyQuery);
    openConfiguration({ onClose, }?: OpenFieldMappingInstanceConfigurationOptions): Promise<void>;
}
declare class ConnectionLevelFieldMappingsAccessor extends ConnectionLevelElementsListAccessor<FieldMapping, ListFieldMappingInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

declare enum FieldMappingDirection {
    IMPORT = "import",
    EXPORT = "export",
    BOTH = "both"
}
interface FieldMapping {
    id: string;
    name: string;
    key: string;
    revision: string;
    publishedRevision?: string;
    universalFieldMappingId?: string;
    universalFieldMappingRevision?: string;
    integrationId?: string;
    integration?: Integration;
    dataSourceId: string;
    dataSourceKey: string;
    appSchema: DataSchema;
    direction: FieldMappingDirection;
    defaultImportValue?: any;
    defaultExportValue?: any;
    importValue?: any;
    exportValue?: any;
    frozenImportFields?: any;
    frozenExportFields?: any;
    frozenUnifiedExportFields?: any;
    archivedAt?: string;
    customized?: boolean;
    appliedToIntegrations?: AppliedToIntegrations<FieldMapping>;
}
interface FieldMappingInstance {
    id: string;
    name?: string;
    userId: string;
    revision: string;
    user?: User;
    connectionId: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    fieldMappingRevision?: string;
    fieldMappingId?: string;
    fieldMapping?: FieldMapping;
    instanceKey?: string;
    dataSourceInstanceId?: string;
    dataSourceInstance?: DataSourceInstance;
    dataSourceSchema?: DataSchema;
    direction?: FieldMappingDirection;
    appSchema?: DataSchema;
    importValue?: any;
    exportValue?: any;
    isCustomized?: boolean;
    unifiedExportValue?: any;
    unifiedImportValue?: any;
    frozenImportFields?: string[];
    frozenExportFields?: string[];
    error?: ErrorData;
    externalSchema?: any;
}

interface OpenIntegrationUIIntegrationConfigurationOptions extends OpenConfigurationOptions {
}
declare class IntegrationsAccessor extends ElementListAccessor<Integration, FindIntegrationsQuery, CreateIntegrationRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class IntegrationAccessor extends ElementAccessor<Integration, UpdateIntegrationRequest> {
    private client;
    private integrationSelector;
    baseUri: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
    get actions(): IntegrationLevelActionsListAccessor;
    action(actionSelector: string): IntegrationLevelActionAccessor;
    get flows(): IntegrationLevelFlowsListAccessor;
    flow(flowSelector: string): IntegrationLevelFlowAccessor;
    get dataSources(): IntegrationLevelDataSourcesListAccessor;
    dataSource(dataSourceSelector: string): IntegrationLevelDataSourceAccessor;
    get fieldMappings(): IntegrationLevelFieldMappingsListAccessor;
    fieldMapping(fieldMappingSelector: string): IntegrationLevelFieldMappingAccessor;
    setup(): Promise<Integration>;
    resetParameters(): Promise<Integration>;
    getConnectorSpec(): Promise<ConnectionSpec>;
    open({ onClose, }?: OpenIntegrationUIIntegrationConfigurationOptions): Promise<void>;
    openNewConnection({ allowMultipleConnections, name, }?: OpenNewConnectionOptions): Promise<Connection>;
    connect({ name, parameters, authOptionKey, allowMultipleConnections, redirectUri, sameWindow, }?: {
        name?: string;
        parameters?: any;
        authOptionKey?: string;
        allowMultipleConnections?: boolean;
    } & ({
        sameWindow: true;
        redirectUri: string;
    } | {
        sameWindow?: false;
        redirectUri?: never;
    })): Promise<Connection | undefined>;
    createConnection({ parameters, name, }: {
        parameters?: any;
        name?: string;
    }): Promise<Connection | undefined>;
    disconnect(): Promise<void>;
    getOperations(): Promise<OperationListItem[]>;
    getOperation(key: string): Promise<OperationSpec>;
    getDataCollections(): Promise<DataLocationListItem[]>;
    getDataCollection(key: string): Promise<DataLocationSpec>;
    getDataLocations(): Promise<DataLocationListItem[]>;
    getDataLocation(key: string): Promise<DataLocationSpec>;
}

declare class FlowRunsAccessor {
    private readonly client;
    constructor(client: IntegrationAppApiClient);
    find(query: FindFlowRunsQuery): Promise<FindFlowRunsResponse>;
    create(request: CreateFlowRunRequest): Promise<FlowRun>;
}
declare class FlowRunAccessor {
    private readonly client;
    id: string;
    private baseUri;
    constructor(client: IntegrationAppApiClient, id: string);
    get(): Promise<FlowRun>;
    stop(): Promise<void>;
    getOutput(): Promise<any>;
    getNodeRuns(nodeKey: string, parameters?: {
        cursor?: string;
    }): Promise<any>;
    getNodeRun(nodeKey: string, runId: string): Promise<any>;
    getNodeOutputs(nodeKey: string, parameters?: {
        cursor?: string;
    }): Promise<any>;
    getNodeOutput(nodeKey: string, outputId: string): Promise<any>;
    repeat(): Promise<FlowRun>;
}

declare enum FlowRunState {
    QUEUED = "queued",
    RUNNING = "running",
    COMPLETED = "completed",
    STOPPED = "stopped",
    FAILED = "failed"
}
declare enum FlowRunNodeState {
    RUNNING = "running",
    COMPLETED = "completed",
    STOPPED = "stopped",
    FAILED = "failed"
}
declare enum FlowRunLaunchedByTrigger {
    ApiTrigger = "api-trigger",
    ScheduleTrigger = "schedule-trigger",
    AppEventTrigger = "app-event-trigger",
    DataSourceTrigger = "data-source-trigger",
    ExternalEvent = "external-event"
}
interface FlowRun {
    id: string;
    flowInstanceId: string;
    flowInstance?: FlowInstance;
    universalFlowId?: string;
    connectionId?: string;
    connection?: Connection;
    integrationId?: string;
    integration?: Integration;
    startNodeKey: string;
    userId: string;
    user?: Customer;
    input?: any;
    state: FlowRunState;
    startTime: string;
    endTime?: string;
    errors?: ErrorData[];
    nodes?: Record<string, FlowRunNode>;
    launchedBy?: FlowRunLaunchedBy;
}
interface FlowRunNode {
    state: FlowRunNodeState;
    runs?: number;
    erroredRuns?: number;
    outputs?: number;
}
interface FlowRunLaunchedBy {
    type: FlowRunLaunchedByTrigger;
    ids?: string[];
}
interface CreateFlowRunRequest {
    flowInstanceId: string;
    nodeKey?: string;
    input?: any;
}
interface FindFlowRunsQuery extends PaginationQuery {
    id?: string;
    flowInstanceId?: string;
    startNodeKey?: string;
    flowId?: string;
    universalFlowId?: string;
    userId?: string;
    state?: FlowRunState;
    integrationId?: string;
    connectionId?: string;
    startedAfter?: string;
}
interface FindFlowRunsResponse extends PaginationResponse<FlowRun> {
}

declare const createFlowInstanceSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    userId: z.ZodOptional<z.ZodString>;
    flowId: z.ZodOptional<z.ZodString>;
    connectionId: z.ZodOptional<z.ZodString>;
    integrationId: z.ZodOptional<z.ZodString>;
    instanceKey: z.ZodOptional<z.ZodString>;
    parameters: z.ZodOptional<z.ZodAny>;
    nodes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        name: z.ZodOptional<z.ZodString>;
        type: z.ZodOptional<z.ZodString>;
        userConfig: z.ZodOptional<z.ZodAny>;
        config: z.ZodOptional<z.ZodAny>;
        onError: z.ZodOptional<z.ZodEnum<["stop", "continue"]>>;
        concurrency: z.ZodOptional<z.ZodNumber>;
        ui: z.ZodOptional<z.ZodAny>;
        links: z.ZodOptional<z.ZodArray<z.ZodObject<{
            key: z.ZodOptional<z.ZodString>;
            filter: z.ZodOptional<z.ZodAny>;
            name: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }>, "many">>;
        isCustomized: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }>>>;
    enabled: z.ZodOptional<z.ZodBoolean>;
    customized: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodBoolean>;
        nodes: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    name?: string | undefined;
    userId?: string | undefined;
    integrationId?: string | undefined;
    connectionId?: string | undefined;
    parameters?: any;
    flowId?: string | undefined;
    instanceKey?: string | undefined;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
}, {
    name?: string | undefined;
    userId?: string | undefined;
    integrationId?: string | undefined;
    connectionId?: string | undefined;
    parameters?: any;
    flowId?: string | undefined;
    instanceKey?: string | undefined;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        ui?: any;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
}>;
declare const updateFlowInstanceSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    enabled: z.ZodOptional<z.ZodBoolean>;
    parameters: z.ZodOptional<z.ZodAny>;
    nodes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        name: z.ZodOptional<z.ZodString>;
        type: z.ZodOptional<z.ZodString>;
        userConfig: z.ZodOptional<z.ZodAny>;
        config: z.ZodOptional<z.ZodAny>;
        onError: z.ZodOptional<z.ZodEnum<["stop", "continue"]>>;
        links: z.ZodOptional<z.ZodArray<z.ZodObject<{
            key: z.ZodOptional<z.ZodString>;
            filter: z.ZodOptional<z.ZodAny>;
            name: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }, {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }>, "many">>;
        concurrency: z.ZodOptional<z.ZodNumber>;
        isCustomized: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }>>>;
    archivedAt: z.ZodOptional<z.ZodString>;
    customized: z.ZodOptional<z.ZodObject<{
        name: z.ZodOptional<z.ZodBoolean>;
        nodes: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }, {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    name?: string | undefined;
    parameters?: any;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
    archivedAt?: string | undefined;
}, {
    name?: string | undefined;
    parameters?: any;
    nodes?: Record<string, {
        concurrency?: number | undefined;
        type?: string | undefined;
        name?: string | undefined;
        userConfig?: any;
        config?: any;
        onError?: "stop" | "continue" | undefined;
        links?: {
            key?: string | undefined;
            name?: string | undefined;
            filter?: any;
        }[] | undefined;
        isCustomized?: boolean | undefined;
    }> | undefined;
    enabled?: boolean | undefined;
    customized?: {
        name?: boolean | undefined;
        nodes?: boolean | undefined;
    } | undefined;
    archivedAt?: string | undefined;
}>;
type CreateFlowInstanceRequest = z.infer<typeof createFlowInstanceSchema>;
type UpdateFlowInstanceRequest = z.infer<typeof updateFlowInstanceSchema>;

declare enum IntegrationElementType {
    APP_DATA_SCHEMA = "app-data-schema",
    APP_EVENT_TYPE = "app-event-type",
    DATA_SOURCE = "data-source",
    SCHEMA = "schema",
    FIELD_MAPPING = "field-mapping",
    FLOW = "flow",
    INTEGRATION = "integration",
    ACTION = "action",
    DATA_LINK_TABLE = "data-link-table",
    EXTERNAL_EVENT = "external-event"
}
interface ElementTemplateFields {
    id: string;
    key: string;
    name: string;
    revision: string;
    integrationId?: string;
    integration?: Integration;
    parentId?: string;
    parentRevision?: string;
    isCustomized?: boolean;
    createdAt?: string;
    updatedAt?: string;
    archivedAt?: string;
}
interface ElementInstanceFields {
    id: string;
    name: string;
    revision: string;
    parentId?: string;
    parentRevision?: string;
    universalParentId?: string;
    userId: string;
    user?: Customer;
    instanceKey?: string;
    isCustomized?: boolean;
    connectionId: string;
    connection?: Connection;
    integrationId?: string;
    integration?: Integration;
    dependencies?: IntegrationElementInstance[];
    errors?: ErrorData[];
    createdAt?: string;
    updatedAt?: string;
    archivedAt?: string;
}
interface IntegrationElementInstance {
    type: IntegrationElementType;
    instanceId?: string;
    data?: any;
}

interface FlowNode {
    type?: string;
    version?: number;
    name?: string;
    description?: string;
    config?: any;
    concurrency?: number;
    onError?: 'stop' | 'continue';
    ui?: any;
    inputSchema?: any;
    outputSchema?: any;
    outputExample?: any;
    links?: FlowNodeLink[];
    isCustomized?: boolean;
}
interface Flow {
    id: string;
    name: string;
    key: string;
    integrationId?: string;
    integration?: Integration;
    universalFlowId?: string;
    universalFlowRevision?: string;
    parametersSchema?: DataSchema;
    nodes?: Record<string, FlowNode>;
    autoCreateInstances?: boolean;
    archivedAt?: string;
    revision: string;
    customized?: boolean;
    appliedToIntegrations?: AppliedToIntegrations<Flow>;
    isDeployed?: boolean;
}
interface FlowInstance {
    id: string;
    userId: string;
    user?: User;
    connectionId?: string;
    connection?: Connection;
    flow?: Flow;
    flowId?: string;
    universalFlowId?: string;
    integrationId: string;
    integration?: Integration;
    instanceKey?: string;
    name: string;
    parameters?: any;
    parametersSchema?: DataSchema;
    nodes?: Record<string, FlowInstanceNode>;
    enabled: boolean;
    createdAt: string;
    updatedAt: string;
    dependencies?: IntegrationElementInstance[];
    state?: WorkspaceElementState;
    outdated?: boolean;
    customized?: {
        name?: boolean;
        nodes?: boolean;
    };
}
declare enum FlowInstanceNodeState {
    SETTING_UP = "SETTING_UP",
    SETUP_FAILED = "SETUP_FAILED",
    READY = "READY"
}
interface FlowInstanceNode extends FlowNode {
    state?: FlowInstanceNodeState;
    errors?: ErrorData[];
    userConfig?: any;
    testInput?: any;
    dependencies?: IntegrationElementInstance[];
}
interface FlowNodeLink {
    key?: string;
    filter?: any;
    name?: string;
}

interface OpenFlowInstanceConfigurationOptions extends OpenConfigurationOptions {
    nodeKey?: string;
}
interface OpenFlowInstanceEditorOptions extends OpenConfigurationOptions {
}
declare class FlowsAccessor extends ElementListAccessor<Flow, FindFlowsQuery, CreateFlowRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class FlowAccessor extends ElementAccessor<Flow, UpdateFlowRequest, FlowSelector> {
    constructor(client: IntegrationAppApiClient, selector: FlowSelector | string);
    apply(integrationKeys: string[]): Promise<Flow[]>;
    reset(): Promise<Flow>;
}
declare class FlowInstancesAccessor extends ElementInstanceListAccessor<FlowInstance, FindFlowInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
    create(data: CreateFlowInstanceRequest): Promise<FlowInstance>;
}
declare class FlowInstanceAccessor extends ElementInstanceAccessor<FlowInstance, FlowInstanceSelector, CreateFlowInstanceRequest, UpdateFlowInstanceRequest> {
    protected client: IntegrationAppApiClient;
    protected selector: FlowInstanceSelector | string;
    constructor(client: IntegrationAppApiClient, selector: FlowInstanceSelector | string);
    enable(): Promise<FlowInstance>;
    disable(): Promise<FlowInstance>;
    updateToLatestFlow(): Promise<FlowInstance>;
    setup(): Promise<FlowInstance>;
    reset(options?: ResetFlowInstanceOptions): Promise<FlowInstance>;
    openConfiguration({ nodeKey, onClose, }?: OpenFlowInstanceConfigurationOptions): Promise<void>;
    openEditor({ onClose }?: OpenFlowInstanceEditorOptions): Promise<void>;
    startRun(options?: RunFlowOptions): Promise<FlowRun>;
    run(options?: RunFlowOptions): Promise<FlowRun>;
}
declare class IntegrationLevelFlowAccessor extends IntegrationLevelElementAccessor<Flow, UpdateFlowRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    flowSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, flowSelector: string);
}
declare class IntegrationLevelFlowsListAccessor extends IntegrationLevelElementsListAccessor<Flow, ListFlowsForIntegrationQuery, Omit<CreateFlowRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelFlowAccessor extends ConnectionLevelElementAccessor<FlowInstance, UpdateFlowInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    flowSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, flowSelector: string, query: InstanceKeyQuery);
    enable(): Promise<FlowInstance>;
    disable(): Promise<FlowInstance>;
    run(options: {
        nodeKey?: string;
        input?: any;
    }): Promise<FlowRun>;
    openConfiguration(options?: OpenFlowInstanceConfigurationOptions): Promise<void>;
    openEditor(options?: OpenFlowInstanceEditorOptions): Promise<void>;
}
declare class ConnectionLevelFlowsAccessor extends ConnectionLevelElementsListAccessor<Flow, ListFlowInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

interface ListDataSourcesForIntegrationQuery extends PaginationQuery {
    universalDataSourceId?: string | 'null';
}
interface FindDataSourcesQuery extends ListDataSourcesForIntegrationQuery {
    integrationId?: string | 'null';
}
type CreateDataSourceRequest = {
    key: string;
    name: string;
    integrationId?: string;
    udm?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    rootPath?: string;
    defaultPath?: string;
    collectionKey?: string;
    collectionParameters?: any;
};
type UpdateDataSourceRequest = {
    key?: string;
    name?: string;
    archivedAt?: string;
    udm?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    rootPath?: string;
    defaultPath?: string;
};
interface DataSourceInstanceSelector extends ConnectionSelector, FlowInstanceSelector, ElementInstanceSelector {
    dataSourceKey?: string;
    dataSourceId?: string;
    instanceKey?: string;
    nodeKey?: string;
    udm?: string;
}
interface FindDataSourceInstancesQuery extends PaginationQuery {
    userId?: string;
    dataSourceId?: string;
    universalDataSourceId?: string;
    connectionId?: string;
    integrationKey?: string;
    integrationId?: string;
}
interface CreateDataSourceInstanceRequest {
    dataSourceId: string;
    connectionId: string;
    path?: string;
}
interface UpdateDataSourceInstanceRequest {
    path?: string;
    collectionKey?: string;
    collectionParameters?: any;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    subscribedTo?: {
        created?: boolean;
        updated?: boolean;
        deleted?: boolean;
    };
}
type ListDataSourceInstancesForConnectionQuery = PaginationQuery & {
    dataSourceId?: string;
};

interface OpenDataSourceConfigurationOptions extends OpenConfigurationOptions {
}
declare class DataSourcesAccessor extends ElementListAccessor<DataSource, FindDataSourcesQuery, CreateDataSourceRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataSourceAccessor extends ElementAccessor<DataSource, UpdateDataSourceRequest, DataSourceSelector> {
    constructor(client: IntegrationAppApiClient, selector: DataSourceSelector | string);
    apply(integrationKeys: string[]): Promise<DataSource[]>;
    reset(): Promise<any>;
}
declare class DataSourceInstancesAccessor extends ElementInstanceListAccessor<DataSourceInstance, FindDataSourceInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataSourceInstanceAccessor extends ElementInstanceAccessor<DataSourceInstance, DataSourceInstanceSelector, CreateDataSourceInstanceRequest, UpdateDataSourceInstanceRequest> {
    client: IntegrationAppApiClient;
    constructor(client: IntegrationAppApiClient, selector: string | DataSourceInstanceSelector);
    setup(): Promise<void>;
    reset(): Promise<void>;
    openConfiguration({ onClose, }?: OpenDataSourceConfigurationOptions): Promise<void>;
    unifiedFieldsToNative(unifiedFields: any): Promise<any>;
    getCollection(): Promise<DataCollectionSpec>;
    listRecords(request?: DataCollectionListRequest): Promise<DataCollectionListResponse>;
    matchRecord(request: DataCollectionMatchRequest): Promise<DataCollectionMatchResponse>;
    searchRecords(request: DataCollectionSearchRequest): Promise<DataCollectionSearchResponse>;
    findRecordById(request: string | DataCollectionFindByIdRequest): Promise<DataCollectionFindByIdResponse>;
    createRecord(request: DataCollectionCreateRequest): Promise<DataCollectionCreateResponse>;
    updateRecord(request: DataCollectionUpdateRequest): Promise<DataCollectionUpdateResponse>;
    deleteRecord(request: string | DataCollectionFindByIdRequest): Promise<DataCollectionDeleteResponse>;
    findRecords(request?: DataCollectionFindRequest): Promise<DataCollectionFindResponse>;
}
declare class IntegrationLevelDataSourceAccessor extends IntegrationLevelElementAccessor<DataSource, UpdateDataSourceRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    dataSourceSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, dataSourceSelector: string);
}
declare class IntegrationLevelDataSourcesListAccessor extends IntegrationLevelElementsListAccessor<DataSource, ListDataSourcesForIntegrationQuery, Omit<CreateDataSourceRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelDataSourceAccessor extends ConnectionLevelElementAccessor<DataSourceInstance, UpdateDataSourceInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    dataSourceSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, dataSourceSelector: string, query: InstanceKeyQuery);
    openConfiguration(options?: OpenDataSourceConfigurationOptions): Promise<void>;
}
declare class ConnectionLevelDataSourcesAccessor extends ConnectionLevelElementsListAccessor<DataSource, ListDataSourceInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

interface DataSourceUnitConfig {
    key?: string;
    collectionKey?: any;
    collectionParameters?: any;
    udm?: any;
    path?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
}
interface DataSource {
    id: string;
    key: string;
    name: string;
    revision: string;
    publishedRevision?: string;
    integrationId?: string;
    integration?: Integration;
    universalDataSourceId?: string;
    universalDataSourceRevision?: string;
    udm?: string;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    collectionKey?: string;
    collectionParameters?: any;
    archivedAt?: string;
    createdAt?: string;
    updatedAt?: string;
    customized?: boolean;
    appliedToIntegrations?: AppliedToIntegrations<DataSource>;
    defaultPath?: string;
}
interface DataSourceInstance {
    id: string;
    userId: string;
    revision: string;
    user?: User;
    dataSourceRevision?: string;
    dataSourceId?: string;
    universalDataSourceId?: string;
    dataSource?: DataSource;
    udm?: string;
    connectionId: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    instanceKey?: string;
    collectionKey?: string;
    collectionParameters?: any;
    defaultCollectionKey?: string;
    defaultCollectionParameters?: any;
    collectionSpec?: DataCollectionSpec;
    isCustomized?: boolean;
    errors?: ErrorData[];
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    path?: string;
    defaultPath?: string;
}
interface DataSourceSelector extends IntegrationSpecificElementSelector {
}

declare class ConnectionsAccessor extends ElementInstanceListAccessor<Connection, FindConnectionsQuery> {
    constructor(client: IntegrationAppApiClient);
    create(data: CreateConnectionRequest): Promise<Connection>;
}
declare class ConnectionAccessor {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
    get actions(): ConnectionLevelActionsAccessor;
    action(actionSelector: string, query?: InstanceKeyQuery): ConnectionLevelActionAccessor;
    get flows(): ConnectionLevelFlowsAccessor;
    flow(flowSelector: string, query?: InstanceKeyQuery): ConnectionLevelFlowAccessor;
    get dataSources(): ConnectionLevelDataSourcesAccessor;
    dataSource(dataSourceSelector: string, query?: InstanceKeyQuery): ConnectionLevelDataSourceAccessor;
    get fieldMappings(): ConnectionLevelFieldMappingsAccessor;
    fieldMapping(fieldMappingSelector: string, query?: InstanceKeyQuery): ConnectionLevelFieldMappingAccessor;
    get(query?: {
        includeSecrets?: boolean;
    }): Promise<Connection>;
    patch(data: UpdateConnectionRequest): Promise<Connection>;
    put(data: UpdateConnectionRequest): Promise<Connection>;
    archive(): Promise<void>;
    request(path: string, data?: any): Promise<any>;
    get proxy(): ConnectionProxy;
    operation(key: string): ConnectionOperationAccessor;
    dataCollection(key: string, parameters?: Record<string, any>): ConnectionDataCollectionAccessor;
    dataDirectory(key: string, parameters?: Record<string, any>): ConnectionDataDirectoryAccessor;
    reconnect({ parameters, authOptionKey, }?: {
        parameters?: any;
        authOptionKey?: string;
    }): Promise<Connection | undefined>;
    openReconnectUI({}?: OpenConfigurationOptions): Promise<void>;
    refreshCredentials(): Promise<void>;
    getPath(subpath?: string, query?: Record<string, any>): string;
}
declare class ConnectionOperationAccessor {
    client: IntegrationAppApiClient;
    connectionAccessor: ConnectionAccessor;
    key: string;
    constructor(client: IntegrationAppApiClient, connectionAccessor: ConnectionAccessor, key: string);
    get(): Promise<OperationSpec>;
    run(request?: OperationRunRequest): Promise<OperationRunResponse>;
}
declare class ConnectionDataDirectoryAccessor {
    client: IntegrationAppApiClient;
    connectionAccessor: ConnectionAccessor;
    key: string;
    parameters: Record<string, any>;
    constructor(client: IntegrationAppApiClient, connectionAccessor: ConnectionAccessor, key: string, parameters: Record<string, any>);
    list(request?: DataDirectoryListRequest): Promise<DataDirectoryListResponse>;
}
declare class ConnectionDataCollectionAccessor {
    client: IntegrationAppApiClient;
    connectionAccessor: ConnectionAccessor;
    key: string;
    parameters: Record<string, any>;
    constructor(client: IntegrationAppApiClient, connectionAccessor: ConnectionAccessor, key: string, parameters: Record<string, any>);
    get(): Promise<DataCollectionSpec>;
    findById(request?: DataCollectionFindByIdRequest): Promise<DataCollectionFindByIdResponse>;
    list(request?: DataCollectionListRequest): Promise<DataCollectionListResponse>;
    search(request?: DataCollectionSearchRequest): Promise<DataCollectionSearchResponse>;
    match(request?: DataCollectionMatchRequest): Promise<DataCollectionMatchResponse>;
    create(request?: DataCollectionCreateRequest): Promise<DataCollectionCreateResponse>;
    update(request?: DataCollectionUpdateRequest): Promise<DataCollectionUpdateResponse>;
    delete(request?: DataCollectionDeleteRequest): Promise<DataCollectionDeleteResponse>;
}
declare class ConnectionProxy {
    private connection;
    constructor(connection: ConnectionAccessor);
    get(path: string): Promise<any>;
    post(path: string, data?: any): Promise<any>;
    put(path: string, data?: any): Promise<any>;
    patch(path: string, data?: any): Promise<any>;
    delete(path: string): Promise<any>;
    private getProxyPath;
}

declare class Connection {
    id: string;
    name: string;
    userId: string;
    user?: User;
    disconnected?: boolean;
    error?: ErrorData;
    integrationId: string;
    integration?: Integration;
    credentials?: unknown;
    parameters?: unknown;
    connectorParameters?: unknown;
    accessToken?: string;
    refreshToken?: string;
    createdAt: string;
    updatedAt: string;
    archivedAt?: string;
}
interface ConnectionSpec extends ConnectorSpec {
}
declare class ConnectionSpec {
    constructor(opts: ConnectionSpec);
}

declare enum ActionType {
    ListDataRecords = "list-data-records",
    FindDataRecordById = "find-data-record-by-id",
    MatchDataRecord = "match-data-record",
    CreateDataRecord = "create-data-record",
    FindOrCreateDataRecord = "find-or-create-data-record",
    UpdateDataRecord = "update-data-record",
    DeleteDataRecord = "delete-data-record",
    SearchDataRecords = "search-data-record",
    ConnectorOperation = "connector-operation",
    ApiRequestToExternalApp = "api-request-to-external-app",
    ApiRequestToYourApp = "api-request-to-your-app",
    HttpRequest = "http-request",
    RunJavascript = "run-javascript",
    ApiRequest = "api-request"
}

interface Action extends ElementTemplateFields {
    type: ActionType;
    inputSchema?: DataSchema;
    config?: any;
    outputMapping?: any;
    customOutputSchema?: DataSchema;
    defaultOutputSchema?: DataSchema;
    transformedOutputSchema?: DataSchema;
    outputSchema?: DataSchema;
    appliedToIntegrations?: AppliedToIntegrations<Action>;
    dependencies?: WorkspaceElementDependency[];
    isDeployed?: boolean;
}
interface ActionInstance extends ElementInstanceFields {
    type: ActionType;
    parent?: Action;
    instanceKey?: string;
    inputSchema?: any;
    config?: any;
    outputSchema?: any;
    isOutdated?: boolean;
    state: WorkspaceElementState;
}
interface ListActionsForIntegrationQuery extends PaginationQuery {
    parentId?: string | 'null';
}
interface FindActionsQuery extends ListActionsForIntegrationQuery {
    integrationId?: string | 'null';
}
type CreateActionRequest = {
    key: string;
    name: string;
    type?: ActionType;
    inputSchema?: any;
    config?: any;
    integrationId?: string;
};
type UpdateActionRequest = {
    key?: string;
    type?: ActionType;
    name?: string;
    inputSchema?: any;
    config?: any;
    archivedAt?: string;
};
interface ActionSelector extends IntegrationSpecificElementSelector {
}
interface ActionInstanceSelector extends ConnectionSelector, ElementInstanceSelector {
}
type ListActionInstancesForConnectionQuery = PaginationQuery & {
    parentId?: string;
    universalParentId?: string;
};
interface FindActionInstancesQuery extends ListActionInstancesForConnectionQuery {
    integrationKey?: string;
    integrationId?: string;
    userId?: string;
    connectionId?: string;
}
interface CreateActionInstanceRequest {
    parentId: string;
    connectionId: string;
    config?: any;
}
interface UpdateActionInstanceRequest {
    config?: any;
}
interface OpenActionConfigurationOptions extends OpenConfigurationOptions {
}
interface ActionRunResponse {
    output?: any;
    logs?: any[];
}

declare class ActionsAccessor extends ElementListAccessor<Action, FindActionsQuery, CreateActionRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class ActionAccessor extends ElementAccessor<Action, UpdateActionRequest, ActionSelector> {
    constructor(client: IntegrationAppApiClient, selector: ActionSelector | string);
    apply(integrationKeys: string[]): Promise<Action[]>;
    reset(): Promise<any>;
}
declare class ActionInstancesAccessor extends ElementInstanceListAccessor<ActionInstance, FindActionInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class ActionInstanceAccessor extends ElementInstanceAccessor<ActionInstance, ActionInstanceSelector, CreateActionInstanceRequest, UpdateActionInstanceRequest> {
    client: IntegrationAppApiClient;
    constructor(client: IntegrationAppApiClient, selector: string | ActionInstanceSelector);
    setup(): Promise<void>;
    reset(): Promise<void>;
    run(input?: any): Promise<ActionRunResponse>;
    open({ onClose, }?: OpenActionConfigurationOptions): Promise<void>;
}
declare class IntegrationLevelActionAccessor extends IntegrationLevelElementAccessor<Action, UpdateActionRequest> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    actionSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string, actionSelector: string);
}
declare class IntegrationLevelActionsListAccessor extends IntegrationLevelElementsListAccessor<Action, ListActionsForIntegrationQuery, Omit<CreateActionRequest, 'integrationId'>> {
    client: IntegrationAppApiClient;
    integrationSelector: string;
    constructor(client: IntegrationAppApiClient, integrationSelector: string);
}
declare class ConnectionLevelActionAccessor extends ConnectionLevelElementAccessor<ActionInstance, UpdateActionInstanceRequest> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    actionSelector: string;
    query: InstanceKeyQuery;
    constructor(client: IntegrationAppApiClient, connectionSelector: string, actionSelector: string, query: InstanceKeyQuery);
    run(input?: any): Promise<ActionRunResponse>;
}
declare class ConnectionLevelActionsAccessor extends ConnectionLevelElementsListAccessor<Action, ListActionInstancesForConnectionQuery> {
    client: IntegrationAppApiClient;
    connectionSelector: string;
    constructor(client: IntegrationAppApiClient, connectionSelector: string);
}

type CreateAppDataSchemaRequest = {
    key: string;
    name: string;
    schema?: any;
    code?: string;
};
type UpdateAppDataSchemaRequest = {
    key?: string;
    name?: string;
    schema?: any;
    code?: string;
    archivedAt?: string;
};
interface FindAppDataSchemasQuery extends PaginationQuery {
}
interface AppDataSchemaInstanceSelector {
    id?: string;
    appDataSchemaKey?: string;
    appDataSchemaId?: string;
    instanceKey?: string;
    autoCreate?: boolean;
}
interface UpdateAppDataSchemaInstanceRequest {
}
interface CreateAppDataSchemaInstanceRequest {
}
interface FindAppDataSchemaInstancesQuery extends PaginationQuery {
    id?: string;
    userId?: string;
    appDataSchemaId?: string;
    instanceKey?: string;
}

declare class AppDataSchemasAccessor extends ElementListAccessor<AppDataSchema, FindAppDataSchemasQuery, CreateAppDataSchemaRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppDataSchemaAccessor extends ElementAccessor<AppDataSchema, UpdateAppDataSchemaRequest> {
    constructor(client: IntegrationAppApiClient, idOrKey: string);
}
declare class AppDataSchemaInstancesAccessor extends ElementInstanceListAccessor<AppDataSchemaInstance, FindAppDataSchemaInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppDataSchemaInstanceAccessor extends ElementInstanceAccessor<AppDataSchemaInstance, AppDataSchemaInstanceSelector, UpdateAppDataSchemaInstanceRequest, CreateAppDataSchemaInstanceRequest> {
    private client;
    constructor(client: IntegrationAppApiClient, selector: string | AppDataSchemaInstanceSelector);
    setup(): Promise<void>;
}

interface AppDataSchema {
    id: string;
    key: string;
    name: string;
    schema: any;
    code?: string;
    archivedAt?: string;
    revision?: string;
}
interface AppDataSchemaInstance {
    id: string;
    appId: string;
    userId: string;
    user?: User;
    appDataSchemaId: string;
    appDataSchemaRevision: string;
    appDataSchema?: AppDataSchema;
    instanceKey?: string;
    schema?: any;
    error?: ErrorData;
    archivedAt?: string;
}

interface UpdateAppEventTypeRequest {
    key?: string;
    name?: string;
    subscribeRequest?: HttpRequestSpec;
    example?: any;
    schema?: DataSchema;
    userIdFormula?: any;
}
interface CreateAppEventTypeRequest extends UpdateAppEventTypeRequest {
    key: string;
    name: string;
}
interface AppEventSubscriptionSelector extends Omit<ElementInstanceSelector, 'parentKey' | 'parentId'> {
    appEventTypeKey?: string;
    appEventTypeId?: string;
    instanceKey?: string;
}
interface AppEventSubscriptionUpdateRequest {
}
interface FindAppEventTypesQuery extends PaginationQuery {
    includeArchived?: boolean;
}
interface FindAppEventSubscriptionsQuery extends PaginationQuery {
    id?: string;
    userId?: string;
    instanceKey?: string;
    appEventTypeId?: string;
    isSubscribed?: boolean;
}
interface FindAppEventsQuery extends PaginationQuery {
    id?: string;
    userId?: string;
    instanceKey?: string;
    appEventTypeId?: string;
    appEventSubscriptionId?: string;
    startDatetime?: string;
    endDatetime?: string;
}

declare class AppEventTypesAccessor extends ElementListAccessor<AppEventType, FindAppEventTypesQuery, CreateAppEventTypeRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppEventTypeAccessor extends ElementAccessor<AppEventType, UpdateAppEventTypeRequest> {
    constructor(client: IntegrationAppApiClient, idOrKey: string);
}
declare class AppEventSubscriptionsAccessor extends ElementInstanceListAccessor<AppEventSubscription, FindAppEventSubscriptionsQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class AppEventSubscriptionAccessor extends ElementInstanceAccessor<AppEventSubscription, AppEventSubscriptionSelector, AppEventSubscriptionUpdateRequest, AppEventSubscriptionUpdateRequest> {
    constructor(client: IntegrationAppApiClient, selector: string | AppEventSubscriptionSelector);
    subscribe(): Promise<void>;
}
declare class AppEventsAccessor extends ElementInstanceListAccessor<AppEvent, FindAppEventsQuery> {
    constructor(client: IntegrationAppApiClient);
}

interface AppEventType {
    id: string;
    key: string;
    name: string;
    revision: string;
    archivedAt?: string;
    subscribeRequest?: HttpRequestSpec;
    example?: any;
    schema?: DataSchema;
    globalWebhookUri: string;
    userIdFormula?: any;
}
interface AppEventSubscription {
    id: string;
    revision: string;
    appEventTypeId: string;
    appEventType?: AppEventType;
    userId: string;
    user?: User;
    instanceKey?: string;
    isSubscribed: boolean;
    schema?: DataSchema;
    webhookUri: string;
    subscriptionRequest: HttpRequestSpec;
    subscriptionResponse?: any;
    archivedAt?: string;
}
interface AppEvent {
    id: string;
    userId: string;
    user?: User;
    appEventTypeId: string;
    appEventType?: AppEventType;
    appEventSubscriptionId: string;
    appEventSubscription?: AppEventSubscription;
    event: any;
    datetime: string;
    launchedFlowRunIds: string[];
}

declare class SelfAccessor {
    private client;
    constructor(client: IntegrationAppApiClient);
    get(): Promise<Customer>;
    patch(data: Partial<{
        credentials: any;
    }>): Promise<Customer>;
}

type CreateDataLinkTableRequest = Omit<DataLinkTable, 'id' | 'userId'>;
type UpdateDataLinkTableRequest = CreateDataLinkTableRequest;
interface FindDataLinkTablesQuery extends PaginationQuery {
}
interface FindDataLinkTableInstancesQuery extends PaginationQuery {
    connectionId?: string;
    integrationId?: string;
    dataLinkTableId?: string;
}
interface DataLinkTableInstanceSelector extends ConnectionSelector, ElementInstanceSelector {
    dataLinkTableId?: string;
    dataLinkTableKey?: string;
    instanceKey?: string;
}
interface UpdateDataLinkTableInstanceRequest {
}
interface FindDataLinksInTableQuery extends PaginationQuery {
    direction?: DataLinkDirection;
    appRecordId?: string;
    externalRecordId?: string;
}
interface CreateDataLinkRequest {
    direction?: DataLinkDirection;
    appRecordId: string;
    externalRecordId: string;
}
interface DeleteDataLinkRequest {
    direction?: DataLinkDirection;
    appRecordId: string;
    externalRecordId: string;
}
interface FindDataLinksResponse extends PaginationResponse<DataLink> {
}

declare class DataLinkTablesAccessor extends ElementListAccessor<DataLinkTable, FindDataLinkTablesQuery, CreateDataLinkTableRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataLinkTableAccessor extends ElementAccessor<DataLinkTable, UpdateDataLinkTableRequest> {
    constructor(client: IntegrationAppApiClient, idOrKey: string);
}
declare class DataLinkTableInstancesAccessor extends ElementInstanceListAccessor<DataLinkTableInstance, FindDataLinkTableInstancesQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class DataLinkTableInstanceAccessor extends ElementInstanceAccessor<DataLinkTableInstance, DataLinkTableInstanceSelector, UpdateDataLinkTableInstanceRequest, UpdateDataLinkTableInstanceRequest> {
    private client;
    constructor(client: IntegrationAppApiClient, selector: string | DataLinkTableInstanceSelector);
    findLinks(query?: FindDataLinksInTableQuery): Promise<FindDataLinksResponse>;
    createLink(data: CreateDataLinkRequest): Promise<void>;
    deleteLink(data: DeleteDataLinkRequest): Promise<void>;
}

declare enum DataLinkDirection {
    IMPORT = "import",
    EXPORT = "export",
    BOTH = "both"
}
interface DataLinkTable {
    id: string;
    key: string;
    name: string;
    archivedAt?: string;
}
interface DataLinkTableInstance {
    id: string;
    dataLinkTableId?: string;
    dataLinkTable?: DataLinkTable;
    connectionId?: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    instanceKey?: string;
    userId: string;
    user?: User;
    name: string;
    archivedAt?: string;
}
interface DataLink {
    id: string;
    dataLinkTableInstanceId: string;
    externalRecordId: string;
    appRecordId: string;
    direction: DataLinkDirection;
}

declare enum ExternalEventSubscriptionStatus {
    Subscribed = "subscribed",
    Unsubscribed = "unsubscribed",
    Error = "error"
}
declare enum ExternalEventSubscriptionType {
    DataRecordCreated = "data-record-created",
    DataRecordUpdated = "data-record-updated",
    DataRecordDeleted = "data-record-deleted",
    ConnectorEvent = "connector-event"
}
interface ExternalEventSubscriptionConfig {
    type: ExternalEventSubscriptionType;
    dataSource?: DataSourceUnitConfig;
    eventKey?: string;
    eventParameters?: any;
}
interface ExternalEventSubscription {
    id: string;
    name?: string;
    userId: string;
    user?: Customer;
    connectionId: string;
    connection?: Connection;
    integrationId: string;
    integration?: Integration;
    uuid: string;
    config?: ExternalEventSubscriptionConfig;
    status?: ExternalEventSubscriptionStatus;
    isRealTime?: boolean;
    requiresPull?: boolean;
    requiresFullSync?: boolean;
    error?: ErrorData;
    createdAt?: string;
    archivedAt?: string;
    stateData?: any;
    nextPullEventsTimestamp?: number;
    pullUpdatesIntervalSeconds?: number;
    fullSyncIntervalSeconds?: number;
    nextRefreshTimestamp?: number;
    globalWebhookKey?: string;
    globalWebhookEventSelector?: string;
}

interface FindExternalEventSubscriptionsQuery extends PaginationQuery {
    userId?: string;
    connectionId?: string;
    integrationId?: string;
}

declare class ExternalEventSubscriptionsAccessor extends ElementInstanceListAccessor<ExternalEventSubscription, FindExternalEventSubscriptionsQuery> {
    constructor(client: IntegrationAppApiClient);
}
declare class ExternalEventSubscriptionAccessor {
    private client;
    private id;
    constructor(client: IntegrationAppApiClient, id: string);
    get(): Promise<ExternalEventSubscription>;
    setup(): Promise<void>;
    subscribe(): Promise<void>;
    unsubscribe(): Promise<void>;
    resubscribe(): Promise<void>;
    pullEvents(): Promise<void>;
    private getPath;
}

interface Scenario {
    id: string;
    appId: string;
    name: string;
    key: string;
    scenarioTemplateId?: string;
    elements?: ScenarioElement[];
    connectors?: MinimalConnector[];
    todos?: ScenarioToDo[];
    appliedToIntegrations?: Integration[];
    archivedAt?: string;
}
type ScenarioToDo = {
    name: string;
    description: string;
    isComplete: boolean;
};
type ScenarioElement = {
    id: string;
    type: IntegrationElementType;
    element?: any;
};
interface FindScenariosQuery extends SearchQuery, PaginationQuery {
}
interface CreateScenarioRequest {
    name: string;
    key: string;
    elements?: ScenarioElement[];
    todos?: ScenarioToDo[];
}
interface UpdateScenarioRequest {
    name?: string;
    key?: string;
    elements?: ScenarioElement[];
    todos?: ScenarioToDo[];
}

declare class ScenariosAccessor extends ElementListAccessor<Scenario, FindScenariosQuery, CreateScenarioRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class ScenarioAccessor extends ElementAccessor<Scenario, UpdateScenarioRequest> {
    constructor(client: IntegrationAppApiClient, selector: string);
}

declare enum ScreenType {
    Integration = "integration"
}
declare enum ScreenBlockType {
    Flow = "flow",
    FieldMapping = "field-mapping",
    DataSource = "data-source",
    Action = "action"
}
interface ScreenBlock {
    type: ScreenBlockType;
    [key: string]: any;
}
interface ScreenSelector {
    id?: string;
    type?: ScreenType;
    key?: string;
    autoCreate?: boolean;
    connectionId?: string;
}
interface UpdateScreenRequest {
    blocks?: ScreenBlock[];
    key?: string;
}
interface CreateScreenRequest extends UpdateScreenRequest {
    type: ScreenType;
}
interface FindScreensQuery extends PaginationQuery {
    type?: ScreenType;
}
interface Screen {
    id: string;
    type: ScreenType;
    key?: string;
    blocks: ScreenBlock[];
}

declare class ScreensAccessor extends ElementListAccessor<Screen, FindScreensQuery, CreateScreenRequest> {
    constructor(client: IntegrationAppApiClient);
}
declare class ScreenAccessor extends ElementAccessor<Screen, UpdateScreenRequest, ScreenSelector> {
    constructor(client: IntegrationAppApiClient, selector: ScreenSelector | string);
}

interface OpenIntegrationAppConfigurationOptions extends OpenConfigurationOptions {
}
declare class IntegrationAppClient extends IntegrationAppApiClient {
    constructor(options: IntegrationAppClientOptions);
    get self(): SelfAccessor;
    get flows(): FlowsAccessor;
    open({ onClose, }?: OpenIntegrationAppConfigurationOptions): Promise<void>;
    action(selector: string | ActionSelector): ActionAccessor;
    get actions(): ActionsAccessor;
    screen(selector: string | ScreenSelector): ScreenAccessor;
    get screens(): ScreensAccessor;
    actionInstance(selector: string | ActionInstanceSelector): ActionInstanceAccessor;
    get actionInstances(): ActionInstancesAccessor;
    flow(selector: string | FlowSelector): FlowAccessor;
    get flowInstances(): FlowInstancesAccessor;
    flowInstance(selector: string | FlowInstanceSelector): FlowInstanceAccessor;
    get dataSourceInstances(): DataSourceInstancesAccessor;
    get dataSources(): DataSourcesAccessor;
    dataSource(selector: string | DataSourceSelector): DataSourceAccessor;
    dataSourceInstance(selector: string | DataSourceInstanceSelector): DataSourceInstanceAccessor;
    get fieldMappings(): FieldMappingsAccessor;
    fieldMapping(selector: string | FieldMappingSelector): FieldMappingAccessor;
    get fieldMappingInstances(): FieldMappingInstancesAccessor;
    fieldMappingInstance(selector: string | FieldMappingInstanceSelector): FieldMappingInstanceAccessor;
    get dataLinkTables(): DataLinkTablesAccessor;
    dataLinkTable(idOrKey: string): DataLinkTableAccessor;
    get dataLinkTableInstances(): DataLinkTableInstancesAccessor;
    dataLinkTableInstance(selector: string | DataLinkTableInstanceSelector): DataLinkTableInstanceAccessor;
    get integrations(): IntegrationsAccessor;
    externalEventSubscriptions(): ExternalEventSubscriptionsAccessor;
    externalEventSubscription(id: string): ExternalEventSubscriptionAccessor;
    integration(identifier: string): IntegrationAccessor;
    get connections(): ConnectionsAccessor;
    connection(connectionSelector: string): ConnectionAccessor;
    get appEventTypes(): AppEventTypesAccessor;
    appEventType(id: string): AppEventTypeAccessor;
    get appEventSubscriptions(): AppEventSubscriptionsAccessor;
    appEventSubscription(selector: string | AppEventSubscriptionSelector): AppEventSubscriptionAccessor;
    get appEvents(): AppEventsAccessor;
    get flowRuns(): FlowRunsAccessor;
    flowRun(id: string): FlowRunAccessor;
    get appDataSchemas(): AppDataSchemasAccessor;
    appDataSchema(id: string): AppDataSchemaAccessor;
    get appDataSchemaInstances(): AppDataSchemaInstancesAccessor;
    appDataSchemaInstance(selector: string | AppDataSchemaInstanceSelector): AppDataSchemaInstanceAccessor;
    customer(selector: string | CustomerSelector): CustomerAccessor;
    get customers(): CustomersAccessor;
    scenario(selector: string): ScenarioAccessor;
    get scenarios(): ScenariosAccessor;
    connectionRequest(connectionId: string, uri: string, data?: any): Promise<any>;
}

export { IntegrationAppClient as default };
