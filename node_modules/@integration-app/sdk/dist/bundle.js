(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.IntegrationAppClient = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var type;
	var hasRequiredType;

	function requireType () {
		if (hasRequiredType) return type;
		hasRequiredType = 1;

		/** @type {import('./type')} */
		type = TypeError;
		return type;
	}

	var global$1 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init$1 () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init$1();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init$1();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString$1 = {}.toString;

	var isArray$2 = Array.isArray || function (arr) {
	  return toString$1.call(arr) == '[object Array]';
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */


	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	kMaxLength();

	function kMaxLength () {
	  return Buffer$1.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$1(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$1 (arg, encodingOrOffset, length) {
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
	    return new Buffer$1(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer$1.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$1._augment = function (arr) {
	  arr.__proto__ = Buffer$1.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$1.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$1.__proto__ = Uint8Array;
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer$1[Symbol.species] === Buffer$1) ;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$1.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$1.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$1.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$1.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer$1.isBuffer = isBuffer$2;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$1.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$1.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$1.concat = function concat (list, length) {
	  if (!isArray$2(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$1.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$1.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$1.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$1.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$1.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer$1.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$1.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$1.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer$1.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$1.compare(this, b) === 0
	};

	Buffer$1.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -2147483648) {
	    byteOffset = -2147483648;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$1.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer$1.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$1.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$1.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$1.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$1(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer$1(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$2(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform$2 = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop$1() {}

	var on = noop$1;
	var addListener = noop$1;
	var once = noop$1;
	var off = noop$1;
	var removeListener = noop$1;
	var removeAllListeners = noop$1;
	var emit = noop$1;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var browser$1 = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform$2,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var inherits$1;
	if (typeof Object.create === 'function'){
	  inherits$1 = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits$1 = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

	var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
	  function getOwnPropertyDescriptors(obj) {
	    var keys = Object.keys(obj);
	    var descriptors = {};
	    for (var i = 0; i < keys.length; i++) {
	      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
	    }
	    return descriptors;
	  };

	var formatRegExp = /%[sdj%]/g;
	function format(f) {
	  if (!isString$1(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject$1(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined$1(global$1.process)) {
	    return function() {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (browser$1.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (browser$1.throwDeprecation) {
	        throw new Error(msg);
	      } else if (browser$1.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined$1(debugEnviron))
	    debugEnviron = browser$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function() {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean$1(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined$1(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined$1(ctx.depth)) ctx.depth = 2;
	  if (isUndefined$1(ctx.colors)) ctx.colors = false;
	  if (isUndefined$1(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction$1(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString$1(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction$1(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp$1(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate$1(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray$1(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction$1(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp$1(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate$1(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp$1(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined$1(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString$1(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber$1(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean$1(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty$1(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty$1(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined$1(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray$1(ar) {
	  return Array.isArray(ar);
	}

	function isBoolean$1(arg) {
	  return typeof arg === 'boolean';
	}

	function isNull(arg) {
	  return arg === null;
	}

	function isNullOrUndefined(arg) {
	  return arg == null;
	}

	function isNumber$1(arg) {
	  return typeof arg === 'number';
	}

	function isString$1(arg) {
	  return typeof arg === 'string';
	}

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}

	function isUndefined$1(arg) {
	  return arg === void 0;
	}

	function isRegExp$1(re) {
	  return isObject$1(re) && objectToString(re) === '[object RegExp]';
	}

	function isObject$1(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isDate$1(d) {
	  return isObject$1(d) && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	  return isObject$1(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}

	function isFunction$1(arg) {
	  return typeof arg === 'function';
	}

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}

	function isBuffer$1(maybeBuf) {
	  return Buffer$1.isBuffer(maybeBuf);
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	function log() {
	  console.log('%s - %s', timestamp(), format.apply(null, arguments));
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject$1(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty$1(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

	function promisify(original) {
	  if (typeof original !== 'function')
	    throw new TypeError('The "original" argument must be of type Function');

	  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
	    var fn = original[kCustomPromisifiedSymbol];
	    if (typeof fn !== 'function') {
	      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
	    }
	    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
	      value: fn, enumerable: false, writable: false, configurable: true
	    });
	    return fn;
	  }

	  function fn() {
	    var promiseResolve, promiseReject;
	    var promise = new Promise(function (resolve, reject) {
	      promiseResolve = resolve;
	      promiseReject = reject;
	    });

	    var args = [];
	    for (var i = 0; i < arguments.length; i++) {
	      args.push(arguments[i]);
	    }
	    args.push(function (err, value) {
	      if (err) {
	        promiseReject(err);
	      } else {
	        promiseResolve(value);
	      }
	    });

	    try {
	      original.apply(this, args);
	    } catch (err) {
	      promiseReject(err);
	    }

	    return promise;
	  }

	  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

	  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
	    value: fn, enumerable: false, writable: false, configurable: true
	  });
	  return Object.defineProperties(
	    fn,
	    getOwnPropertyDescriptors(original)
	  );
	}

	promisify.custom = kCustomPromisifiedSymbol;

	function callbackifyOnRejected(reason, cb) {
	  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
	  // Because `null` is a special error value in callbacks which means "no error
	  // occurred", we error-wrap so the callback consumer can distinguish between
	  // "the promise rejected with null" or "the promise fulfilled with undefined".
	  if (!reason) {
	    var newReason = new Error('Promise was rejected with a falsy value');
	    newReason.reason = reason;
	    reason = newReason;
	  }
	  return cb(reason);
	}

	function callbackify(original) {
	  if (typeof original !== 'function') {
	    throw new TypeError('The "original" argument must be of type Function');
	  }

	  // We DO NOT return the promise as it gives the user a false sense that
	  // the promise is actually somehow related to the callback's execution
	  // and that the callback throwing will reject the promise.
	  function callbackified() {
	    var args = [];
	    for (var i = 0; i < arguments.length; i++) {
	      args.push(arguments[i]);
	    }

	    var maybeCb = args.pop();
	    if (typeof maybeCb !== 'function') {
	      throw new TypeError('The last argument must be of type Function');
	    }
	    var self = this;
	    var cb = function() {
	      return maybeCb.apply(self, arguments);
	    };
	    // In true node style we process the callback on `nextTick` with all the
	    // implications (stack, `uncaughtException`, `async_hooks`)
	    original.apply(this, args)
	      .then(function(ret) { browser$1.nextTick(cb.bind(null, null, ret)); },
	        function(rej) { browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
	  }

	  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
	  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
	  return callbackified;
	}

	var _polyfillNode_util = {
	  inherits: inherits$1,
	  _extend: _extend,
	  log: log,
	  isBuffer: isBuffer$1,
	  isPrimitive: isPrimitive,
	  isFunction: isFunction$1,
	  isError: isError,
	  isDate: isDate$1,
	  isObject: isObject$1,
	  isRegExp: isRegExp$1,
	  isUndefined: isUndefined$1,
	  isSymbol: isSymbol,
	  isString: isString$1,
	  isNumber: isNumber$1,
	  isNullOrUndefined: isNullOrUndefined,
	  isNull: isNull,
	  isBoolean: isBoolean$1,
	  isArray: isArray$1,
	  inspect: inspect,
	  deprecate: deprecate,
	  format: format,
	  debuglog: debuglog,
	  promisify: promisify,
	  callbackify: callbackify,
	};

	var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		_extend: _extend,
		callbackify: callbackify,
		debuglog: debuglog,
		default: _polyfillNode_util,
		deprecate: deprecate,
		format: format,
		inherits: inherits$1,
		inspect: inspect,
		isArray: isArray$1,
		isBoolean: isBoolean$1,
		isBuffer: isBuffer$1,
		isDate: isDate$1,
		isError: isError,
		isFunction: isFunction$1,
		isNull: isNull,
		isNullOrUndefined: isNullOrUndefined,
		isNumber: isNumber$1,
		isObject: isObject$1,
		isPrimitive: isPrimitive,
		isRegExp: isRegExp$1,
		isString: isString$1,
		isSymbol: isSymbol,
		isUndefined: isUndefined$1,
		log: log,
		promisify: promisify
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

	var util_inspect;
	var hasRequiredUtil_inspect;

	function requireUtil_inspect () {
		if (hasRequiredUtil_inspect) return util_inspect;
		hasRequiredUtil_inspect = 1;
		util_inspect = require$$0.inspect;
		return util_inspect;
	}

	var objectInspect;
	var hasRequiredObjectInspect;

	function requireObjectInspect () {
		if (hasRequiredObjectInspect) return objectInspect;
		hasRequiredObjectInspect = 1;
		var hasMap = typeof Map === 'function' && Map.prototype;
		var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
		var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
		var mapForEach = hasMap && Map.prototype.forEach;
		var hasSet = typeof Set === 'function' && Set.prototype;
		var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
		var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
		var setForEach = hasSet && Set.prototype.forEach;
		var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
		var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
		var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
		var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
		var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
		var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
		var booleanValueOf = Boolean.prototype.valueOf;
		var objectToString = Object.prototype.toString;
		var functionToString = Function.prototype.toString;
		var $match = String.prototype.match;
		var $slice = String.prototype.slice;
		var $replace = String.prototype.replace;
		var $toUpperCase = String.prototype.toUpperCase;
		var $toLowerCase = String.prototype.toLowerCase;
		var $test = RegExp.prototype.test;
		var $concat = Array.prototype.concat;
		var $join = Array.prototype.join;
		var $arrSlice = Array.prototype.slice;
		var $floor = Math.floor;
		var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
		var gOPS = Object.getOwnPropertySymbols;
		var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
		var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
		// ie, `has-tostringtag/shams
		var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
		    ? Symbol.toStringTag
		    : null;
		var isEnumerable = Object.prototype.propertyIsEnumerable;

		var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
		    [].__proto__ === Array.prototype // eslint-disable-line no-proto
		        ? function (O) {
		            return O.__proto__; // eslint-disable-line no-proto
		        }
		        : null
		);

		function addNumericSeparator(num, str) {
		    if (
		        num === Infinity
		        || num === -Infinity
		        || num !== num
		        || (num && num > -1e3 && num < 1000)
		        || $test.call(/e/, str)
		    ) {
		        return str;
		    }
		    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
		    if (typeof num === 'number') {
		        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
		        if (int !== num) {
		            var intStr = String(int);
		            var dec = $slice.call(str, intStr.length + 1);
		            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
		        }
		    }
		    return $replace.call(str, sepRegex, '$&_');
		}

		var utilInspect = /*@__PURE__*/ requireUtil_inspect();
		var inspectCustom = utilInspect.custom;
		var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

		var quotes = {
		    __proto__: null,
		    'double': '"',
		    single: "'"
		};
		var quoteREs = {
		    __proto__: null,
		    'double': /(["\\])/g,
		    single: /(['\\])/g
		};

		objectInspect = function inspect_(obj, options, depth, seen) {
		    var opts = options || {};

		    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
		        throw new TypeError('option "quoteStyle" must be "single" or "double"');
		    }
		    if (
		        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
		            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
		            : opts.maxStringLength !== null
		        )
		    ) {
		        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
		    }
		    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
		    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
		        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
		    }

		    if (
		        has(opts, 'indent')
		        && opts.indent !== null
		        && opts.indent !== '\t'
		        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
		    ) {
		        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
		    }
		    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
		        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
		    }
		    var numericSeparator = opts.numericSeparator;

		    if (typeof obj === 'undefined') {
		        return 'undefined';
		    }
		    if (obj === null) {
		        return 'null';
		    }
		    if (typeof obj === 'boolean') {
		        return obj ? 'true' : 'false';
		    }

		    if (typeof obj === 'string') {
		        return inspectString(obj, opts);
		    }
		    if (typeof obj === 'number') {
		        if (obj === 0) {
		            return Infinity / obj > 0 ? '0' : '-0';
		        }
		        var str = String(obj);
		        return numericSeparator ? addNumericSeparator(obj, str) : str;
		    }
		    if (typeof obj === 'bigint') {
		        var bigIntStr = String(obj) + 'n';
		        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
		    }

		    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
		    if (typeof depth === 'undefined') { depth = 0; }
		    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
		        return isArray(obj) ? '[Array]' : '[Object]';
		    }

		    var indent = getIndent(opts, depth);

		    if (typeof seen === 'undefined') {
		        seen = [];
		    } else if (indexOf(seen, obj) >= 0) {
		        return '[Circular]';
		    }

		    function inspect(value, from, noIndent) {
		        if (from) {
		            seen = $arrSlice.call(seen);
		            seen.push(from);
		        }
		        if (noIndent) {
		            var newOpts = {
		                depth: opts.depth
		            };
		            if (has(opts, 'quoteStyle')) {
		                newOpts.quoteStyle = opts.quoteStyle;
		            }
		            return inspect_(value, newOpts, depth + 1, seen);
		        }
		        return inspect_(value, opts, depth + 1, seen);
		    }

		    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
		        var name = nameOf(obj);
		        var keys = arrObjKeys(obj, inspect);
		        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
		    }
		    if (isSymbol(obj)) {
		        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
		        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
		    }
		    if (isElement(obj)) {
		        var s = '<' + $toLowerCase.call(String(obj.nodeName));
		        var attrs = obj.attributes || [];
		        for (var i = 0; i < attrs.length; i++) {
		            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
		        }
		        s += '>';
		        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
		        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
		        return s;
		    }
		    if (isArray(obj)) {
		        if (obj.length === 0) { return '[]'; }
		        var xs = arrObjKeys(obj, inspect);
		        if (indent && !singleLineValues(xs)) {
		            return '[' + indentedJoin(xs, indent) + ']';
		        }
		        return '[ ' + $join.call(xs, ', ') + ' ]';
		    }
		    if (isError(obj)) {
		        var parts = arrObjKeys(obj, inspect);
		        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
		            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
		        }
		        if (parts.length === 0) { return '[' + String(obj) + ']'; }
		        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
		    }
		    if (typeof obj === 'object' && customInspect) {
		        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
		            return utilInspect(obj, { depth: maxDepth - depth });
		        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
		            return obj.inspect();
		        }
		    }
		    if (isMap(obj)) {
		        var mapParts = [];
		        if (mapForEach) {
		            mapForEach.call(obj, function (value, key) {
		                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
		            });
		        }
		        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
		    }
		    if (isSet(obj)) {
		        var setParts = [];
		        if (setForEach) {
		            setForEach.call(obj, function (value) {
		                setParts.push(inspect(value, obj));
		            });
		        }
		        return collectionOf('Set', setSize.call(obj), setParts, indent);
		    }
		    if (isWeakMap(obj)) {
		        return weakCollectionOf('WeakMap');
		    }
		    if (isWeakSet(obj)) {
		        return weakCollectionOf('WeakSet');
		    }
		    if (isWeakRef(obj)) {
		        return weakCollectionOf('WeakRef');
		    }
		    if (isNumber(obj)) {
		        return markBoxed(inspect(Number(obj)));
		    }
		    if (isBigInt(obj)) {
		        return markBoxed(inspect(bigIntValueOf.call(obj)));
		    }
		    if (isBoolean(obj)) {
		        return markBoxed(booleanValueOf.call(obj));
		    }
		    if (isString(obj)) {
		        return markBoxed(inspect(String(obj)));
		    }
		    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
		    /* eslint-env browser */
		    if (typeof window !== 'undefined' && obj === window) {
		        return '{ [object Window] }';
		    }
		    if (
		        (typeof globalThis !== 'undefined' && obj === globalThis)
		        || (typeof commonjsGlobal !== 'undefined' && obj === commonjsGlobal)
		    ) {
		        return '{ [object globalThis] }';
		    }
		    if (!isDate(obj) && !isRegExp(obj)) {
		        var ys = arrObjKeys(obj, inspect);
		        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
		        var protoTag = obj instanceof Object ? '' : 'null prototype';
		        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
		        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
		        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
		        if (ys.length === 0) { return tag + '{}'; }
		        if (indent) {
		            return tag + '{' + indentedJoin(ys, indent) + '}';
		        }
		        return tag + '{ ' + $join.call(ys, ', ') + ' }';
		    }
		    return String(obj);
		};

		function wrapQuotes(s, defaultStyle, opts) {
		    var style = opts.quoteStyle || defaultStyle;
		    var quoteChar = quotes[style];
		    return quoteChar + s + quoteChar;
		}

		function quote(s) {
		    return $replace.call(String(s), /"/g, '&quot;');
		}

		function canTrustToString(obj) {
		    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
		}
		function isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
		function isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
		function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
		function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
		function isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
		function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
		function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

		// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
		function isSymbol(obj) {
		    if (hasShammedSymbols) {
		        return obj && typeof obj === 'object' && obj instanceof Symbol;
		    }
		    if (typeof obj === 'symbol') {
		        return true;
		    }
		    if (!obj || typeof obj !== 'object' || !symToString) {
		        return false;
		    }
		    try {
		        symToString.call(obj);
		        return true;
		    } catch (e) {}
		    return false;
		}

		function isBigInt(obj) {
		    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
		        return false;
		    }
		    try {
		        bigIntValueOf.call(obj);
		        return true;
		    } catch (e) {}
		    return false;
		}

		var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
		function has(obj, key) {
		    return hasOwn.call(obj, key);
		}

		function toStr(obj) {
		    return objectToString.call(obj);
		}

		function nameOf(f) {
		    if (f.name) { return f.name; }
		    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
		    if (m) { return m[1]; }
		    return null;
		}

		function indexOf(xs, x) {
		    if (xs.indexOf) { return xs.indexOf(x); }
		    for (var i = 0, l = xs.length; i < l; i++) {
		        if (xs[i] === x) { return i; }
		    }
		    return -1;
		}

		function isMap(x) {
		    if (!mapSize || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        mapSize.call(x);
		        try {
		            setSize.call(x);
		        } catch (s) {
		            return true;
		        }
		        return x instanceof Map; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isWeakMap(x) {
		    if (!weakMapHas || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        weakMapHas.call(x, weakMapHas);
		        try {
		            weakSetHas.call(x, weakSetHas);
		        } catch (s) {
		            return true;
		        }
		        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isWeakRef(x) {
		    if (!weakRefDeref || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        weakRefDeref.call(x);
		        return true;
		    } catch (e) {}
		    return false;
		}

		function isSet(x) {
		    if (!setSize || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        setSize.call(x);
		        try {
		            mapSize.call(x);
		        } catch (m) {
		            return true;
		        }
		        return x instanceof Set; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isWeakSet(x) {
		    if (!weakSetHas || !x || typeof x !== 'object') {
		        return false;
		    }
		    try {
		        weakSetHas.call(x, weakSetHas);
		        try {
		            weakMapHas.call(x, weakMapHas);
		        } catch (s) {
		            return true;
		        }
		        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
		    } catch (e) {}
		    return false;
		}

		function isElement(x) {
		    if (!x || typeof x !== 'object') { return false; }
		    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
		        return true;
		    }
		    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
		}

		function inspectString(str, opts) {
		    if (str.length > opts.maxStringLength) {
		        var remaining = str.length - opts.maxStringLength;
		        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
		        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
		    }
		    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
		    quoteRE.lastIndex = 0;
		    // eslint-disable-next-line no-control-regex
		    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
		    return wrapQuotes(s, 'single', opts);
		}

		function lowbyte(c) {
		    var n = c.charCodeAt(0);
		    var x = {
		        8: 'b',
		        9: 't',
		        10: 'n',
		        12: 'f',
		        13: 'r'
		    }[n];
		    if (x) { return '\\' + x; }
		    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
		}

		function markBoxed(str) {
		    return 'Object(' + str + ')';
		}

		function weakCollectionOf(type) {
		    return type + ' { ? }';
		}

		function collectionOf(type, size, entries, indent) {
		    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
		    return type + ' (' + size + ') {' + joinedEntries + '}';
		}

		function singleLineValues(xs) {
		    for (var i = 0; i < xs.length; i++) {
		        if (indexOf(xs[i], '\n') >= 0) {
		            return false;
		        }
		    }
		    return true;
		}

		function getIndent(opts, depth) {
		    var baseIndent;
		    if (opts.indent === '\t') {
		        baseIndent = '\t';
		    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
		        baseIndent = $join.call(Array(opts.indent + 1), ' ');
		    } else {
		        return null;
		    }
		    return {
		        base: baseIndent,
		        prev: $join.call(Array(depth + 1), baseIndent)
		    };
		}

		function indentedJoin(xs, indent) {
		    if (xs.length === 0) { return ''; }
		    var lineJoiner = '\n' + indent.prev + indent.base;
		    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
		}

		function arrObjKeys(obj, inspect) {
		    var isArr = isArray(obj);
		    var xs = [];
		    if (isArr) {
		        xs.length = obj.length;
		        for (var i = 0; i < obj.length; i++) {
		            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
		        }
		    }
		    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
		    var symMap;
		    if (hasShammedSymbols) {
		        symMap = {};
		        for (var k = 0; k < syms.length; k++) {
		            symMap['$' + syms[k]] = syms[k];
		        }
		    }

		    for (var key in obj) { // eslint-disable-line no-restricted-syntax
		        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
		        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
		        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
		            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
		            continue; // eslint-disable-line no-restricted-syntax, no-continue
		        } else if ($test.call(/[^\w$]/, key)) {
		            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
		        } else {
		            xs.push(key + ': ' + inspect(obj[key], obj));
		        }
		    }
		    if (typeof gOPS === 'function') {
		        for (var j = 0; j < syms.length; j++) {
		            if (isEnumerable.call(obj, syms[j])) {
		                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
		            }
		        }
		    }
		    return xs;
		}
		return objectInspect;
	}

	var sideChannelList;
	var hasRequiredSideChannelList;

	function requireSideChannelList () {
		if (hasRequiredSideChannelList) return sideChannelList;
		hasRequiredSideChannelList = 1;

		var inspect = /*@__PURE__*/ requireObjectInspect();

		var $TypeError = /*@__PURE__*/ requireType();

		/*
		* This function traverses the list returning the node corresponding to the given key.
		*
		* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
		* By doing so, all the recently used nodes can be accessed relatively quickly.
		*/
		/** @type {import('./list.d.ts').listGetNode} */
		// eslint-disable-next-line consistent-return
		var listGetNode = function (list, key, isDelete) {
			/** @type {typeof list | NonNullable<(typeof list)['next']>} */
			var prev = list;
			/** @type {(typeof list)['next']} */
			var curr;
			// eslint-disable-next-line eqeqeq
			for (; (curr = prev.next) != null; prev = curr) {
				if (curr.key === key) {
					prev.next = curr.next;
					if (!isDelete) {
						// eslint-disable-next-line no-extra-parens
						curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
						list.next = curr; // eslint-disable-line no-param-reassign
					}
					return curr;
				}
			}
		};

		/** @type {import('./list.d.ts').listGet} */
		var listGet = function (objects, key) {
			if (!objects) {
				return void 0;
			}
			var node = listGetNode(objects, key);
			return node && node.value;
		};
		/** @type {import('./list.d.ts').listSet} */
		var listSet = function (objects, key, value) {
			var node = listGetNode(objects, key);
			if (node) {
				node.value = value;
			} else {
				// Prepend the new node to the beginning of the list
				objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
					key: key,
					next: objects.next,
					value: value
				});
			}
		};
		/** @type {import('./list.d.ts').listHas} */
		var listHas = function (objects, key) {
			if (!objects) {
				return false;
			}
			return !!listGetNode(objects, key);
		};
		/** @type {import('./list.d.ts').listDelete} */
		// eslint-disable-next-line consistent-return
		var listDelete = function (objects, key) {
			if (objects) {
				return listGetNode(objects, key, true);
			}
		};

		/** @type {import('.')} */
		sideChannelList = function getSideChannelList() {
			/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
			/** @typedef {Parameters<Channel['get']>[0]} K */
			/** @typedef {Parameters<Channel['set']>[1]} V */

			/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

			/** @type {Channel} */
			var channel = {
				assert: function (key) {
					if (!channel.has(key)) {
						throw new $TypeError('Side channel does not contain ' + inspect(key));
					}
				},
				'delete': function (key) {
					var root = $o && $o.next;
					var deletedNode = listDelete($o, key);
					if (deletedNode && root && root === deletedNode) {
						$o = void 0;
					}
					return !!deletedNode;
				},
				get: function (key) {
					return listGet($o, key);
				},
				has: function (key) {
					return listHas($o, key);
				},
				set: function (key, value) {
					if (!$o) {
						// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
						$o = {
							next: void 0
						};
					}
					// eslint-disable-next-line no-extra-parens
					listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
				}
			};
			// @ts-expect-error TODO: figure out why this is erroring
			return channel;
		};
		return sideChannelList;
	}

	var esObjectAtoms;
	var hasRequiredEsObjectAtoms;

	function requireEsObjectAtoms () {
		if (hasRequiredEsObjectAtoms) return esObjectAtoms;
		hasRequiredEsObjectAtoms = 1;

		/** @type {import('.')} */
		esObjectAtoms = Object;
		return esObjectAtoms;
	}

	var esErrors;
	var hasRequiredEsErrors;

	function requireEsErrors () {
		if (hasRequiredEsErrors) return esErrors;
		hasRequiredEsErrors = 1;

		/** @type {import('.')} */
		esErrors = Error;
		return esErrors;
	}

	var _eval;
	var hasRequired_eval;

	function require_eval () {
		if (hasRequired_eval) return _eval;
		hasRequired_eval = 1;

		/** @type {import('./eval')} */
		_eval = EvalError;
		return _eval;
	}

	var range;
	var hasRequiredRange;

	function requireRange () {
		if (hasRequiredRange) return range;
		hasRequiredRange = 1;

		/** @type {import('./range')} */
		range = RangeError;
		return range;
	}

	var ref;
	var hasRequiredRef;

	function requireRef () {
		if (hasRequiredRef) return ref;
		hasRequiredRef = 1;

		/** @type {import('./ref')} */
		ref = ReferenceError;
		return ref;
	}

	var syntax;
	var hasRequiredSyntax;

	function requireSyntax () {
		if (hasRequiredSyntax) return syntax;
		hasRequiredSyntax = 1;

		/** @type {import('./syntax')} */
		syntax = SyntaxError;
		return syntax;
	}

	var uri;
	var hasRequiredUri;

	function requireUri () {
		if (hasRequiredUri) return uri;
		hasRequiredUri = 1;

		/** @type {import('./uri')} */
		uri = URIError;
		return uri;
	}

	var abs;
	var hasRequiredAbs;

	function requireAbs () {
		if (hasRequiredAbs) return abs;
		hasRequiredAbs = 1;

		/** @type {import('./abs')} */
		abs = Math.abs;
		return abs;
	}

	var floor;
	var hasRequiredFloor;

	function requireFloor () {
		if (hasRequiredFloor) return floor;
		hasRequiredFloor = 1;

		/** @type {import('./floor')} */
		floor = Math.floor;
		return floor;
	}

	var max;
	var hasRequiredMax;

	function requireMax () {
		if (hasRequiredMax) return max;
		hasRequiredMax = 1;

		/** @type {import('./max')} */
		max = Math.max;
		return max;
	}

	var min;
	var hasRequiredMin;

	function requireMin () {
		if (hasRequiredMin) return min;
		hasRequiredMin = 1;

		/** @type {import('./min')} */
		min = Math.min;
		return min;
	}

	var pow;
	var hasRequiredPow;

	function requirePow () {
		if (hasRequiredPow) return pow;
		hasRequiredPow = 1;

		/** @type {import('./pow')} */
		pow = Math.pow;
		return pow;
	}

	var round;
	var hasRequiredRound;

	function requireRound () {
		if (hasRequiredRound) return round;
		hasRequiredRound = 1;

		/** @type {import('./round')} */
		round = Math.round;
		return round;
	}

	var _isNaN;
	var hasRequired_isNaN;

	function require_isNaN () {
		if (hasRequired_isNaN) return _isNaN;
		hasRequired_isNaN = 1;

		/** @type {import('./isNaN')} */
		_isNaN = Number.isNaN || function isNaN(a) {
			return a !== a;
		};
		return _isNaN;
	}

	var sign;
	var hasRequiredSign;

	function requireSign () {
		if (hasRequiredSign) return sign;
		hasRequiredSign = 1;

		var $isNaN = /*@__PURE__*/ require_isNaN();

		/** @type {import('./sign')} */
		sign = function sign(number) {
			if ($isNaN(number) || number === 0) {
				return number;
			}
			return number < 0 ? -1 : 1;
		};
		return sign;
	}

	var gOPD;
	var hasRequiredGOPD;

	function requireGOPD () {
		if (hasRequiredGOPD) return gOPD;
		hasRequiredGOPD = 1;

		/** @type {import('./gOPD')} */
		gOPD = Object.getOwnPropertyDescriptor;
		return gOPD;
	}

	var gopd;
	var hasRequiredGopd;

	function requireGopd () {
		if (hasRequiredGopd) return gopd;
		hasRequiredGopd = 1;

		/** @type {import('.')} */
		var $gOPD = /*@__PURE__*/ requireGOPD();

		if ($gOPD) {
			try {
				$gOPD([], 'length');
			} catch (e) {
				// IE 8 has a broken gOPD
				$gOPD = null;
			}
		}

		gopd = $gOPD;
		return gopd;
	}

	var esDefineProperty;
	var hasRequiredEsDefineProperty;

	function requireEsDefineProperty () {
		if (hasRequiredEsDefineProperty) return esDefineProperty;
		hasRequiredEsDefineProperty = 1;

		/** @type {import('.')} */
		var $defineProperty = Object.defineProperty || false;
		if ($defineProperty) {
			try {
				$defineProperty({}, 'a', { value: 1 });
			} catch (e) {
				// IE 8 has a broken defineProperty
				$defineProperty = false;
			}
		}

		esDefineProperty = $defineProperty;
		return esDefineProperty;
	}

	var shams;
	var hasRequiredShams;

	function requireShams () {
		if (hasRequiredShams) return shams;
		hasRequiredShams = 1;

		/** @type {import('./shams')} */
		/* eslint complexity: [2, 18], max-statements: [2, 33] */
		shams = function hasSymbols() {
			if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
			if (typeof Symbol.iterator === 'symbol') { return true; }

			/** @type {{ [k in symbol]?: unknown }} */
			var obj = {};
			var sym = Symbol('test');
			var symObj = Object(sym);
			if (typeof sym === 'string') { return false; }

			if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
			if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

			// temp disabled per https://github.com/ljharb/object.assign/issues/17
			// if (sym instanceof Symbol) { return false; }
			// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
			// if (!(symObj instanceof Symbol)) { return false; }

			// if (typeof Symbol.prototype.toString !== 'function') { return false; }
			// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

			var symVal = 42;
			obj[sym] = symVal;
			for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
			if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

			if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

			var syms = Object.getOwnPropertySymbols(obj);
			if (syms.length !== 1 || syms[0] !== sym) { return false; }

			if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

			if (typeof Object.getOwnPropertyDescriptor === 'function') {
				// eslint-disable-next-line no-extra-parens
				var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
				if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
			}

			return true;
		};
		return shams;
	}

	var hasSymbols;
	var hasRequiredHasSymbols;

	function requireHasSymbols () {
		if (hasRequiredHasSymbols) return hasSymbols;
		hasRequiredHasSymbols = 1;

		var origSymbol = typeof Symbol !== 'undefined' && Symbol;
		var hasSymbolSham = requireShams();

		/** @type {import('.')} */
		hasSymbols = function hasNativeSymbols() {
			if (typeof origSymbol !== 'function') { return false; }
			if (typeof Symbol !== 'function') { return false; }
			if (typeof origSymbol('foo') !== 'symbol') { return false; }
			if (typeof Symbol('bar') !== 'symbol') { return false; }

			return hasSymbolSham();
		};
		return hasSymbols;
	}

	var Reflect_getPrototypeOf;
	var hasRequiredReflect_getPrototypeOf;

	function requireReflect_getPrototypeOf () {
		if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
		hasRequiredReflect_getPrototypeOf = 1;

		/** @type {import('./Reflect.getPrototypeOf')} */
		Reflect_getPrototypeOf = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;
		return Reflect_getPrototypeOf;
	}

	var Object_getPrototypeOf;
	var hasRequiredObject_getPrototypeOf;

	function requireObject_getPrototypeOf () {
		if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
		hasRequiredObject_getPrototypeOf = 1;

		var $Object = /*@__PURE__*/ requireEsObjectAtoms();

		/** @type {import('./Object.getPrototypeOf')} */
		Object_getPrototypeOf = $Object.getPrototypeOf || null;
		return Object_getPrototypeOf;
	}

	var implementation;
	var hasRequiredImplementation;

	function requireImplementation () {
		if (hasRequiredImplementation) return implementation;
		hasRequiredImplementation = 1;

		/* eslint no-invalid-this: 1 */

		var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
		var toStr = Object.prototype.toString;
		var max = Math.max;
		var funcType = '[object Function]';

		var concatty = function concatty(a, b) {
		    var arr = [];

		    for (var i = 0; i < a.length; i += 1) {
		        arr[i] = a[i];
		    }
		    for (var j = 0; j < b.length; j += 1) {
		        arr[j + a.length] = b[j];
		    }

		    return arr;
		};

		var slicy = function slicy(arrLike, offset) {
		    var arr = [];
		    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
		        arr[j] = arrLike[i];
		    }
		    return arr;
		};

		var joiny = function (arr, joiner) {
		    var str = '';
		    for (var i = 0; i < arr.length; i += 1) {
		        str += arr[i];
		        if (i + 1 < arr.length) {
		            str += joiner;
		        }
		    }
		    return str;
		};

		implementation = function bind(that) {
		    var target = this;
		    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
		        throw new TypeError(ERROR_MESSAGE + target);
		    }
		    var args = slicy(arguments, 1);

		    var bound;
		    var binder = function () {
		        if (this instanceof bound) {
		            var result = target.apply(
		                this,
		                concatty(args, arguments)
		            );
		            if (Object(result) === result) {
		                return result;
		            }
		            return this;
		        }
		        return target.apply(
		            that,
		            concatty(args, arguments)
		        );

		    };

		    var boundLength = max(0, target.length - args.length);
		    var boundArgs = [];
		    for (var i = 0; i < boundLength; i++) {
		        boundArgs[i] = '$' + i;
		    }

		    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

		    if (target.prototype) {
		        var Empty = function Empty() {};
		        Empty.prototype = target.prototype;
		        bound.prototype = new Empty();
		        Empty.prototype = null;
		    }

		    return bound;
		};
		return implementation;
	}

	var functionBind;
	var hasRequiredFunctionBind;

	function requireFunctionBind () {
		if (hasRequiredFunctionBind) return functionBind;
		hasRequiredFunctionBind = 1;

		var implementation = requireImplementation();

		functionBind = Function.prototype.bind || implementation;
		return functionBind;
	}

	var functionCall;
	var hasRequiredFunctionCall;

	function requireFunctionCall () {
		if (hasRequiredFunctionCall) return functionCall;
		hasRequiredFunctionCall = 1;

		/** @type {import('./functionCall')} */
		functionCall = Function.prototype.call;
		return functionCall;
	}

	var functionApply;
	var hasRequiredFunctionApply;

	function requireFunctionApply () {
		if (hasRequiredFunctionApply) return functionApply;
		hasRequiredFunctionApply = 1;

		/** @type {import('./functionApply')} */
		functionApply = Function.prototype.apply;
		return functionApply;
	}

	var reflectApply;
	var hasRequiredReflectApply;

	function requireReflectApply () {
		if (hasRequiredReflectApply) return reflectApply;
		hasRequiredReflectApply = 1;

		/** @type {import('./reflectApply')} */
		reflectApply = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
		return reflectApply;
	}

	var actualApply;
	var hasRequiredActualApply;

	function requireActualApply () {
		if (hasRequiredActualApply) return actualApply;
		hasRequiredActualApply = 1;

		var bind = requireFunctionBind();

		var $apply = requireFunctionApply();
		var $call = requireFunctionCall();
		var $reflectApply = requireReflectApply();

		/** @type {import('./actualApply')} */
		actualApply = $reflectApply || bind.call($call, $apply);
		return actualApply;
	}

	var callBindApplyHelpers;
	var hasRequiredCallBindApplyHelpers;

	function requireCallBindApplyHelpers () {
		if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
		hasRequiredCallBindApplyHelpers = 1;

		var bind = requireFunctionBind();
		var $TypeError = /*@__PURE__*/ requireType();

		var $call = requireFunctionCall();
		var $actualApply = requireActualApply();

		/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
		callBindApplyHelpers = function callBindBasic(args) {
			if (args.length < 1 || typeof args[0] !== 'function') {
				throw new $TypeError('a function is required');
			}
			return $actualApply(bind, $call, args);
		};
		return callBindApplyHelpers;
	}

	var get;
	var hasRequiredGet;

	function requireGet () {
		if (hasRequiredGet) return get;
		hasRequiredGet = 1;

		var callBind = requireCallBindApplyHelpers();
		var gOPD = /*@__PURE__*/ requireGopd();

		var hasProtoAccessor;
		try {
			// eslint-disable-next-line no-extra-parens, no-proto
			hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
		} catch (e) {
			if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
				throw e;
			}
		}

		// eslint-disable-next-line no-extra-parens
		var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

		var $Object = Object;
		var $getPrototypeOf = $Object.getPrototypeOf;

		/** @type {import('./get')} */
		get = desc && typeof desc.get === 'function'
			? callBind([desc.get])
			: typeof $getPrototypeOf === 'function'
				? /** @type {import('./get')} */ function getDunder(value) {
					// eslint-disable-next-line eqeqeq
					return $getPrototypeOf(value == null ? value : $Object(value));
				}
				: false;
		return get;
	}

	var getProto;
	var hasRequiredGetProto;

	function requireGetProto () {
		if (hasRequiredGetProto) return getProto;
		hasRequiredGetProto = 1;

		var reflectGetProto = requireReflect_getPrototypeOf();
		var originalGetProto = requireObject_getPrototypeOf();

		var getDunderProto = /*@__PURE__*/ requireGet();

		/** @type {import('.')} */
		getProto = reflectGetProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return reflectGetProto(O);
			}
			: originalGetProto
				? function getProto(O) {
					if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
						throw new TypeError('getProto: not an object');
					}
					// @ts-expect-error TS can't narrow inside a closure, for some reason
					return originalGetProto(O);
				}
				: getDunderProto
					? function getProto(O) {
						// @ts-expect-error TS can't narrow inside a closure, for some reason
						return getDunderProto(O);
					}
					: null;
		return getProto;
	}

	var hasown;
	var hasRequiredHasown;

	function requireHasown () {
		if (hasRequiredHasown) return hasown;
		hasRequiredHasown = 1;

		var call = Function.prototype.call;
		var $hasOwn = Object.prototype.hasOwnProperty;
		var bind = requireFunctionBind();

		/** @type {import('.')} */
		hasown = bind.call(call, $hasOwn);
		return hasown;
	}

	var getIntrinsic;
	var hasRequiredGetIntrinsic;

	function requireGetIntrinsic () {
		if (hasRequiredGetIntrinsic) return getIntrinsic;
		hasRequiredGetIntrinsic = 1;

		var undefined$1;

		var $Object = /*@__PURE__*/ requireEsObjectAtoms();

		var $Error = /*@__PURE__*/ requireEsErrors();
		var $EvalError = /*@__PURE__*/ require_eval();
		var $RangeError = /*@__PURE__*/ requireRange();
		var $ReferenceError = /*@__PURE__*/ requireRef();
		var $SyntaxError = /*@__PURE__*/ requireSyntax();
		var $TypeError = /*@__PURE__*/ requireType();
		var $URIError = /*@__PURE__*/ requireUri();

		var abs = /*@__PURE__*/ requireAbs();
		var floor = /*@__PURE__*/ requireFloor();
		var max = /*@__PURE__*/ requireMax();
		var min = /*@__PURE__*/ requireMin();
		var pow = /*@__PURE__*/ requirePow();
		var round = /*@__PURE__*/ requireRound();
		var sign = /*@__PURE__*/ requireSign();

		var $Function = Function;

		// eslint-disable-next-line consistent-return
		var getEvalledConstructor = function (expressionSyntax) {
			try {
				return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
			} catch (e) {}
		};

		var $gOPD = /*@__PURE__*/ requireGopd();
		var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

		var throwTypeError = function () {
			throw new $TypeError();
		};
		var ThrowTypeError = $gOPD
			? (function () {
				try {
					// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
					arguments.callee; // IE 8 does not throw here
					return throwTypeError;
				} catch (calleeThrows) {
					try {
						// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
						return $gOPD(arguments, 'callee').get;
					} catch (gOPDthrows) {
						return throwTypeError;
					}
				}
			}())
			: throwTypeError;

		var hasSymbols = requireHasSymbols()();

		var getProto = requireGetProto();
		var $ObjectGPO = requireObject_getPrototypeOf();
		var $ReflectGPO = requireReflect_getPrototypeOf();

		var $apply = requireFunctionApply();
		var $call = requireFunctionCall();

		var needsEval = {};

		var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

		var INTRINSICS = {
			__proto__: null,
			'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
			'%Array%': Array,
			'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
			'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
			'%AsyncFromSyncIteratorPrototype%': undefined$1,
			'%AsyncFunction%': needsEval,
			'%AsyncGenerator%': needsEval,
			'%AsyncGeneratorFunction%': needsEval,
			'%AsyncIteratorPrototype%': needsEval,
			'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
			'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
			'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
			'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
			'%Boolean%': Boolean,
			'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
			'%Date%': Date,
			'%decodeURI%': decodeURI,
			'%decodeURIComponent%': decodeURIComponent,
			'%encodeURI%': encodeURI,
			'%encodeURIComponent%': encodeURIComponent,
			'%Error%': $Error,
			'%eval%': eval, // eslint-disable-line no-eval
			'%EvalError%': $EvalError,
			'%Float16Array%': typeof Float16Array === 'undefined' ? undefined$1 : Float16Array,
			'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
			'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
			'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
			'%Function%': $Function,
			'%GeneratorFunction%': needsEval,
			'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
			'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
			'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
			'%isFinite%': isFinite,
			'%isNaN%': isNaN,
			'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
			'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
			'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
			'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
			'%Math%': Math,
			'%Number%': Number,
			'%Object%': $Object,
			'%Object.getOwnPropertyDescriptor%': $gOPD,
			'%parseFloat%': parseFloat,
			'%parseInt%': parseInt,
			'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
			'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
			'%RangeError%': $RangeError,
			'%ReferenceError%': $ReferenceError,
			'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
			'%RegExp%': RegExp,
			'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
			'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
			'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
			'%String%': String,
			'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
			'%Symbol%': hasSymbols ? Symbol : undefined$1,
			'%SyntaxError%': $SyntaxError,
			'%ThrowTypeError%': ThrowTypeError,
			'%TypedArray%': TypedArray,
			'%TypeError%': $TypeError,
			'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
			'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
			'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
			'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
			'%URIError%': $URIError,
			'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
			'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
			'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,

			'%Function.prototype.call%': $call,
			'%Function.prototype.apply%': $apply,
			'%Object.defineProperty%': $defineProperty,
			'%Object.getPrototypeOf%': $ObjectGPO,
			'%Math.abs%': abs,
			'%Math.floor%': floor,
			'%Math.max%': max,
			'%Math.min%': min,
			'%Math.pow%': pow,
			'%Math.round%': round,
			'%Math.sign%': sign,
			'%Reflect.getPrototypeOf%': $ReflectGPO
		};

		if (getProto) {
			try {
				null.error; // eslint-disable-line no-unused-expressions
			} catch (e) {
				// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
				var errorProto = getProto(getProto(e));
				INTRINSICS['%Error.prototype%'] = errorProto;
			}
		}

		var doEval = function doEval(name) {
			var value;
			if (name === '%AsyncFunction%') {
				value = getEvalledConstructor('async function () {}');
			} else if (name === '%GeneratorFunction%') {
				value = getEvalledConstructor('function* () {}');
			} else if (name === '%AsyncGeneratorFunction%') {
				value = getEvalledConstructor('async function* () {}');
			} else if (name === '%AsyncGenerator%') {
				var fn = doEval('%AsyncGeneratorFunction%');
				if (fn) {
					value = fn.prototype;
				}
			} else if (name === '%AsyncIteratorPrototype%') {
				var gen = doEval('%AsyncGenerator%');
				if (gen && getProto) {
					value = getProto(gen.prototype);
				}
			}

			INTRINSICS[name] = value;

			return value;
		};

		var LEGACY_ALIASES = {
			__proto__: null,
			'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
			'%ArrayPrototype%': ['Array', 'prototype'],
			'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
			'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
			'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
			'%ArrayProto_values%': ['Array', 'prototype', 'values'],
			'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
			'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
			'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
			'%BooleanPrototype%': ['Boolean', 'prototype'],
			'%DataViewPrototype%': ['DataView', 'prototype'],
			'%DatePrototype%': ['Date', 'prototype'],
			'%ErrorPrototype%': ['Error', 'prototype'],
			'%EvalErrorPrototype%': ['EvalError', 'prototype'],
			'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
			'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
			'%FunctionPrototype%': ['Function', 'prototype'],
			'%Generator%': ['GeneratorFunction', 'prototype'],
			'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
			'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
			'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
			'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
			'%JSONParse%': ['JSON', 'parse'],
			'%JSONStringify%': ['JSON', 'stringify'],
			'%MapPrototype%': ['Map', 'prototype'],
			'%NumberPrototype%': ['Number', 'prototype'],
			'%ObjectPrototype%': ['Object', 'prototype'],
			'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
			'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
			'%PromisePrototype%': ['Promise', 'prototype'],
			'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
			'%Promise_all%': ['Promise', 'all'],
			'%Promise_reject%': ['Promise', 'reject'],
			'%Promise_resolve%': ['Promise', 'resolve'],
			'%RangeErrorPrototype%': ['RangeError', 'prototype'],
			'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
			'%RegExpPrototype%': ['RegExp', 'prototype'],
			'%SetPrototype%': ['Set', 'prototype'],
			'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
			'%StringPrototype%': ['String', 'prototype'],
			'%SymbolPrototype%': ['Symbol', 'prototype'],
			'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
			'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
			'%TypeErrorPrototype%': ['TypeError', 'prototype'],
			'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
			'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
			'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
			'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
			'%URIErrorPrototype%': ['URIError', 'prototype'],
			'%WeakMapPrototype%': ['WeakMap', 'prototype'],
			'%WeakSetPrototype%': ['WeakSet', 'prototype']
		};

		var bind = requireFunctionBind();
		var hasOwn = /*@__PURE__*/ requireHasown();
		var $concat = bind.call($call, Array.prototype.concat);
		var $spliceApply = bind.call($apply, Array.prototype.splice);
		var $replace = bind.call($call, String.prototype.replace);
		var $strSlice = bind.call($call, String.prototype.slice);
		var $exec = bind.call($call, RegExp.prototype.exec);

		/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
		var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
		var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
		var stringToPath = function stringToPath(string) {
			var first = $strSlice(string, 0, 1);
			var last = $strSlice(string, -1);
			if (first === '%' && last !== '%') {
				throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
			} else if (last === '%' && first !== '%') {
				throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
			}
			var result = [];
			$replace(string, rePropName, function (match, number, quote, subString) {
				result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
			});
			return result;
		};
		/* end adaptation */

		var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
			var intrinsicName = name;
			var alias;
			if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
				alias = LEGACY_ALIASES[intrinsicName];
				intrinsicName = '%' + alias[0] + '%';
			}

			if (hasOwn(INTRINSICS, intrinsicName)) {
				var value = INTRINSICS[intrinsicName];
				if (value === needsEval) {
					value = doEval(intrinsicName);
				}
				if (typeof value === 'undefined' && !allowMissing) {
					throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
				}

				return {
					alias: alias,
					name: intrinsicName,
					value: value
				};
			}

			throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
		};

		getIntrinsic = function GetIntrinsic(name, allowMissing) {
			if (typeof name !== 'string' || name.length === 0) {
				throw new $TypeError('intrinsic name must be a non-empty string');
			}
			if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
				throw new $TypeError('"allowMissing" argument must be a boolean');
			}

			if ($exec(/^%?[^%]*%?$/, name) === null) {
				throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
			}
			var parts = stringToPath(name);
			var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

			var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
			var intrinsicRealName = intrinsic.name;
			var value = intrinsic.value;
			var skipFurtherCaching = false;

			var alias = intrinsic.alias;
			if (alias) {
				intrinsicBaseName = alias[0];
				$spliceApply(parts, $concat([0, 1], alias));
			}

			for (var i = 1, isOwn = true; i < parts.length; i += 1) {
				var part = parts[i];
				var first = $strSlice(part, 0, 1);
				var last = $strSlice(part, -1);
				if (
					(
						(first === '"' || first === "'" || first === '`')
						|| (last === '"' || last === "'" || last === '`')
					)
					&& first !== last
				) {
					throw new $SyntaxError('property names with quotes must have matching quotes');
				}
				if (part === 'constructor' || !isOwn) {
					skipFurtherCaching = true;
				}

				intrinsicBaseName += '.' + part;
				intrinsicRealName = '%' + intrinsicBaseName + '%';

				if (hasOwn(INTRINSICS, intrinsicRealName)) {
					value = INTRINSICS[intrinsicRealName];
				} else if (value != null) {
					if (!(part in value)) {
						if (!allowMissing) {
							throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
						}
						return void 0;
					}
					if ($gOPD && (i + 1) >= parts.length) {
						var desc = $gOPD(value, part);
						isOwn = !!desc;

						// By convention, when a data property is converted to an accessor
						// property to emulate a data property that does not suffer from
						// the override mistake, that accessor's getter is marked with
						// an `originalValue` property. Here, when we detect this, we
						// uphold the illusion by pretending to see that original data
						// property, i.e., returning the value rather than the getter
						// itself.
						if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
							value = desc.get;
						} else {
							value = value[part];
						}
					} else {
						isOwn = hasOwn(value, part);
						value = value[part];
					}

					if (isOwn && !skipFurtherCaching) {
						INTRINSICS[intrinsicRealName] = value;
					}
				}
			}
			return value;
		};
		return getIntrinsic;
	}

	var callBound;
	var hasRequiredCallBound;

	function requireCallBound () {
		if (hasRequiredCallBound) return callBound;
		hasRequiredCallBound = 1;

		var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

		var callBindBasic = requireCallBindApplyHelpers();

		/** @type {(thisArg: string, searchString: string, position?: number) => number} */
		var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

		/** @type {import('.')} */
		callBound = function callBoundIntrinsic(name, allowMissing) {
			/* eslint no-extra-parens: 0 */

			var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
			if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
				return callBindBasic(/** @type {const} */ ([intrinsic]));
			}
			return intrinsic;
		};
		return callBound;
	}

	var sideChannelMap;
	var hasRequiredSideChannelMap;

	function requireSideChannelMap () {
		if (hasRequiredSideChannelMap) return sideChannelMap;
		hasRequiredSideChannelMap = 1;

		var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
		var callBound = /*@__PURE__*/ requireCallBound();
		var inspect = /*@__PURE__*/ requireObjectInspect();

		var $TypeError = /*@__PURE__*/ requireType();
		var $Map = GetIntrinsic('%Map%', true);

		/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
		var $mapGet = callBound('Map.prototype.get', true);
		/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
		var $mapSet = callBound('Map.prototype.set', true);
		/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
		var $mapHas = callBound('Map.prototype.has', true);
		/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
		var $mapDelete = callBound('Map.prototype.delete', true);
		/** @type {<K, V>(thisArg: Map<K, V>) => number} */
		var $mapSize = callBound('Map.prototype.size', true);

		/** @type {import('.')} */
		sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
			/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
			/** @typedef {Parameters<Channel['get']>[0]} K */
			/** @typedef {Parameters<Channel['set']>[1]} V */

			/** @type {Map<K, V> | undefined} */ var $m;

			/** @type {Channel} */
			var channel = {
				assert: function (key) {
					if (!channel.has(key)) {
						throw new $TypeError('Side channel does not contain ' + inspect(key));
					}
				},
				'delete': function (key) {
					if ($m) {
						var result = $mapDelete($m, key);
						if ($mapSize($m) === 0) {
							$m = void 0;
						}
						return result;
					}
					return false;
				},
				get: function (key) { // eslint-disable-line consistent-return
					if ($m) {
						return $mapGet($m, key);
					}
				},
				has: function (key) {
					if ($m) {
						return $mapHas($m, key);
					}
					return false;
				},
				set: function (key, value) {
					if (!$m) {
						// @ts-expect-error TS can't handle narrowing a variable inside a closure
						$m = new $Map();
					}
					$mapSet($m, key, value);
				}
			};

			// @ts-expect-error TODO: figure out why TS is erroring here
			return channel;
		};
		return sideChannelMap;
	}

	var sideChannelWeakmap;
	var hasRequiredSideChannelWeakmap;

	function requireSideChannelWeakmap () {
		if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
		hasRequiredSideChannelWeakmap = 1;

		var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
		var callBound = /*@__PURE__*/ requireCallBound();
		var inspect = /*@__PURE__*/ requireObjectInspect();
		var getSideChannelMap = requireSideChannelMap();

		var $TypeError = /*@__PURE__*/ requireType();
		var $WeakMap = GetIntrinsic('%WeakMap%', true);

		/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
		var $weakMapGet = callBound('WeakMap.prototype.get', true);
		/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
		var $weakMapSet = callBound('WeakMap.prototype.set', true);
		/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
		var $weakMapHas = callBound('WeakMap.prototype.has', true);
		/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
		var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

		/** @type {import('.')} */
		sideChannelWeakmap = $WeakMap
			? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
				/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
				/** @typedef {Parameters<Channel['get']>[0]} K */
				/** @typedef {Parameters<Channel['set']>[1]} V */

				/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
				/** @type {Channel | undefined} */ var $m;

				/** @type {Channel} */
				var channel = {
					assert: function (key) {
						if (!channel.has(key)) {
							throw new $TypeError('Side channel does not contain ' + inspect(key));
						}
					},
					'delete': function (key) {
						if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
							if ($wm) {
								return $weakMapDelete($wm, key);
							}
						} else if (getSideChannelMap) {
							if ($m) {
								return $m['delete'](key);
							}
						}
						return false;
					},
					get: function (key) {
						if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
							if ($wm) {
								return $weakMapGet($wm, key);
							}
						}
						return $m && $m.get(key);
					},
					has: function (key) {
						if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
							if ($wm) {
								return $weakMapHas($wm, key);
							}
						}
						return !!$m && $m.has(key);
					},
					set: function (key, value) {
						if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
							if (!$wm) {
								$wm = new $WeakMap();
							}
							$weakMapSet($wm, key, value);
						} else if (getSideChannelMap) {
							if (!$m) {
								$m = getSideChannelMap();
							}
							// eslint-disable-next-line no-extra-parens
							/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
						}
					}
				};

				// @ts-expect-error TODO: figure out why this is erroring
				return channel;
			}
			: getSideChannelMap;
		return sideChannelWeakmap;
	}

	var sideChannel;
	var hasRequiredSideChannel;

	function requireSideChannel () {
		if (hasRequiredSideChannel) return sideChannel;
		hasRequiredSideChannel = 1;

		var $TypeError = /*@__PURE__*/ requireType();
		var inspect = /*@__PURE__*/ requireObjectInspect();
		var getSideChannelList = requireSideChannelList();
		var getSideChannelMap = requireSideChannelMap();
		var getSideChannelWeakMap = requireSideChannelWeakmap();

		var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

		/** @type {import('.')} */
		sideChannel = function getSideChannel() {
			/** @typedef {ReturnType<typeof getSideChannel>} Channel */

			/** @type {Channel | undefined} */ var $channelData;

			/** @type {Channel} */
			var channel = {
				assert: function (key) {
					if (!channel.has(key)) {
						throw new $TypeError('Side channel does not contain ' + inspect(key));
					}
				},
				'delete': function (key) {
					return !!$channelData && $channelData['delete'](key);
				},
				get: function (key) {
					return $channelData && $channelData.get(key);
				},
				has: function (key) {
					return !!$channelData && $channelData.has(key);
				},
				set: function (key, value) {
					if (!$channelData) {
						$channelData = makeChannel();
					}

					$channelData.set(key, value);
				}
			};
			// @ts-expect-error TODO: figure out why this is erroring
			return channel;
		};
		return sideChannel;
	}

	var formats;
	var hasRequiredFormats;

	function requireFormats () {
		if (hasRequiredFormats) return formats;
		hasRequiredFormats = 1;

		var replace = String.prototype.replace;
		var percentTwenties = /%20/g;

		var Format = {
		    RFC1738: 'RFC1738',
		    RFC3986: 'RFC3986'
		};

		formats = {
		    'default': Format.RFC3986,
		    formatters: {
		        RFC1738: function (value) {
		            return replace.call(value, percentTwenties, '+');
		        },
		        RFC3986: function (value) {
		            return String(value);
		        }
		    },
		    RFC1738: Format.RFC1738,
		    RFC3986: Format.RFC3986
		};
		return formats;
	}

	var utils$3;
	var hasRequiredUtils$1;

	function requireUtils$1 () {
		if (hasRequiredUtils$1) return utils$3;
		hasRequiredUtils$1 = 1;

		var formats = /*@__PURE__*/ requireFormats();

		var has = Object.prototype.hasOwnProperty;
		var isArray = Array.isArray;

		var hexTable = (function () {
		    var array = [];
		    for (var i = 0; i < 256; ++i) {
		        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
		    }

		    return array;
		}());

		var compactQueue = function compactQueue(queue) {
		    while (queue.length > 1) {
		        var item = queue.pop();
		        var obj = item.obj[item.prop];

		        if (isArray(obj)) {
		            var compacted = [];

		            for (var j = 0; j < obj.length; ++j) {
		                if (typeof obj[j] !== 'undefined') {
		                    compacted.push(obj[j]);
		                }
		            }

		            item.obj[item.prop] = compacted;
		        }
		    }
		};

		var arrayToObject = function arrayToObject(source, options) {
		    var obj = options && options.plainObjects ? { __proto__: null } : {};
		    for (var i = 0; i < source.length; ++i) {
		        if (typeof source[i] !== 'undefined') {
		            obj[i] = source[i];
		        }
		    }

		    return obj;
		};

		var merge = function merge(target, source, options) {
		    /* eslint no-param-reassign: 0 */
		    if (!source) {
		        return target;
		    }

		    if (typeof source !== 'object' && typeof source !== 'function') {
		        if (isArray(target)) {
		            target.push(source);
		        } else if (target && typeof target === 'object') {
		            if (
		                (options && (options.plainObjects || options.allowPrototypes))
		                || !has.call(Object.prototype, source)
		            ) {
		                target[source] = true;
		            }
		        } else {
		            return [target, source];
		        }

		        return target;
		    }

		    if (!target || typeof target !== 'object') {
		        return [target].concat(source);
		    }

		    var mergeTarget = target;
		    if (isArray(target) && !isArray(source)) {
		        mergeTarget = arrayToObject(target, options);
		    }

		    if (isArray(target) && isArray(source)) {
		        source.forEach(function (item, i) {
		            if (has.call(target, i)) {
		                var targetItem = target[i];
		                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
		                    target[i] = merge(targetItem, item, options);
		                } else {
		                    target.push(item);
		                }
		            } else {
		                target[i] = item;
		            }
		        });
		        return target;
		    }

		    return Object.keys(source).reduce(function (acc, key) {
		        var value = source[key];

		        if (has.call(acc, key)) {
		            acc[key] = merge(acc[key], value, options);
		        } else {
		            acc[key] = value;
		        }
		        return acc;
		    }, mergeTarget);
		};

		var assign = function assignSingleSource(target, source) {
		    return Object.keys(source).reduce(function (acc, key) {
		        acc[key] = source[key];
		        return acc;
		    }, target);
		};

		var decode = function (str, defaultDecoder, charset) {
		    var strWithoutPlus = str.replace(/\+/g, ' ');
		    if (charset === 'iso-8859-1') {
		        // unescape never throws, no try...catch needed:
		        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		    }
		    // utf-8
		    try {
		        return decodeURIComponent(strWithoutPlus);
		    } catch (e) {
		        return strWithoutPlus;
		    }
		};

		var limit = 1024;

		/* eslint operator-linebreak: [2, "before"] */

		var encode = function encode(str, defaultEncoder, charset, kind, format) {
		    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
		    // It has been adapted here for stricter adherence to RFC 3986
		    if (str.length === 0) {
		        return str;
		    }

		    var string = str;
		    if (typeof str === 'symbol') {
		        string = Symbol.prototype.toString.call(str);
		    } else if (typeof str !== 'string') {
		        string = String(str);
		    }

		    if (charset === 'iso-8859-1') {
		        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
		            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
		        });
		    }

		    var out = '';
		    for (var j = 0; j < string.length; j += limit) {
		        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
		        var arr = [];

		        for (var i = 0; i < segment.length; ++i) {
		            var c = segment.charCodeAt(i);
		            if (
		                c === 0x2D // -
		                || c === 0x2E // .
		                || c === 0x5F // _
		                || c === 0x7E // ~
		                || (c >= 0x30 && c <= 0x39) // 0-9
		                || (c >= 0x41 && c <= 0x5A) // a-z
		                || (c >= 0x61 && c <= 0x7A) // A-Z
		                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
		            ) {
		                arr[arr.length] = segment.charAt(i);
		                continue;
		            }

		            if (c < 0x80) {
		                arr[arr.length] = hexTable[c];
		                continue;
		            }

		            if (c < 0x800) {
		                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
		                    + hexTable[0x80 | (c & 0x3F)];
		                continue;
		            }

		            if (c < 0xD800 || c >= 0xE000) {
		                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
		                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
		                    + hexTable[0x80 | (c & 0x3F)];
		                continue;
		            }

		            i += 1;
		            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

		            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
		                + hexTable[0x80 | ((c >> 12) & 0x3F)]
		                + hexTable[0x80 | ((c >> 6) & 0x3F)]
		                + hexTable[0x80 | (c & 0x3F)];
		        }

		        out += arr.join('');
		    }

		    return out;
		};

		var compact = function compact(value) {
		    var queue = [{ obj: { o: value }, prop: 'o' }];
		    var refs = [];

		    for (var i = 0; i < queue.length; ++i) {
		        var item = queue[i];
		        var obj = item.obj[item.prop];

		        var keys = Object.keys(obj);
		        for (var j = 0; j < keys.length; ++j) {
		            var key = keys[j];
		            var val = obj[key];
		            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
		                queue.push({ obj: obj, prop: key });
		                refs.push(val);
		            }
		        }
		    }

		    compactQueue(queue);

		    return value;
		};

		var isRegExp = function isRegExp(obj) {
		    return Object.prototype.toString.call(obj) === '[object RegExp]';
		};

		var isBuffer = function isBuffer(obj) {
		    if (!obj || typeof obj !== 'object') {
		        return false;
		    }

		    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
		};

		var combine = function combine(a, b) {
		    return [].concat(a, b);
		};

		var maybeMap = function maybeMap(val, fn) {
		    if (isArray(val)) {
		        var mapped = [];
		        for (var i = 0; i < val.length; i += 1) {
		            mapped.push(fn(val[i]));
		        }
		        return mapped;
		    }
		    return fn(val);
		};

		utils$3 = {
		    arrayToObject: arrayToObject,
		    assign: assign,
		    combine: combine,
		    compact: compact,
		    decode: decode,
		    encode: encode,
		    isBuffer: isBuffer,
		    isRegExp: isRegExp,
		    maybeMap: maybeMap,
		    merge: merge
		};
		return utils$3;
	}

	var stringify_1;
	var hasRequiredStringify;

	function requireStringify () {
		if (hasRequiredStringify) return stringify_1;
		hasRequiredStringify = 1;

		var getSideChannel = requireSideChannel();
		var utils = /*@__PURE__*/ requireUtils$1();
		var formats = /*@__PURE__*/ requireFormats();
		var has = Object.prototype.hasOwnProperty;

		var arrayPrefixGenerators = {
		    brackets: function brackets(prefix) {
		        return prefix + '[]';
		    },
		    comma: 'comma',
		    indices: function indices(prefix, key) {
		        return prefix + '[' + key + ']';
		    },
		    repeat: function repeat(prefix) {
		        return prefix;
		    }
		};

		var isArray = Array.isArray;
		var push = Array.prototype.push;
		var pushToArray = function (arr, valueOrArray) {
		    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
		};

		var toISO = Date.prototype.toISOString;

		var defaultFormat = formats['default'];
		var defaults = {
		    addQueryPrefix: false,
		    allowDots: false,
		    allowEmptyArrays: false,
		    arrayFormat: 'indices',
		    charset: 'utf-8',
		    charsetSentinel: false,
		    commaRoundTrip: false,
		    delimiter: '&',
		    encode: true,
		    encodeDotInKeys: false,
		    encoder: utils.encode,
		    encodeValuesOnly: false,
		    filter: void 0,
		    format: defaultFormat,
		    formatter: formats.formatters[defaultFormat],
		    // deprecated
		    indices: false,
		    serializeDate: function serializeDate(date) {
		        return toISO.call(date);
		    },
		    skipNulls: false,
		    strictNullHandling: false
		};

		var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
		    return typeof v === 'string'
		        || typeof v === 'number'
		        || typeof v === 'boolean'
		        || typeof v === 'symbol'
		        || typeof v === 'bigint';
		};

		var sentinel = {};

		var stringify = function stringify(
		    object,
		    prefix,
		    generateArrayPrefix,
		    commaRoundTrip,
		    allowEmptyArrays,
		    strictNullHandling,
		    skipNulls,
		    encodeDotInKeys,
		    encoder,
		    filter,
		    sort,
		    allowDots,
		    serializeDate,
		    format,
		    formatter,
		    encodeValuesOnly,
		    charset,
		    sideChannel
		) {
		    var obj = object;

		    var tmpSc = sideChannel;
		    var step = 0;
		    var findFlag = false;
		    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
		        // Where object last appeared in the ref tree
		        var pos = tmpSc.get(object);
		        step += 1;
		        if (typeof pos !== 'undefined') {
		            if (pos === step) {
		                throw new RangeError('Cyclic object value');
		            } else {
		                findFlag = true; // Break while
		            }
		        }
		        if (typeof tmpSc.get(sentinel) === 'undefined') {
		            step = 0;
		        }
		    }

		    if (typeof filter === 'function') {
		        obj = filter(prefix, obj);
		    } else if (obj instanceof Date) {
		        obj = serializeDate(obj);
		    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
		        obj = utils.maybeMap(obj, function (value) {
		            if (value instanceof Date) {
		                return serializeDate(value);
		            }
		            return value;
		        });
		    }

		    if (obj === null) {
		        if (strictNullHandling) {
		            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
		        }

		        obj = '';
		    }

		    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
		        if (encoder) {
		            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
		            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
		        }
		        return [formatter(prefix) + '=' + formatter(String(obj))];
		    }

		    var values = [];

		    if (typeof obj === 'undefined') {
		        return values;
		    }

		    var objKeys;
		    if (generateArrayPrefix === 'comma' && isArray(obj)) {
		        // we need to join elements in
		        if (encodeValuesOnly && encoder) {
		            obj = utils.maybeMap(obj, encoder);
		        }
		        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void 0 }];
		    } else if (isArray(filter)) {
		        objKeys = filter;
		    } else {
		        var keys = Object.keys(obj);
		        objKeys = sort ? keys.sort(sort) : keys;
		    }

		    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);

		    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

		    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
		        return adjustedPrefix + '[]';
		    }

		    for (var j = 0; j < objKeys.length; ++j) {
		        var key = objKeys[j];
		        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'
		            ? key.value
		            : obj[key];

		        if (skipNulls && value === null) {
		            continue;
		        }

		        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
		        var keyPrefix = isArray(obj)
		            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
		            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

		        sideChannel.set(object, step);
		        var valueSideChannel = getSideChannel();
		        valueSideChannel.set(sentinel, sideChannel);
		        pushToArray(values, stringify(
		            value,
		            keyPrefix,
		            generateArrayPrefix,
		            commaRoundTrip,
		            allowEmptyArrays,
		            strictNullHandling,
		            skipNulls,
		            encodeDotInKeys,
		            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
		            filter,
		            sort,
		            allowDots,
		            serializeDate,
		            format,
		            formatter,
		            encodeValuesOnly,
		            charset,
		            valueSideChannel
		        ));
		    }

		    return values;
		};

		var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
		    if (!opts) {
		        return defaults;
		    }

		    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
		        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
		    }

		    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
		        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
		    }

		    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
		        throw new TypeError('Encoder has to be a function.');
		    }

		    var charset = opts.charset || defaults.charset;
		    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
		        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
		    }

		    var format = formats['default'];
		    if (typeof opts.format !== 'undefined') {
		        if (!has.call(formats.formatters, opts.format)) {
		            throw new TypeError('Unknown format option provided.');
		        }
		        format = opts.format;
		    }
		    var formatter = formats.formatters[format];

		    var filter = defaults.filter;
		    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
		        filter = opts.filter;
		    }

		    var arrayFormat;
		    if (opts.arrayFormat in arrayPrefixGenerators) {
		        arrayFormat = opts.arrayFormat;
		    } else if ('indices' in opts) {
		        arrayFormat = opts.indices ? 'indices' : 'repeat';
		    } else {
		        arrayFormat = defaults.arrayFormat;
		    }

		    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
		        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
		    }

		    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

		    return {
		        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
		        allowDots: allowDots,
		        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
		        arrayFormat: arrayFormat,
		        charset: charset,
		        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
		        commaRoundTrip: !!opts.commaRoundTrip,
		        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
		        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
		        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
		        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
		        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
		        filter: filter,
		        format: format,
		        formatter: formatter,
		        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
		        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
		        sort: typeof opts.sort === 'function' ? opts.sort : null,
		        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
		    };
		};

		stringify_1 = function (object, opts) {
		    var obj = object;
		    var options = normalizeStringifyOptions(opts);

		    var objKeys;
		    var filter;

		    if (typeof options.filter === 'function') {
		        filter = options.filter;
		        obj = filter('', obj);
		    } else if (isArray(options.filter)) {
		        filter = options.filter;
		        objKeys = filter;
		    }

		    var keys = [];

		    if (typeof obj !== 'object' || obj === null) {
		        return '';
		    }

		    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
		    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

		    if (!objKeys) {
		        objKeys = Object.keys(obj);
		    }

		    if (options.sort) {
		        objKeys.sort(options.sort);
		    }

		    var sideChannel = getSideChannel();
		    for (var i = 0; i < objKeys.length; ++i) {
		        var key = objKeys[i];
		        var value = obj[key];

		        if (options.skipNulls && value === null) {
		            continue;
		        }
		        pushToArray(keys, stringify(
		            value,
		            key,
		            generateArrayPrefix,
		            commaRoundTrip,
		            options.allowEmptyArrays,
		            options.strictNullHandling,
		            options.skipNulls,
		            options.encodeDotInKeys,
		            options.encode ? options.encoder : null,
		            options.filter,
		            options.sort,
		            options.allowDots,
		            options.serializeDate,
		            options.format,
		            options.formatter,
		            options.encodeValuesOnly,
		            options.charset,
		            sideChannel
		        ));
		    }

		    var joined = keys.join(options.delimiter);
		    var prefix = options.addQueryPrefix === true ? '?' : '';

		    if (options.charsetSentinel) {
		        if (options.charset === 'iso-8859-1') {
		            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
		            prefix += 'utf8=%26%2310003%3B&';
		        } else {
		            // encodeURIComponent('✓')
		            prefix += 'utf8=%E2%9C%93&';
		        }
		    }

		    return joined.length > 0 ? prefix + joined : '';
		};
		return stringify_1;
	}

	var parse;
	var hasRequiredParse;

	function requireParse () {
		if (hasRequiredParse) return parse;
		hasRequiredParse = 1;

		var utils = /*@__PURE__*/ requireUtils$1();

		var has = Object.prototype.hasOwnProperty;
		var isArray = Array.isArray;

		var defaults = {
		    allowDots: false,
		    allowEmptyArrays: false,
		    allowPrototypes: false,
		    allowSparse: false,
		    arrayLimit: 20,
		    charset: 'utf-8',
		    charsetSentinel: false,
		    comma: false,
		    decodeDotInKeys: false,
		    decoder: utils.decode,
		    delimiter: '&',
		    depth: 5,
		    duplicates: 'combine',
		    ignoreQueryPrefix: false,
		    interpretNumericEntities: false,
		    parameterLimit: 1000,
		    parseArrays: true,
		    plainObjects: false,
		    strictDepth: false,
		    strictNullHandling: false,
		    throwOnLimitExceeded: false
		};

		var interpretNumericEntities = function (str) {
		    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
		        return String.fromCharCode(parseInt(numberStr, 10));
		    });
		};

		var parseArrayValue = function (val, options, currentArrayLength) {
		    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
		        return val.split(',');
		    }

		    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
		        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
		    }

		    return val;
		};

		// This is what browsers will submit when the ✓ character occurs in an
		// application/x-www-form-urlencoded body and the encoding of the page containing
		// the form is iso-8859-1, or when the submitted form has an accept-charset
		// attribute of iso-8859-1. Presumably also with other charsets that do not contain
		// the ✓ character, such as us-ascii.
		var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

		// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
		var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

		var parseValues = function parseQueryStringValues(str, options) {
		    var obj = { __proto__: null };

		    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
		    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');

		    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
		    var parts = cleanStr.split(
		        options.delimiter,
		        options.throwOnLimitExceeded ? limit + 1 : limit
		    );

		    if (options.throwOnLimitExceeded && parts.length > limit) {
		        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
		    }

		    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
		    var i;

		    var charset = options.charset;
		    if (options.charsetSentinel) {
		        for (i = 0; i < parts.length; ++i) {
		            if (parts[i].indexOf('utf8=') === 0) {
		                if (parts[i] === charsetSentinel) {
		                    charset = 'utf-8';
		                } else if (parts[i] === isoSentinel) {
		                    charset = 'iso-8859-1';
		                }
		                skipIndex = i;
		                i = parts.length; // The eslint settings do not allow break;
		            }
		        }
		    }

		    for (i = 0; i < parts.length; ++i) {
		        if (i === skipIndex) {
		            continue;
		        }
		        var part = parts[i];

		        var bracketEqualsPos = part.indexOf(']=');
		        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

		        var key;
		        var val;
		        if (pos === -1) {
		            key = options.decoder(part, defaults.decoder, charset, 'key');
		            val = options.strictNullHandling ? null : '';
		        } else {
		            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');

		            val = utils.maybeMap(
		                parseArrayValue(
		                    part.slice(pos + 1),
		                    options,
		                    isArray(obj[key]) ? obj[key].length : 0
		                ),
		                function (encodedVal) {
		                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
		                }
		            );
		        }

		        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
		            val = interpretNumericEntities(String(val));
		        }

		        if (part.indexOf('[]=') > -1) {
		            val = isArray(val) ? [val] : val;
		        }

		        var existing = has.call(obj, key);
		        if (existing && options.duplicates === 'combine') {
		            obj[key] = utils.combine(obj[key], val);
		        } else if (!existing || options.duplicates === 'last') {
		            obj[key] = val;
		        }
		    }

		    return obj;
		};

		var parseObject = function (chain, val, options, valuesParsed) {
		    var currentArrayLength = 0;
		    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
		        var parentKey = chain.slice(0, -1).join('');
		        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
		    }

		    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);

		    for (var i = chain.length - 1; i >= 0; --i) {
		        var obj;
		        var root = chain[i];

		        if (root === '[]' && options.parseArrays) {
		            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
		                ? []
		                : utils.combine([], leaf);
		        } else {
		            obj = options.plainObjects ? { __proto__: null } : {};
		            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
		            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
		            var index = parseInt(decodedRoot, 10);
		            if (!options.parseArrays && decodedRoot === '') {
		                obj = { 0: leaf };
		            } else if (
		                !isNaN(index)
		                && root !== decodedRoot
		                && String(index) === decodedRoot
		                && index >= 0
		                && (options.parseArrays && index <= options.arrayLimit)
		            ) {
		                obj = [];
		                obj[index] = leaf;
		            } else if (decodedRoot !== '__proto__') {
		                obj[decodedRoot] = leaf;
		            }
		        }

		        leaf = obj;
		    }

		    return leaf;
		};

		var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		    if (!givenKey) {
		        return;
		    }

		    // Transform dot notation to bracket notation
		    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

		    // The regex chunks

		    var brackets = /(\[[^[\]]*])/;
		    var child = /(\[[^[\]]*])/g;

		    // Get the parent

		    var segment = options.depth > 0 && brackets.exec(key);
		    var parent = segment ? key.slice(0, segment.index) : key;

		    // Stash the parent if it exists

		    var keys = [];
		    if (parent) {
		        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
		        if (!options.plainObjects && has.call(Object.prototype, parent)) {
		            if (!options.allowPrototypes) {
		                return;
		            }
		        }

		        keys.push(parent);
		    }

		    // Loop through children appending to the array until we hit depth

		    var i = 0;
		    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
		        i += 1;
		        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
		            if (!options.allowPrototypes) {
		                return;
		            }
		        }
		        keys.push(segment[1]);
		    }

		    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

		    if (segment) {
		        if (options.strictDepth === true) {
		            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
		        }
		        keys.push('[' + key.slice(segment.index) + ']');
		    }

		    return parseObject(keys, val, options, valuesParsed);
		};

		var normalizeParseOptions = function normalizeParseOptions(opts) {
		    if (!opts) {
		        return defaults;
		    }

		    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
		        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
		    }

		    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
		        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
		    }

		    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
		        throw new TypeError('Decoder has to be a function.');
		    }

		    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
		        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
		    }

		    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
		        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
		    }

		    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

		    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

		    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
		        throw new TypeError('The duplicates option must be either combine, first, or last');
		    }

		    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

		    return {
		        allowDots: allowDots,
		        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
		        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
		        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
		        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
		        charset: charset,
		        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
		        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
		        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
		        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
		        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
		        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
		        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
		        duplicates: duplicates,
		        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
		        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
		        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
		        parseArrays: opts.parseArrays !== false,
		        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
		        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
		        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
		        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
		    };
		};

		parse = function (str, opts) {
		    var options = normalizeParseOptions(opts);

		    if (str === '' || str === null || typeof str === 'undefined') {
		        return options.plainObjects ? { __proto__: null } : {};
		    }

		    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
		    var obj = options.plainObjects ? { __proto__: null } : {};

		    // Iterate over the keys and setup the new object

		    var keys = Object.keys(tempObj);
		    for (var i = 0; i < keys.length; ++i) {
		        var key = keys[i];
		        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
		        obj = utils.merge(obj, newObj, options);
		    }

		    if (options.allowSparse === true) {
		        return obj;
		    }

		    return utils.compact(obj);
		};
		return parse;
	}

	var lib$1;
	var hasRequiredLib$1;

	function requireLib$1 () {
		if (hasRequiredLib$1) return lib$1;
		hasRequiredLib$1 = 1;

		var stringify = /*@__PURE__*/ requireStringify();
		var parse = /*@__PURE__*/ requireParse();
		var formats = /*@__PURE__*/ requireFormats();

		lib$1 = {
		    formats: formats,
		    parse: parse,
		    stringify: stringify
		};
		return lib$1;
	}

	var libExports = /*@__PURE__*/ requireLib$1();
	var qs = /*@__PURE__*/getDefaultExportFromCjs(libExports);

	var util;
	(function (util) {
	    util.assertEqual = (val) => val;
	    function assertIs(_arg) { }
	    util.assertIs = assertIs;
	    function assertNever(_x) {
	        throw new Error();
	    }
	    util.assertNever = assertNever;
	    util.arrayToEnum = (items) => {
	        const obj = {};
	        for (const item of items) {
	            obj[item] = item;
	        }
	        return obj;
	    };
	    util.getValidEnumValues = (obj) => {
	        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
	        const filtered = {};
	        for (const k of validKeys) {
	            filtered[k] = obj[k];
	        }
	        return util.objectValues(filtered);
	    };
	    util.objectValues = (obj) => {
	        return util.objectKeys(obj).map(function (e) {
	            return obj[e];
	        });
	    };
	    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
	        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
	        : (object) => {
	            const keys = [];
	            for (const key in object) {
	                if (Object.prototype.hasOwnProperty.call(object, key)) {
	                    keys.push(key);
	                }
	            }
	            return keys;
	        };
	    util.find = (arr, checker) => {
	        for (const item of arr) {
	            if (checker(item))
	                return item;
	        }
	        return undefined;
	    };
	    util.isInteger = typeof Number.isInteger === "function"
	        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
	        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
	    function joinValues(array, separator = " | ") {
	        return array
	            .map((val) => (typeof val === "string" ? `'${val}'` : val))
	            .join(separator);
	    }
	    util.joinValues = joinValues;
	    util.jsonStringifyReplacer = (_, value) => {
	        if (typeof value === "bigint") {
	            return value.toString();
	        }
	        return value;
	    };
	})(util || (util = {}));
	var objectUtil;
	(function (objectUtil) {
	    objectUtil.mergeShapes = (first, second) => {
	        return {
	            ...first,
	            ...second, // second overwrites first
	        };
	    };
	})(objectUtil || (objectUtil = {}));
	const ZodParsedType = util.arrayToEnum([
	    "string",
	    "nan",
	    "number",
	    "integer",
	    "float",
	    "boolean",
	    "date",
	    "bigint",
	    "symbol",
	    "function",
	    "undefined",
	    "null",
	    "array",
	    "object",
	    "unknown",
	    "promise",
	    "void",
	    "never",
	    "map",
	    "set",
	]);
	const getParsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "undefined":
	            return ZodParsedType.undefined;
	        case "string":
	            return ZodParsedType.string;
	        case "number":
	            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
	        case "boolean":
	            return ZodParsedType.boolean;
	        case "function":
	            return ZodParsedType.function;
	        case "bigint":
	            return ZodParsedType.bigint;
	        case "symbol":
	            return ZodParsedType.symbol;
	        case "object":
	            if (Array.isArray(data)) {
	                return ZodParsedType.array;
	            }
	            if (data === null) {
	                return ZodParsedType.null;
	            }
	            if (data.then &&
	                typeof data.then === "function" &&
	                data.catch &&
	                typeof data.catch === "function") {
	                return ZodParsedType.promise;
	            }
	            if (typeof Map !== "undefined" && data instanceof Map) {
	                return ZodParsedType.map;
	            }
	            if (typeof Set !== "undefined" && data instanceof Set) {
	                return ZodParsedType.set;
	            }
	            if (typeof Date !== "undefined" && data instanceof Date) {
	                return ZodParsedType.date;
	            }
	            return ZodParsedType.object;
	        default:
	            return ZodParsedType.unknown;
	    }
	};

	const ZodIssueCode = util.arrayToEnum([
	    "invalid_type",
	    "invalid_literal",
	    "custom",
	    "invalid_union",
	    "invalid_union_discriminator",
	    "invalid_enum_value",
	    "unrecognized_keys",
	    "invalid_arguments",
	    "invalid_return_type",
	    "invalid_date",
	    "invalid_string",
	    "too_small",
	    "too_big",
	    "invalid_intersection_types",
	    "not_multiple_of",
	    "not_finite",
	]);
	const quotelessJson = (obj) => {
	    const json = JSON.stringify(obj, null, 2);
	    return json.replace(/"([^"]+)":/g, "$1:");
	};
	class ZodError extends Error {
	    get errors() {
	        return this.issues;
	    }
	    constructor(issues) {
	        super();
	        this.issues = [];
	        this.addIssue = (sub) => {
	            this.issues = [...this.issues, sub];
	        };
	        this.addIssues = (subs = []) => {
	            this.issues = [...this.issues, ...subs];
	        };
	        const actualProto = new.target.prototype;
	        if (Object.setPrototypeOf) {
	            // eslint-disable-next-line ban/ban
	            Object.setPrototypeOf(this, actualProto);
	        }
	        else {
	            this.__proto__ = actualProto;
	        }
	        this.name = "ZodError";
	        this.issues = issues;
	    }
	    format(_mapper) {
	        const mapper = _mapper ||
	            function (issue) {
	                return issue.message;
	            };
	        const fieldErrors = { _errors: [] };
	        const processError = (error) => {
	            for (const issue of error.issues) {
	                if (issue.code === "invalid_union") {
	                    issue.unionErrors.map(processError);
	                }
	                else if (issue.code === "invalid_return_type") {
	                    processError(issue.returnTypeError);
	                }
	                else if (issue.code === "invalid_arguments") {
	                    processError(issue.argumentsError);
	                }
	                else if (issue.path.length === 0) {
	                    fieldErrors._errors.push(mapper(issue));
	                }
	                else {
	                    let curr = fieldErrors;
	                    let i = 0;
	                    while (i < issue.path.length) {
	                        const el = issue.path[i];
	                        const terminal = i === issue.path.length - 1;
	                        if (!terminal) {
	                            curr[el] = curr[el] || { _errors: [] };
	                            // if (typeof el === "string") {
	                            //   curr[el] = curr[el] || { _errors: [] };
	                            // } else if (typeof el === "number") {
	                            //   const errorArray: any = [];
	                            //   errorArray._errors = [];
	                            //   curr[el] = curr[el] || errorArray;
	                            // }
	                        }
	                        else {
	                            curr[el] = curr[el] || { _errors: [] };
	                            curr[el]._errors.push(mapper(issue));
	                        }
	                        curr = curr[el];
	                        i++;
	                    }
	                }
	            }
	        };
	        processError(this);
	        return fieldErrors;
	    }
	    static assert(value) {
	        if (!(value instanceof ZodError)) {
	            throw new Error(`Not a ZodError: ${value}`);
	        }
	    }
	    toString() {
	        return this.message;
	    }
	    get message() {
	        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	    }
	    get isEmpty() {
	        return this.issues.length === 0;
	    }
	    flatten(mapper = (issue) => issue.message) {
	        const fieldErrors = {};
	        const formErrors = [];
	        for (const sub of this.issues) {
	            if (sub.path.length > 0) {
	                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
	                fieldErrors[sub.path[0]].push(mapper(sub));
	            }
	            else {
	                formErrors.push(mapper(sub));
	            }
	        }
	        return { formErrors, fieldErrors };
	    }
	    get formErrors() {
	        return this.flatten();
	    }
	}
	ZodError.create = (issues) => {
	    const error = new ZodError(issues);
	    return error;
	};

	const errorMap = (issue, _ctx) => {
	    let message;
	    switch (issue.code) {
	        case ZodIssueCode.invalid_type:
	            if (issue.received === ZodParsedType.undefined) {
	                message = "Required";
	            }
	            else {
	                message = `Expected ${issue.expected}, received ${issue.received}`;
	            }
	            break;
	        case ZodIssueCode.invalid_literal:
	            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
	            break;
	        case ZodIssueCode.unrecognized_keys:
	            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
	            break;
	        case ZodIssueCode.invalid_union:
	            message = `Invalid input`;
	            break;
	        case ZodIssueCode.invalid_union_discriminator:
	            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
	            break;
	        case ZodIssueCode.invalid_enum_value:
	            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
	            break;
	        case ZodIssueCode.invalid_arguments:
	            message = `Invalid function arguments`;
	            break;
	        case ZodIssueCode.invalid_return_type:
	            message = `Invalid function return type`;
	            break;
	        case ZodIssueCode.invalid_date:
	            message = `Invalid date`;
	            break;
	        case ZodIssueCode.invalid_string:
	            if (typeof issue.validation === "object") {
	                if ("includes" in issue.validation) {
	                    message = `Invalid input: must include "${issue.validation.includes}"`;
	                    if (typeof issue.validation.position === "number") {
	                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
	                    }
	                }
	                else if ("startsWith" in issue.validation) {
	                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
	                }
	                else if ("endsWith" in issue.validation) {
	                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
	                }
	                else {
	                    util.assertNever(issue.validation);
	                }
	            }
	            else if (issue.validation !== "regex") {
	                message = `Invalid ${issue.validation}`;
	            }
	            else {
	                message = "Invalid";
	            }
	            break;
	        case ZodIssueCode.too_small:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodIssueCode.too_big:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
	            else if (issue.type === "bigint")
	                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodIssueCode.custom:
	            message = `Invalid input`;
	            break;
	        case ZodIssueCode.invalid_intersection_types:
	            message = `Intersection results could not be merged`;
	            break;
	        case ZodIssueCode.not_multiple_of:
	            message = `Number must be a multiple of ${issue.multipleOf}`;
	            break;
	        case ZodIssueCode.not_finite:
	            message = "Number must be finite";
	            break;
	        default:
	            message = _ctx.defaultError;
	            util.assertNever(issue);
	    }
	    return { message };
	};

	let overrideErrorMap = errorMap;
	function setErrorMap(map) {
	    overrideErrorMap = map;
	}
	function getErrorMap() {
	    return overrideErrorMap;
	}

	const makeIssue = (params) => {
	    const { data, path, errorMaps, issueData } = params;
	    const fullPath = [...path, ...(issueData.path || [])];
	    const fullIssue = {
	        ...issueData,
	        path: fullPath,
	    };
	    if (issueData.message !== undefined) {
	        return {
	            ...issueData,
	            path: fullPath,
	            message: issueData.message,
	        };
	    }
	    let errorMessage = "";
	    const maps = errorMaps
	        .filter((m) => !!m)
	        .slice()
	        .reverse();
	    for (const map of maps) {
	        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
	    }
	    return {
	        ...issueData,
	        path: fullPath,
	        message: errorMessage,
	    };
	};
	const EMPTY_PATH = [];
	function addIssueToContext(ctx, issueData) {
	    const overrideMap = getErrorMap();
	    const issue = makeIssue({
	        issueData: issueData,
	        data: ctx.data,
	        path: ctx.path,
	        errorMaps: [
	            ctx.common.contextualErrorMap, // contextual error map is first priority
	            ctx.schemaErrorMap, // then schema-bound map if available
	            overrideMap, // then global override map
	            overrideMap === errorMap ? undefined : errorMap, // then global default map
	        ].filter((x) => !!x),
	    });
	    ctx.common.issues.push(issue);
	}
	class ParseStatus {
	    constructor() {
	        this.value = "valid";
	    }
	    dirty() {
	        if (this.value === "valid")
	            this.value = "dirty";
	    }
	    abort() {
	        if (this.value !== "aborted")
	            this.value = "aborted";
	    }
	    static mergeArray(status, results) {
	        const arrayValue = [];
	        for (const s of results) {
	            if (s.status === "aborted")
	                return INVALID;
	            if (s.status === "dirty")
	                status.dirty();
	            arrayValue.push(s.value);
	        }
	        return { status: status.value, value: arrayValue };
	    }
	    static async mergeObjectAsync(status, pairs) {
	        const syncPairs = [];
	        for (const pair of pairs) {
	            const key = await pair.key;
	            const value = await pair.value;
	            syncPairs.push({
	                key,
	                value,
	            });
	        }
	        return ParseStatus.mergeObjectSync(status, syncPairs);
	    }
	    static mergeObjectSync(status, pairs) {
	        const finalObject = {};
	        for (const pair of pairs) {
	            const { key, value } = pair;
	            if (key.status === "aborted")
	                return INVALID;
	            if (value.status === "aborted")
	                return INVALID;
	            if (key.status === "dirty")
	                status.dirty();
	            if (value.status === "dirty")
	                status.dirty();
	            if (key.value !== "__proto__" &&
	                (typeof value.value !== "undefined" || pair.alwaysSet)) {
	                finalObject[key.value] = value.value;
	            }
	        }
	        return { status: status.value, value: finalObject };
	    }
	}
	const INVALID = Object.freeze({
	    status: "aborted",
	});
	const DIRTY = (value) => ({ status: "dirty", value });
	const OK = (value) => ({ status: "valid", value });
	const isAborted = (x) => x.status === "aborted";
	const isDirty = (x) => x.status === "dirty";
	const isValid = (x) => x.status === "valid";
	const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	function __classPrivateFieldGet(receiver, state, kind, f) {
	    if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	    return state.get(receiver);
	}

	function __classPrivateFieldSet(receiver, state, value, kind, f) {
	    if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	    return (state.set(receiver, value)), value;
	}

	typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	var errorUtil;
	(function (errorUtil) {
	    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
	})(errorUtil || (errorUtil = {}));

	var _ZodEnum_cache, _ZodNativeEnum_cache;
	class ParseInputLazyPath {
	    constructor(parent, value, path, key) {
	        this._cachedPath = [];
	        this.parent = parent;
	        this.data = value;
	        this._path = path;
	        this._key = key;
	    }
	    get path() {
	        if (!this._cachedPath.length) {
	            if (this._key instanceof Array) {
	                this._cachedPath.push(...this._path, ...this._key);
	            }
	            else {
	                this._cachedPath.push(...this._path, this._key);
	            }
	        }
	        return this._cachedPath;
	    }
	}
	const handleResult = (ctx, result) => {
	    if (isValid(result)) {
	        return { success: true, data: result.value };
	    }
	    else {
	        if (!ctx.common.issues.length) {
	            throw new Error("Validation failed but no issues detected.");
	        }
	        return {
	            success: false,
	            get error() {
	                if (this._error)
	                    return this._error;
	                const error = new ZodError(ctx.common.issues);
	                this._error = error;
	                return this._error;
	            },
	        };
	    }
	};
	function processCreateParams(params) {
	    if (!params)
	        return {};
	    const { errorMap, invalid_type_error, required_error, description } = params;
	    if (errorMap && (invalid_type_error || required_error)) {
	        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	    }
	    if (errorMap)
	        return { errorMap: errorMap, description };
	    const customMap = (iss, ctx) => {
	        var _a, _b;
	        const { message } = params;
	        if (iss.code === "invalid_enum_value") {
	            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
	        }
	        if (typeof ctx.data === "undefined") {
	            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
	        }
	        if (iss.code !== "invalid_type")
	            return { message: ctx.defaultError };
	        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
	    };
	    return { errorMap: customMap, description };
	}
	class ZodType {
	    get description() {
	        return this._def.description;
	    }
	    _getType(input) {
	        return getParsedType(input.data);
	    }
	    _getOrReturnCtx(input, ctx) {
	        return (ctx || {
	            common: input.parent.common,
	            data: input.data,
	            parsedType: getParsedType(input.data),
	            schemaErrorMap: this._def.errorMap,
	            path: input.path,
	            parent: input.parent,
	        });
	    }
	    _processInputParams(input) {
	        return {
	            status: new ParseStatus(),
	            ctx: {
	                common: input.parent.common,
	                data: input.data,
	                parsedType: getParsedType(input.data),
	                schemaErrorMap: this._def.errorMap,
	                path: input.path,
	                parent: input.parent,
	            },
	        };
	    }
	    _parseSync(input) {
	        const result = this._parse(input);
	        if (isAsync(result)) {
	            throw new Error("Synchronous parse encountered promise.");
	        }
	        return result;
	    }
	    _parseAsync(input) {
	        const result = this._parse(input);
	        return Promise.resolve(result);
	    }
	    parse(data, params) {
	        const result = this.safeParse(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    safeParse(data, params) {
	        var _a;
	        const ctx = {
	            common: {
	                issues: [],
	                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: getParsedType(data),
	        };
	        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
	        return handleResult(ctx, result);
	    }
	    "~validate"(data) {
	        var _a, _b;
	        const ctx = {
	            common: {
	                issues: [],
	                async: !!this["~standard"].async,
	            },
	            path: [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: getParsedType(data),
	        };
	        if (!this["~standard"].async) {
	            try {
	                const result = this._parseSync({ data, path: [], parent: ctx });
	                return isValid(result)
	                    ? {
	                        value: result.value,
	                    }
	                    : {
	                        issues: ctx.common.issues,
	                    };
	            }
	            catch (err) {
	                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
	                    this["~standard"].async = true;
	                }
	                ctx.common = {
	                    issues: [],
	                    async: true,
	                };
	            }
	        }
	        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)
	            ? {
	                value: result.value,
	            }
	            : {
	                issues: ctx.common.issues,
	            });
	    }
	    async parseAsync(data, params) {
	        const result = await this.safeParseAsync(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    async safeParseAsync(data, params) {
	        const ctx = {
	            common: {
	                issues: [],
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	                async: true,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: getParsedType(data),
	        };
	        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
	        const result = await (isAsync(maybeAsyncResult)
	            ? maybeAsyncResult
	            : Promise.resolve(maybeAsyncResult));
	        return handleResult(ctx, result);
	    }
	    refine(check, message) {
	        const getIssueProperties = (val) => {
	            if (typeof message === "string" || typeof message === "undefined") {
	                return { message };
	            }
	            else if (typeof message === "function") {
	                return message(val);
	            }
	            else {
	                return message;
	            }
	        };
	        return this._refinement((val, ctx) => {
	            const result = check(val);
	            const setError = () => ctx.addIssue({
	                code: ZodIssueCode.custom,
	                ...getIssueProperties(val),
	            });
	            if (typeof Promise !== "undefined" && result instanceof Promise) {
	                return result.then((data) => {
	                    if (!data) {
	                        setError();
	                        return false;
	                    }
	                    else {
	                        return true;
	                    }
	                });
	            }
	            if (!result) {
	                setError();
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    refinement(check, refinementData) {
	        return this._refinement((val, ctx) => {
	            if (!check(val)) {
	                ctx.addIssue(typeof refinementData === "function"
	                    ? refinementData(val, ctx)
	                    : refinementData);
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    _refinement(refinement) {
	        return new ZodEffects({
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "refinement", refinement },
	        });
	    }
	    superRefine(refinement) {
	        return this._refinement(refinement);
	    }
	    constructor(def) {
	        /** Alias of safeParseAsync */
	        this.spa = this.safeParseAsync;
	        this._def = def;
	        this.parse = this.parse.bind(this);
	        this.safeParse = this.safeParse.bind(this);
	        this.parseAsync = this.parseAsync.bind(this);
	        this.safeParseAsync = this.safeParseAsync.bind(this);
	        this.spa = this.spa.bind(this);
	        this.refine = this.refine.bind(this);
	        this.refinement = this.refinement.bind(this);
	        this.superRefine = this.superRefine.bind(this);
	        this.optional = this.optional.bind(this);
	        this.nullable = this.nullable.bind(this);
	        this.nullish = this.nullish.bind(this);
	        this.array = this.array.bind(this);
	        this.promise = this.promise.bind(this);
	        this.or = this.or.bind(this);
	        this.and = this.and.bind(this);
	        this.transform = this.transform.bind(this);
	        this.brand = this.brand.bind(this);
	        this.default = this.default.bind(this);
	        this.catch = this.catch.bind(this);
	        this.describe = this.describe.bind(this);
	        this.pipe = this.pipe.bind(this);
	        this.readonly = this.readonly.bind(this);
	        this.isNullable = this.isNullable.bind(this);
	        this.isOptional = this.isOptional.bind(this);
	        this["~standard"] = {
	            version: 1,
	            vendor: "zod",
	            validate: (data) => this["~validate"](data),
	        };
	    }
	    optional() {
	        return ZodOptional.create(this, this._def);
	    }
	    nullable() {
	        return ZodNullable.create(this, this._def);
	    }
	    nullish() {
	        return this.nullable().optional();
	    }
	    array() {
	        return ZodArray.create(this);
	    }
	    promise() {
	        return ZodPromise.create(this, this._def);
	    }
	    or(option) {
	        return ZodUnion.create([this, option], this._def);
	    }
	    and(incoming) {
	        return ZodIntersection.create(this, incoming, this._def);
	    }
	    transform(transform) {
	        return new ZodEffects({
	            ...processCreateParams(this._def),
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "transform", transform },
	        });
	    }
	    default(def) {
	        const defaultValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodDefault({
	            ...processCreateParams(this._def),
	            innerType: this,
	            defaultValue: defaultValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodDefault,
	        });
	    }
	    brand() {
	        return new ZodBranded({
	            typeName: ZodFirstPartyTypeKind.ZodBranded,
	            type: this,
	            ...processCreateParams(this._def),
	        });
	    }
	    catch(def) {
	        const catchValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodCatch({
	            ...processCreateParams(this._def),
	            innerType: this,
	            catchValue: catchValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodCatch,
	        });
	    }
	    describe(description) {
	        const This = this.constructor;
	        return new This({
	            ...this._def,
	            description,
	        });
	    }
	    pipe(target) {
	        return ZodPipeline.create(this, target);
	    }
	    readonly() {
	        return ZodReadonly.create(this);
	    }
	    isOptional() {
	        return this.safeParse(undefined).success;
	    }
	    isNullable() {
	        return this.safeParse(null).success;
	    }
	}
	const cuidRegex = /^c[^\s-]{8,}$/i;
	const cuid2Regex = /^[0-9a-z]+$/;
	const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
	// const uuidRegex =
	//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
	const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
	const nanoidRegex = /^[a-z0-9_-]{21}$/i;
	const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
	const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
	// from https://stackoverflow.com/a/46181/1550155
	// old version: too slow, didn't support unicode
	// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
	//old email regex
	// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
	// eslint-disable-next-line
	// const emailRegex =
	//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
	// const emailRegex =
	//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	// const emailRegex =
	//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
	const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
	// const emailRegex =
	//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
	// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
	const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
	let emojiRegex;
	// faster, simpler, safer
	const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
	const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
	// const ipv6Regex =
	// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
	const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
	const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
	// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
	const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
	// https://base64.guru/standards/base64url
	const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
	// simple
	// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
	// no leap year validation
	// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
	// with leap year validation
	const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
	const dateRegex = new RegExp(`^${dateRegexSource}$`);
	function timeRegexSource(args) {
	    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
	    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
	    if (args.precision) {
	        regex = `${regex}\\.\\d{${args.precision}}`;
	    }
	    else if (args.precision == null) {
	        regex = `${regex}(\\.\\d+)?`;
	    }
	    return regex;
	}
	function timeRegex(args) {
	    return new RegExp(`^${timeRegexSource(args)}$`);
	}
	// Adapted from https://stackoverflow.com/a/3143231
	function datetimeRegex(args) {
	    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
	    const opts = [];
	    opts.push(args.local ? `Z?` : `Z`);
	    if (args.offset)
	        opts.push(`([+-]\\d{2}:?\\d{2})`);
	    regex = `${regex}(${opts.join("|")})`;
	    return new RegExp(`^${regex}$`);
	}
	function isValidIP(ip, version) {
	    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	function isValidJWT(jwt, alg) {
	    if (!jwtRegex.test(jwt))
	        return false;
	    try {
	        const [header] = jwt.split(".");
	        // Convert base64url to base64
	        const base64 = header
	            .replace(/-/g, "+")
	            .replace(/_/g, "/")
	            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
	        const decoded = JSON.parse(atob(base64));
	        if (typeof decoded !== "object" || decoded === null)
	            return false;
	        if (!decoded.typ || !decoded.alg)
	            return false;
	        if (alg && decoded.alg !== alg)
	            return false;
	        return true;
	    }
	    catch (_a) {
	        return false;
	    }
	}
	function isValidCidr(ip, version) {
	    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	class ZodString extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = String(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.string) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.string,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const status = new ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.length < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.length > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "length") {
	                const tooBig = input.data.length > check.value;
	                const tooSmall = input.data.length < check.value;
	                if (tooBig || tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    if (tooBig) {
	                        addIssueToContext(ctx, {
	                            code: ZodIssueCode.too_big,
	                            maximum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    else if (tooSmall) {
	                        addIssueToContext(ctx, {
	                            code: ZodIssueCode.too_small,
	                            minimum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "email") {
	                if (!emailRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "email",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "emoji") {
	                if (!emojiRegex) {
	                    emojiRegex = new RegExp(_emojiRegex, "u");
	                }
	                if (!emojiRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "emoji",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "uuid") {
	                if (!uuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "uuid",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "nanoid") {
	                if (!nanoidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "nanoid",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid") {
	                if (!cuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "cuid",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid2") {
	                if (!cuid2Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "cuid2",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ulid") {
	                if (!ulidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "ulid",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "url") {
	                try {
	                    new URL(input.data);
	                }
	                catch (_a) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "url",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "regex") {
	                check.regex.lastIndex = 0;
	                const testResult = check.regex.test(input.data);
	                if (!testResult) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "regex",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "trim") {
	                input.data = input.data.trim();
	            }
	            else if (check.kind === "includes") {
	                if (!input.data.includes(check.value, check.position)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: { includes: check.value, position: check.position },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "toLowerCase") {
	                input.data = input.data.toLowerCase();
	            }
	            else if (check.kind === "toUpperCase") {
	                input.data = input.data.toUpperCase();
	            }
	            else if (check.kind === "startsWith") {
	                if (!input.data.startsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: { startsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "endsWith") {
	                if (!input.data.endsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: { endsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "datetime") {
	                const regex = datetimeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: "datetime",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "date") {
	                const regex = dateRegex;
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: "date",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "time") {
	                const regex = timeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: "time",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "duration") {
	                if (!durationRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "duration",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ip") {
	                if (!isValidIP(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "ip",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "jwt") {
	                if (!isValidJWT(input.data, check.alg)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "jwt",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cidr") {
	                if (!isValidCidr(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "cidr",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "base64") {
	                if (!base64Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "base64",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "base64url") {
	                if (!base64urlRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "base64url",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _regex(regex, validation, message) {
	        return this.refinement((data) => regex.test(data), {
	            validation,
	            code: ZodIssueCode.invalid_string,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    _addCheck(check) {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    email(message) {
	        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
	    }
	    url(message) {
	        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
	    }
	    emoji(message) {
	        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
	    }
	    uuid(message) {
	        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
	    }
	    nanoid(message) {
	        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
	    }
	    cuid(message) {
	        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
	    }
	    cuid2(message) {
	        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
	    }
	    ulid(message) {
	        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
	    }
	    base64(message) {
	        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
	    }
	    base64url(message) {
	        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
	        return this._addCheck({
	            kind: "base64url",
	            ...errorUtil.errToObj(message),
	        });
	    }
	    jwt(options) {
	        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
	    }
	    ip(options) {
	        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
	    }
	    cidr(options) {
	        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
	    }
	    datetime(options) {
	        var _a, _b;
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "datetime",
	                precision: null,
	                offset: false,
	                local: false,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "datetime",
	            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
	            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
	            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
	            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    date(message) {
	        return this._addCheck({ kind: "date", message });
	    }
	    time(options) {
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "time",
	                precision: null,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "time",
	            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
	            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    duration(message) {
	        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
	    }
	    regex(regex, message) {
	        return this._addCheck({
	            kind: "regex",
	            regex: regex,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    includes(value, options) {
	        return this._addCheck({
	            kind: "includes",
	            value: value,
	            position: options === null || options === void 0 ? void 0 : options.position,
	            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    startsWith(value, message) {
	        return this._addCheck({
	            kind: "startsWith",
	            value: value,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    endsWith(value, message) {
	        return this._addCheck({
	            kind: "endsWith",
	            value: value,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    min(minLength, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minLength,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    max(maxLength, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxLength,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    length(len, message) {
	        return this._addCheck({
	            kind: "length",
	            value: len,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    /**
	     * Equivalent to `.min(1)`
	     */
	    nonempty(message) {
	        return this.min(1, errorUtil.errToObj(message));
	    }
	    trim() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "trim" }],
	        });
	    }
	    toLowerCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toLowerCase" }],
	        });
	    }
	    toUpperCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toUpperCase" }],
	        });
	    }
	    get isDatetime() {
	        return !!this._def.checks.find((ch) => ch.kind === "datetime");
	    }
	    get isDate() {
	        return !!this._def.checks.find((ch) => ch.kind === "date");
	    }
	    get isTime() {
	        return !!this._def.checks.find((ch) => ch.kind === "time");
	    }
	    get isDuration() {
	        return !!this._def.checks.find((ch) => ch.kind === "duration");
	    }
	    get isEmail() {
	        return !!this._def.checks.find((ch) => ch.kind === "email");
	    }
	    get isURL() {
	        return !!this._def.checks.find((ch) => ch.kind === "url");
	    }
	    get isEmoji() {
	        return !!this._def.checks.find((ch) => ch.kind === "emoji");
	    }
	    get isUUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "uuid");
	    }
	    get isNANOID() {
	        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	    }
	    get isCUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid");
	    }
	    get isCUID2() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	    }
	    get isULID() {
	        return !!this._def.checks.find((ch) => ch.kind === "ulid");
	    }
	    get isIP() {
	        return !!this._def.checks.find((ch) => ch.kind === "ip");
	    }
	    get isCIDR() {
	        return !!this._def.checks.find((ch) => ch.kind === "cidr");
	    }
	    get isBase64() {
	        return !!this._def.checks.find((ch) => ch.kind === "base64");
	    }
	    get isBase64url() {
	        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
	        return !!this._def.checks.find((ch) => ch.kind === "base64url");
	    }
	    get minLength() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxLength() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	ZodString.create = (params) => {
	    var _a;
	    return new ZodString({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodString,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
	function floatSafeRemainder(val, step) {
	    const valDecCount = (val.toString().split(".")[1] || "").length;
	    const stepDecCount = (step.toString().split(".")[1] || "").length;
	    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
	    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
	    return (valInt % stepInt) / Math.pow(10, decCount);
	}
	class ZodNumber extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	        this.step = this.multipleOf;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Number(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.number) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.number,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        let ctx = undefined;
	        const status = new ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "int") {
	                if (!util.isInteger(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_type,
	                        expected: "integer",
	                        received: "float",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (floatSafeRemainder(input.data, check.value) !== 0) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "finite") {
	                if (!Number.isFinite(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.not_finite,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    int(message) {
	        return this._addCheck({
	            kind: "int",
	            message: errorUtil.toString(message),
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value: value,
	            message: errorUtil.toString(message),
	        });
	    }
	    finite(message) {
	        return this._addCheck({
	            kind: "finite",
	            message: errorUtil.toString(message),
	        });
	    }
	    safe(message) {
	        return this._addCheck({
	            kind: "min",
	            inclusive: true,
	            value: Number.MIN_SAFE_INTEGER,
	            message: errorUtil.toString(message),
	        })._addCheck({
	            kind: "max",
	            inclusive: true,
	            value: Number.MAX_SAFE_INTEGER,
	            message: errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	    get isInt() {
	        return !!this._def.checks.find((ch) => ch.kind === "int" ||
	            (ch.kind === "multipleOf" && util.isInteger(ch.value)));
	    }
	    get isFinite() {
	        let max = null, min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "finite" ||
	                ch.kind === "int" ||
	                ch.kind === "multipleOf") {
	                return true;
	            }
	            else if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	            else if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return Number.isFinite(min) && Number.isFinite(max);
	    }
	}
	ZodNumber.create = (params) => {
	    return new ZodNumber({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodNumber,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBigInt extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            try {
	                input.data = BigInt(input.data);
	            }
	            catch (_a) {
	                return this._getInvalidInput(input);
	            }
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.bigint) {
	            return this._getInvalidInput(input);
	        }
	        let ctx = undefined;
	        const status = new ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        type: "bigint",
	                        minimum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        type: "bigint",
	                        maximum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (input.data % check.value !== BigInt(0)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _getInvalidInput(input) {
	        const ctx = this._getOrReturnCtx(input);
	        addIssueToContext(ctx, {
	            code: ZodIssueCode.invalid_type,
	            expected: ZodParsedType.bigint,
	            received: ctx.parsedType,
	        });
	        return INVALID;
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value,
	            message: errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	ZodBigInt.create = (params) => {
	    var _a;
	    return new ZodBigInt({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodBigInt,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBoolean extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Boolean(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.boolean) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.boolean,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodBoolean.create = (params) => {
	    return new ZodBoolean({
	        typeName: ZodFirstPartyTypeKind.ZodBoolean,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodDate extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = new Date(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.date) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.date,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        if (isNaN(input.data.getTime())) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_date,
	            });
	            return INVALID;
	        }
	        const status = new ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.getTime() < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        minimum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.getTime() > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        maximum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return {
	            status: status.value,
	            value: new Date(input.data.getTime()),
	        };
	    }
	    _addCheck(check) {
	        return new ZodDate({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    min(minDate, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minDate.getTime(),
	            message: errorUtil.toString(message),
	        });
	    }
	    max(maxDate, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxDate.getTime(),
	            message: errorUtil.toString(message),
	        });
	    }
	    get minDate() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min != null ? new Date(min) : null;
	    }
	    get maxDate() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max != null ? new Date(max) : null;
	    }
	}
	ZodDate.create = (params) => {
	    return new ZodDate({
	        checks: [],
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        typeName: ZodFirstPartyTypeKind.ZodDate,
	        ...processCreateParams(params),
	    });
	};
	class ZodSymbol extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.symbol) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.symbol,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodSymbol.create = (params) => {
	    return new ZodSymbol({
	        typeName: ZodFirstPartyTypeKind.ZodSymbol,
	        ...processCreateParams(params),
	    });
	};
	class ZodUndefined extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.undefined,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodUndefined.create = (params) => {
	    return new ZodUndefined({
	        typeName: ZodFirstPartyTypeKind.ZodUndefined,
	        ...processCreateParams(params),
	    });
	};
	class ZodNull extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.null) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.null,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodNull.create = (params) => {
	    return new ZodNull({
	        typeName: ZodFirstPartyTypeKind.ZodNull,
	        ...processCreateParams(params),
	    });
	};
	class ZodAny extends ZodType {
	    constructor() {
	        super(...arguments);
	        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
	        this._any = true;
	    }
	    _parse(input) {
	        return OK(input.data);
	    }
	}
	ZodAny.create = (params) => {
	    return new ZodAny({
	        typeName: ZodFirstPartyTypeKind.ZodAny,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnknown extends ZodType {
	    constructor() {
	        super(...arguments);
	        // required
	        this._unknown = true;
	    }
	    _parse(input) {
	        return OK(input.data);
	    }
	}
	ZodUnknown.create = (params) => {
	    return new ZodUnknown({
	        typeName: ZodFirstPartyTypeKind.ZodUnknown,
	        ...processCreateParams(params),
	    });
	};
	class ZodNever extends ZodType {
	    _parse(input) {
	        const ctx = this._getOrReturnCtx(input);
	        addIssueToContext(ctx, {
	            code: ZodIssueCode.invalid_type,
	            expected: ZodParsedType.never,
	            received: ctx.parsedType,
	        });
	        return INVALID;
	    }
	}
	ZodNever.create = (params) => {
	    return new ZodNever({
	        typeName: ZodFirstPartyTypeKind.ZodNever,
	        ...processCreateParams(params),
	    });
	};
	class ZodVoid extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.void,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodVoid.create = (params) => {
	    return new ZodVoid({
	        typeName: ZodFirstPartyTypeKind.ZodVoid,
	        ...processCreateParams(params),
	    });
	};
	class ZodArray extends ZodType {
	    _parse(input) {
	        const { ctx, status } = this._processInputParams(input);
	        const def = this._def;
	        if (ctx.parsedType !== ZodParsedType.array) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        if (def.exactLength !== null) {
	            const tooBig = ctx.data.length > def.exactLength.value;
	            const tooSmall = ctx.data.length < def.exactLength.value;
	            if (tooBig || tooSmall) {
	                addIssueToContext(ctx, {
	                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
	                    minimum: (tooSmall ? def.exactLength.value : undefined),
	                    maximum: (tooBig ? def.exactLength.value : undefined),
	                    type: "array",
	                    inclusive: true,
	                    exact: true,
	                    message: def.exactLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.minLength !== null) {
	            if (ctx.data.length < def.minLength.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_small,
	                    minimum: def.minLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxLength !== null) {
	            if (ctx.data.length > def.maxLength.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_big,
	                    maximum: def.maxLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.all([...ctx.data].map((item, i) => {
	                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	            })).then((result) => {
	                return ParseStatus.mergeArray(status, result);
	            });
	        }
	        const result = [...ctx.data].map((item, i) => {
	            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	        });
	        return ParseStatus.mergeArray(status, result);
	    }
	    get element() {
	        return this._def.type;
	    }
	    min(minLength, message) {
	        return new ZodArray({
	            ...this._def,
	            minLength: { value: minLength, message: errorUtil.toString(message) },
	        });
	    }
	    max(maxLength, message) {
	        return new ZodArray({
	            ...this._def,
	            maxLength: { value: maxLength, message: errorUtil.toString(message) },
	        });
	    }
	    length(len, message) {
	        return new ZodArray({
	            ...this._def,
	            exactLength: { value: len, message: errorUtil.toString(message) },
	        });
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	ZodArray.create = (schema, params) => {
	    return new ZodArray({
	        type: schema,
	        minLength: null,
	        maxLength: null,
	        exactLength: null,
	        typeName: ZodFirstPartyTypeKind.ZodArray,
	        ...processCreateParams(params),
	    });
	};
	function deepPartialify(schema) {
	    if (schema instanceof ZodObject) {
	        const newShape = {};
	        for (const key in schema.shape) {
	            const fieldSchema = schema.shape[key];
	            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
	        }
	        return new ZodObject({
	            ...schema._def,
	            shape: () => newShape,
	        });
	    }
	    else if (schema instanceof ZodArray) {
	        return new ZodArray({
	            ...schema._def,
	            type: deepPartialify(schema.element),
	        });
	    }
	    else if (schema instanceof ZodOptional) {
	        return ZodOptional.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodNullable) {
	        return ZodNullable.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodTuple) {
	        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	    }
	    else {
	        return schema;
	    }
	}
	class ZodObject extends ZodType {
	    constructor() {
	        super(...arguments);
	        this._cached = null;
	        /**
	         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
	         * If you want to pass through unknown properties, use `.passthrough()` instead.
	         */
	        this.nonstrict = this.passthrough;
	        // extend<
	        //   Augmentation extends ZodRawShape,
	        //   NewOutput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_output"]
	        //       : k extends keyof Output
	        //       ? Output[k]
	        //       : never;
	        //   }>,
	        //   NewInput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_input"]
	        //       : k extends keyof Input
	        //       ? Input[k]
	        //       : never;
	        //   }>
	        // >(
	        //   augmentation: Augmentation
	        // ): ZodObject<
	        //   extendShape<T, Augmentation>,
	        //   UnknownKeys,
	        //   Catchall,
	        //   NewOutput,
	        //   NewInput
	        // > {
	        //   return new ZodObject({
	        //     ...this._def,
	        //     shape: () => ({
	        //       ...this._def.shape(),
	        //       ...augmentation,
	        //     }),
	        //   }) as any;
	        // }
	        /**
	         * @deprecated Use `.extend` instead
	         *  */
	        this.augment = this.extend;
	    }
	    _getCached() {
	        if (this._cached !== null)
	            return this._cached;
	        const shape = this._def.shape();
	        const keys = util.objectKeys(shape);
	        return (this._cached = { shape, keys });
	    }
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.object) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const { status, ctx } = this._processInputParams(input);
	        const { shape, keys: shapeKeys } = this._getCached();
	        const extraKeys = [];
	        if (!(this._def.catchall instanceof ZodNever &&
	            this._def.unknownKeys === "strip")) {
	            for (const key in ctx.data) {
	                if (!shapeKeys.includes(key)) {
	                    extraKeys.push(key);
	                }
	            }
	        }
	        const pairs = [];
	        for (const key of shapeKeys) {
	            const keyValidator = shape[key];
	            const value = ctx.data[key];
	            pairs.push({
	                key: { status: "valid", value: key },
	                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (this._def.catchall instanceof ZodNever) {
	            const unknownKeys = this._def.unknownKeys;
	            if (unknownKeys === "passthrough") {
	                for (const key of extraKeys) {
	                    pairs.push({
	                        key: { status: "valid", value: key },
	                        value: { status: "valid", value: ctx.data[key] },
	                    });
	                }
	            }
	            else if (unknownKeys === "strict") {
	                if (extraKeys.length > 0) {
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.unrecognized_keys,
	                        keys: extraKeys,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (unknownKeys === "strip") ;
	            else {
	                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
	            }
	        }
	        else {
	            // run catchall validation
	            const catchall = this._def.catchall;
	            for (const key of extraKeys) {
	                const value = ctx.data[key];
	                pairs.push({
	                    key: { status: "valid", value: key },
	                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
	                    ),
	                    alwaysSet: key in ctx.data,
	                });
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.resolve()
	                .then(async () => {
	                const syncPairs = [];
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    syncPairs.push({
	                        key,
	                        value,
	                        alwaysSet: pair.alwaysSet,
	                    });
	                }
	                return syncPairs;
	            })
	                .then((syncPairs) => {
	                return ParseStatus.mergeObjectSync(status, syncPairs);
	            });
	        }
	        else {
	            return ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get shape() {
	        return this._def.shape();
	    }
	    strict(message) {
	        errorUtil.errToObj;
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strict",
	            ...(message !== undefined
	                ? {
	                    errorMap: (issue, ctx) => {
	                        var _a, _b, _c, _d;
	                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
	                        if (issue.code === "unrecognized_keys")
	                            return {
	                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
	                            };
	                        return {
	                            message: defaultError,
	                        };
	                    },
	                }
	                : {}),
	        });
	    }
	    strip() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strip",
	        });
	    }
	    passthrough() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "passthrough",
	        });
	    }
	    // const AugmentFactory =
	    //   <Def extends ZodObjectDef>(def: Def) =>
	    //   <Augmentation extends ZodRawShape>(
	    //     augmentation: Augmentation
	    //   ): ZodObject<
	    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
	    //     Def["unknownKeys"],
	    //     Def["catchall"]
	    //   > => {
	    //     return new ZodObject({
	    //       ...def,
	    //       shape: () => ({
	    //         ...def.shape(),
	    //         ...augmentation,
	    //       }),
	    //     }) as any;
	    //   };
	    extend(augmentation) {
	        return new ZodObject({
	            ...this._def,
	            shape: () => ({
	                ...this._def.shape(),
	                ...augmentation,
	            }),
	        });
	    }
	    /**
	     * Prior to zod@1.0.12 there was a bug in the
	     * inferred type of merged objects. Please
	     * upgrade if you are experiencing issues.
	     */
	    merge(merging) {
	        const merged = new ZodObject({
	            unknownKeys: merging._def.unknownKeys,
	            catchall: merging._def.catchall,
	            shape: () => ({
	                ...this._def.shape(),
	                ...merging._def.shape(),
	            }),
	            typeName: ZodFirstPartyTypeKind.ZodObject,
	        });
	        return merged;
	    }
	    // merge<
	    //   Incoming extends AnyZodObject,
	    //   Augmentation extends Incoming["shape"],
	    //   NewOutput extends {
	    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_output"]
	    //       : k extends keyof Output
	    //       ? Output[k]
	    //       : never;
	    //   },
	    //   NewInput extends {
	    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_input"]
	    //       : k extends keyof Input
	    //       ? Input[k]
	    //       : never;
	    //   }
	    // >(
	    //   merging: Incoming
	    // ): ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"],
	    //   NewOutput,
	    //   NewInput
	    // > {
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    setKey(key, schema) {
	        return this.augment({ [key]: schema });
	    }
	    // merge<Incoming extends AnyZodObject>(
	    //   merging: Incoming
	    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
	    // ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"]
	    // > {
	    //   // const mergedShape = objectUtil.mergeShapes(
	    //   //   this._def.shape(),
	    //   //   merging._def.shape()
	    //   // );
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    catchall(index) {
	        return new ZodObject({
	            ...this._def,
	            catchall: index,
	        });
	    }
	    pick(mask) {
	        const shape = {};
	        util.objectKeys(mask).forEach((key) => {
	            if (mask[key] && this.shape[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    omit(mask) {
	        const shape = {};
	        util.objectKeys(this.shape).forEach((key) => {
	            if (!mask[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    /**
	     * @deprecated
	     */
	    deepPartial() {
	        return deepPartialify(this);
	    }
	    partial(mask) {
	        const newShape = {};
	        util.objectKeys(this.shape).forEach((key) => {
	            const fieldSchema = this.shape[key];
	            if (mask && !mask[key]) {
	                newShape[key] = fieldSchema;
	            }
	            else {
	                newShape[key] = fieldSchema.optional();
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    required(mask) {
	        const newShape = {};
	        util.objectKeys(this.shape).forEach((key) => {
	            if (mask && !mask[key]) {
	                newShape[key] = this.shape[key];
	            }
	            else {
	                const fieldSchema = this.shape[key];
	                let newField = fieldSchema;
	                while (newField instanceof ZodOptional) {
	                    newField = newField._def.innerType;
	                }
	                newShape[key] = newField;
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    keyof() {
	        return createZodEnum(util.objectKeys(this.shape));
	    }
	}
	ZodObject.create = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.strictCreate = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strict",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.lazycreate = (shape, params) => {
	    return new ZodObject({
	        shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const options = this._def.options;
	        function handleResults(results) {
	            // return first issue-free validation if it exists
	            for (const result of results) {
	                if (result.result.status === "valid") {
	                    return result.result;
	                }
	            }
	            for (const result of results) {
	                if (result.result.status === "dirty") {
	                    // add issues from dirty option
	                    ctx.common.issues.push(...result.ctx.common.issues);
	                    return result.result;
	                }
	            }
	            // return invalid
	            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return INVALID;
	        }
	        if (ctx.common.async) {
	            return Promise.all(options.map(async (option) => {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                return {
	                    result: await option._parseAsync({
	                        data: ctx.data,
	                        path: ctx.path,
	                        parent: childCtx,
	                    }),
	                    ctx: childCtx,
	                };
	            })).then(handleResults);
	        }
	        else {
	            let dirty = undefined;
	            const issues = [];
	            for (const option of options) {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                const result = option._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: childCtx,
	                });
	                if (result.status === "valid") {
	                    return result;
	                }
	                else if (result.status === "dirty" && !dirty) {
	                    dirty = { result, ctx: childCtx };
	                }
	                if (childCtx.common.issues.length) {
	                    issues.push(childCtx.common.issues);
	                }
	            }
	            if (dirty) {
	                ctx.common.issues.push(...dirty.ctx.common.issues);
	                return dirty.result;
	            }
	            const unionErrors = issues.map((issues) => new ZodError(issues));
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return INVALID;
	        }
	    }
	    get options() {
	        return this._def.options;
	    }
	}
	ZodUnion.create = (types, params) => {
	    return new ZodUnion({
	        options: types,
	        typeName: ZodFirstPartyTypeKind.ZodUnion,
	        ...processCreateParams(params),
	    });
	};
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	//////////                                 //////////
	//////////      ZodDiscriminatedUnion      //////////
	//////////                                 //////////
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	const getDiscriminator = (type) => {
	    if (type instanceof ZodLazy) {
	        return getDiscriminator(type.schema);
	    }
	    else if (type instanceof ZodEffects) {
	        return getDiscriminator(type.innerType());
	    }
	    else if (type instanceof ZodLiteral) {
	        return [type.value];
	    }
	    else if (type instanceof ZodEnum) {
	        return type.options;
	    }
	    else if (type instanceof ZodNativeEnum) {
	        // eslint-disable-next-line ban/ban
	        return util.objectValues(type.enum);
	    }
	    else if (type instanceof ZodDefault) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else if (type instanceof ZodUndefined) {
	        return [undefined];
	    }
	    else if (type instanceof ZodNull) {
	        return [null];
	    }
	    else if (type instanceof ZodOptional) {
	        return [undefined, ...getDiscriminator(type.unwrap())];
	    }
	    else if (type instanceof ZodNullable) {
	        return [null, ...getDiscriminator(type.unwrap())];
	    }
	    else if (type instanceof ZodBranded) {
	        return getDiscriminator(type.unwrap());
	    }
	    else if (type instanceof ZodReadonly) {
	        return getDiscriminator(type.unwrap());
	    }
	    else if (type instanceof ZodCatch) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else {
	        return [];
	    }
	};
	class ZodDiscriminatedUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.object) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const discriminator = this.discriminator;
	        const discriminatorValue = ctx.data[discriminator];
	        const option = this.optionsMap.get(discriminatorValue);
	        if (!option) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_union_discriminator,
	                options: Array.from(this.optionsMap.keys()),
	                path: [discriminator],
	            });
	            return INVALID;
	        }
	        if (ctx.common.async) {
	            return option._parseAsync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	        else {
	            return option._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	    }
	    get discriminator() {
	        return this._def.discriminator;
	    }
	    get options() {
	        return this._def.options;
	    }
	    get optionsMap() {
	        return this._def.optionsMap;
	    }
	    /**
	     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	     * have a different value for each object in the union.
	     * @param discriminator the name of the discriminator property
	     * @param types an array of object schemas
	     * @param params
	     */
	    static create(discriminator, options, params) {
	        // Get all the valid discriminator values
	        const optionsMap = new Map();
	        // try {
	        for (const type of options) {
	            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
	            if (!discriminatorValues.length) {
	                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
	            }
	            for (const value of discriminatorValues) {
	                if (optionsMap.has(value)) {
	                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
	                }
	                optionsMap.set(value, type);
	            }
	        }
	        return new ZodDiscriminatedUnion({
	            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
	            discriminator,
	            options,
	            optionsMap,
	            ...processCreateParams(params),
	        });
	    }
	}
	function mergeValues(a, b) {
	    const aType = getParsedType(a);
	    const bType = getParsedType(b);
	    if (a === b) {
	        return { valid: true, data: a };
	    }
	    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
	        const bKeys = util.objectKeys(b);
	        const sharedKeys = util
	            .objectKeys(a)
	            .filter((key) => bKeys.indexOf(key) !== -1);
	        const newObj = { ...a, ...b };
	        for (const key of sharedKeys) {
	            const sharedValue = mergeValues(a[key], b[key]);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newObj[key] = sharedValue.data;
	        }
	        return { valid: true, data: newObj };
	    }
	    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
	        if (a.length !== b.length) {
	            return { valid: false };
	        }
	        const newArray = [];
	        for (let index = 0; index < a.length; index++) {
	            const itemA = a[index];
	            const itemB = b[index];
	            const sharedValue = mergeValues(itemA, itemB);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newArray.push(sharedValue.data);
	        }
	        return { valid: true, data: newArray };
	    }
	    else if (aType === ZodParsedType.date &&
	        bType === ZodParsedType.date &&
	        +a === +b) {
	        return { valid: true, data: a };
	    }
	    else {
	        return { valid: false };
	    }
	}
	class ZodIntersection extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const handleParsed = (parsedLeft, parsedRight) => {
	            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
	                return INVALID;
	            }
	            const merged = mergeValues(parsedLeft.value, parsedRight.value);
	            if (!merged.valid) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.invalid_intersection_types,
	                });
	                return INVALID;
	            }
	            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
	                status.dirty();
	            }
	            return { status: status.value, value: merged.data };
	        };
	        if (ctx.common.async) {
	            return Promise.all([
	                this._def.left._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	                this._def.right._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	            ]).then(([left, right]) => handleParsed(left, right));
	        }
	        else {
	            return handleParsed(this._def.left._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }), this._def.right._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }));
	        }
	    }
	}
	ZodIntersection.create = (left, right, params) => {
	    return new ZodIntersection({
	        left: left,
	        right: right,
	        typeName: ZodFirstPartyTypeKind.ZodIntersection,
	        ...processCreateParams(params),
	    });
	};
	class ZodTuple extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.array) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        if (ctx.data.length < this._def.items.length) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.too_small,
	                minimum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            return INVALID;
	        }
	        const rest = this._def.rest;
	        if (!rest && ctx.data.length > this._def.items.length) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.too_big,
	                maximum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            status.dirty();
	        }
	        const items = [...ctx.data]
	            .map((item, itemIndex) => {
	            const schema = this._def.items[itemIndex] || this._def.rest;
	            if (!schema)
	                return null;
	            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
	        })
	            .filter((x) => !!x); // filter nulls
	        if (ctx.common.async) {
	            return Promise.all(items).then((results) => {
	                return ParseStatus.mergeArray(status, results);
	            });
	        }
	        else {
	            return ParseStatus.mergeArray(status, items);
	        }
	    }
	    get items() {
	        return this._def.items;
	    }
	    rest(rest) {
	        return new ZodTuple({
	            ...this._def,
	            rest,
	        });
	    }
	}
	ZodTuple.create = (schemas, params) => {
	    if (!Array.isArray(schemas)) {
	        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	    }
	    return new ZodTuple({
	        items: schemas,
	        typeName: ZodFirstPartyTypeKind.ZodTuple,
	        rest: null,
	        ...processCreateParams(params),
	    });
	};
	class ZodRecord extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.object) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const pairs = [];
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        for (const key in ctx.data) {
	            pairs.push({
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
	                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (ctx.common.async) {
	            return ParseStatus.mergeObjectAsync(status, pairs);
	        }
	        else {
	            return ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get element() {
	        return this._def.valueType;
	    }
	    static create(first, second, third) {
	        if (second instanceof ZodType) {
	            return new ZodRecord({
	                keyType: first,
	                valueType: second,
	                typeName: ZodFirstPartyTypeKind.ZodRecord,
	                ...processCreateParams(third),
	            });
	        }
	        return new ZodRecord({
	            keyType: ZodString.create(),
	            valueType: first,
	            typeName: ZodFirstPartyTypeKind.ZodRecord,
	            ...processCreateParams(second),
	        });
	    }
	}
	class ZodMap extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.map) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.map,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
	            return {
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
	                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
	            };
	        });
	        if (ctx.common.async) {
	            const finalMap = new Map();
	            return Promise.resolve().then(async () => {
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    if (key.status === "aborted" || value.status === "aborted") {
	                        return INVALID;
	                    }
	                    if (key.status === "dirty" || value.status === "dirty") {
	                        status.dirty();
	                    }
	                    finalMap.set(key.value, value.value);
	                }
	                return { status: status.value, value: finalMap };
	            });
	        }
	        else {
	            const finalMap = new Map();
	            for (const pair of pairs) {
	                const key = pair.key;
	                const value = pair.value;
	                if (key.status === "aborted" || value.status === "aborted") {
	                    return INVALID;
	                }
	                if (key.status === "dirty" || value.status === "dirty") {
	                    status.dirty();
	                }
	                finalMap.set(key.value, value.value);
	            }
	            return { status: status.value, value: finalMap };
	        }
	    }
	}
	ZodMap.create = (keyType, valueType, params) => {
	    return new ZodMap({
	        valueType,
	        keyType,
	        typeName: ZodFirstPartyTypeKind.ZodMap,
	        ...processCreateParams(params),
	    });
	};
	class ZodSet extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.set) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.set,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const def = this._def;
	        if (def.minSize !== null) {
	            if (ctx.data.size < def.minSize.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_small,
	                    minimum: def.minSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minSize.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxSize !== null) {
	            if (ctx.data.size > def.maxSize.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_big,
	                    maximum: def.maxSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxSize.message,
	                });
	                status.dirty();
	            }
	        }
	        const valueType = this._def.valueType;
	        function finalizeSet(elements) {
	            const parsedSet = new Set();
	            for (const element of elements) {
	                if (element.status === "aborted")
	                    return INVALID;
	                if (element.status === "dirty")
	                    status.dirty();
	                parsedSet.add(element.value);
	            }
	            return { status: status.value, value: parsedSet };
	        }
	        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
	        if (ctx.common.async) {
	            return Promise.all(elements).then((elements) => finalizeSet(elements));
	        }
	        else {
	            return finalizeSet(elements);
	        }
	    }
	    min(minSize, message) {
	        return new ZodSet({
	            ...this._def,
	            minSize: { value: minSize, message: errorUtil.toString(message) },
	        });
	    }
	    max(maxSize, message) {
	        return new ZodSet({
	            ...this._def,
	            maxSize: { value: maxSize, message: errorUtil.toString(message) },
	        });
	    }
	    size(size, message) {
	        return this.min(size, message).max(size, message);
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	ZodSet.create = (valueType, params) => {
	    return new ZodSet({
	        valueType,
	        minSize: null,
	        maxSize: null,
	        typeName: ZodFirstPartyTypeKind.ZodSet,
	        ...processCreateParams(params),
	    });
	};
	class ZodFunction extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.validate = this.implement;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.function) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.function,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        function makeArgsIssue(args, error) {
	            return makeIssue({
	                data: args,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    getErrorMap(),
	                    errorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodIssueCode.invalid_arguments,
	                    argumentsError: error,
	                },
	            });
	        }
	        function makeReturnsIssue(returns, error) {
	            return makeIssue({
	                data: returns,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    getErrorMap(),
	                    errorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodIssueCode.invalid_return_type,
	                    returnTypeError: error,
	                },
	            });
	        }
	        const params = { errorMap: ctx.common.contextualErrorMap };
	        const fn = ctx.data;
	        if (this._def.returns instanceof ZodPromise) {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return OK(async function (...args) {
	                const error = new ZodError([]);
	                const parsedArgs = await me._def.args
	                    .parseAsync(args, params)
	                    .catch((e) => {
	                    error.addIssue(makeArgsIssue(args, e));
	                    throw error;
	                });
	                const result = await Reflect.apply(fn, this, parsedArgs);
	                const parsedReturns = await me._def.returns._def.type
	                    .parseAsync(result, params)
	                    .catch((e) => {
	                    error.addIssue(makeReturnsIssue(result, e));
	                    throw error;
	                });
	                return parsedReturns;
	            });
	        }
	        else {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return OK(function (...args) {
	                const parsedArgs = me._def.args.safeParse(args, params);
	                if (!parsedArgs.success) {
	                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
	                }
	                const result = Reflect.apply(fn, this, parsedArgs.data);
	                const parsedReturns = me._def.returns.safeParse(result, params);
	                if (!parsedReturns.success) {
	                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
	                }
	                return parsedReturns.data;
	            });
	        }
	    }
	    parameters() {
	        return this._def.args;
	    }
	    returnType() {
	        return this._def.returns;
	    }
	    args(...items) {
	        return new ZodFunction({
	            ...this._def,
	            args: ZodTuple.create(items).rest(ZodUnknown.create()),
	        });
	    }
	    returns(returnType) {
	        return new ZodFunction({
	            ...this._def,
	            returns: returnType,
	        });
	    }
	    implement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    strictImplement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    static create(args, returns, params) {
	        return new ZodFunction({
	            args: (args
	                ? args
	                : ZodTuple.create([]).rest(ZodUnknown.create())),
	            returns: returns || ZodUnknown.create(),
	            typeName: ZodFirstPartyTypeKind.ZodFunction,
	            ...processCreateParams(params),
	        });
	    }
	}
	class ZodLazy extends ZodType {
	    get schema() {
	        return this._def.getter();
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const lazySchema = this._def.getter();
	        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
	    }
	}
	ZodLazy.create = (getter, params) => {
	    return new ZodLazy({
	        getter: getter,
	        typeName: ZodFirstPartyTypeKind.ZodLazy,
	        ...processCreateParams(params),
	    });
	};
	class ZodLiteral extends ZodType {
	    _parse(input) {
	        if (input.data !== this._def.value) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                received: ctx.data,
	                code: ZodIssueCode.invalid_literal,
	                expected: this._def.value,
	            });
	            return INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	    get value() {
	        return this._def.value;
	    }
	}
	ZodLiteral.create = (value, params) => {
	    return new ZodLiteral({
	        value: value,
	        typeName: ZodFirstPartyTypeKind.ZodLiteral,
	        ...processCreateParams(params),
	    });
	};
	function createZodEnum(values, params) {
	    return new ZodEnum({
	        values,
	        typeName: ZodFirstPartyTypeKind.ZodEnum,
	        ...processCreateParams(params),
	    });
	}
	class ZodEnum extends ZodType {
	    constructor() {
	        super(...arguments);
	        _ZodEnum_cache.set(this, void 0);
	    }
	    _parse(input) {
	        if (typeof input.data !== "string") {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            addIssueToContext(ctx, {
	                expected: util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodIssueCode.invalid_type,
	            });
	            return INVALID;
	        }
	        if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
	            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
	        }
	        if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            addIssueToContext(ctx, {
	                received: ctx.data,
	                code: ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	    get options() {
	        return this._def.values;
	    }
	    get enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Values() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    extract(values, newDef = this._def) {
	        return ZodEnum.create(values, {
	            ...this._def,
	            ...newDef,
	        });
	    }
	    exclude(values, newDef = this._def) {
	        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
	            ...this._def,
	            ...newDef,
	        });
	    }
	}
	_ZodEnum_cache = new WeakMap();
	ZodEnum.create = createZodEnum;
	class ZodNativeEnum extends ZodType {
	    constructor() {
	        super(...arguments);
	        _ZodNativeEnum_cache.set(this, void 0);
	    }
	    _parse(input) {
	        const nativeEnumValues = util.getValidEnumValues(this._def.values);
	        const ctx = this._getOrReturnCtx(input);
	        if (ctx.parsedType !== ZodParsedType.string &&
	            ctx.parsedType !== ZodParsedType.number) {
	            const expectedValues = util.objectValues(nativeEnumValues);
	            addIssueToContext(ctx, {
	                expected: util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodIssueCode.invalid_type,
	            });
	            return INVALID;
	        }
	        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
	            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
	        }
	        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
	            const expectedValues = util.objectValues(nativeEnumValues);
	            addIssueToContext(ctx, {
	                received: ctx.data,
	                code: ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	    get enum() {
	        return this._def.values;
	    }
	}
	_ZodNativeEnum_cache = new WeakMap();
	ZodNativeEnum.create = (values, params) => {
	    return new ZodNativeEnum({
	        values: values,
	        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
	        ...processCreateParams(params),
	    });
	};
	class ZodPromise extends ZodType {
	    unwrap() {
	        return this._def.type;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.promise &&
	            ctx.common.async === false) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.promise,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const promisified = ctx.parsedType === ZodParsedType.promise
	            ? ctx.data
	            : Promise.resolve(ctx.data);
	        return OK(promisified.then((data) => {
	            return this._def.type.parseAsync(data, {
	                path: ctx.path,
	                errorMap: ctx.common.contextualErrorMap,
	            });
	        }));
	    }
	}
	ZodPromise.create = (schema, params) => {
	    return new ZodPromise({
	        type: schema,
	        typeName: ZodFirstPartyTypeKind.ZodPromise,
	        ...processCreateParams(params),
	    });
	};
	class ZodEffects extends ZodType {
	    innerType() {
	        return this._def.schema;
	    }
	    sourceType() {
	        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
	            ? this._def.schema.sourceType()
	            : this._def.schema;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const effect = this._def.effect || null;
	        const checkCtx = {
	            addIssue: (arg) => {
	                addIssueToContext(ctx, arg);
	                if (arg.fatal) {
	                    status.abort();
	                }
	                else {
	                    status.dirty();
	                }
	            },
	            get path() {
	                return ctx.path;
	            },
	        };
	        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
	        if (effect.type === "preprocess") {
	            const processed = effect.transform(ctx.data, checkCtx);
	            if (ctx.common.async) {
	                return Promise.resolve(processed).then(async (processed) => {
	                    if (status.value === "aborted")
	                        return INVALID;
	                    const result = await this._def.schema._parseAsync({
	                        data: processed,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                    if (result.status === "aborted")
	                        return INVALID;
	                    if (result.status === "dirty")
	                        return DIRTY(result.value);
	                    if (status.value === "dirty")
	                        return DIRTY(result.value);
	                    return result;
	                });
	            }
	            else {
	                if (status.value === "aborted")
	                    return INVALID;
	                const result = this._def.schema._parseSync({
	                    data: processed,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (result.status === "aborted")
	                    return INVALID;
	                if (result.status === "dirty")
	                    return DIRTY(result.value);
	                if (status.value === "dirty")
	                    return DIRTY(result.value);
	                return result;
	            }
	        }
	        if (effect.type === "refinement") {
	            const executeRefinement = (acc) => {
	                const result = effect.refinement(acc, checkCtx);
	                if (ctx.common.async) {
	                    return Promise.resolve(result);
	                }
	                if (result instanceof Promise) {
	                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
	                }
	                return acc;
	            };
	            if (ctx.common.async === false) {
	                const inner = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inner.status === "aborted")
	                    return INVALID;
	                if (inner.status === "dirty")
	                    status.dirty();
	                // return value is ignored
	                executeRefinement(inner.value);
	                return { status: status.value, value: inner.value };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((inner) => {
	                    if (inner.status === "aborted")
	                        return INVALID;
	                    if (inner.status === "dirty")
	                        status.dirty();
	                    return executeRefinement(inner.value).then(() => {
	                        return { status: status.value, value: inner.value };
	                    });
	                });
	            }
	        }
	        if (effect.type === "transform") {
	            if (ctx.common.async === false) {
	                const base = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (!isValid(base))
	                    return base;
	                const result = effect.transform(base.value, checkCtx);
	                if (result instanceof Promise) {
	                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
	                }
	                return { status: status.value, value: result };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((base) => {
	                    if (!isValid(base))
	                        return base;
	                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
	                });
	            }
	        }
	        util.assertNever(effect);
	    }
	}
	ZodEffects.create = (schema, effect, params) => {
	    return new ZodEffects({
	        schema,
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        effect,
	        ...processCreateParams(params),
	    });
	};
	ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	    return new ZodEffects({
	        schema,
	        effect: { type: "preprocess", transform: preprocess },
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        ...processCreateParams(params),
	    });
	};
	class ZodOptional extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === ZodParsedType.undefined) {
	            return OK(undefined);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	ZodOptional.create = (type, params) => {
	    return new ZodOptional({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodOptional,
	        ...processCreateParams(params),
	    });
	};
	class ZodNullable extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === ZodParsedType.null) {
	            return OK(null);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	ZodNullable.create = (type, params) => {
	    return new ZodNullable({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodNullable,
	        ...processCreateParams(params),
	    });
	};
	class ZodDefault extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        let data = ctx.data;
	        if (ctx.parsedType === ZodParsedType.undefined) {
	            data = this._def.defaultValue();
	        }
	        return this._def.innerType._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    removeDefault() {
	        return this._def.innerType;
	    }
	}
	ZodDefault.create = (type, params) => {
	    return new ZodDefault({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodDefault,
	        defaultValue: typeof params.default === "function"
	            ? params.default
	            : () => params.default,
	        ...processCreateParams(params),
	    });
	};
	class ZodCatch extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        // newCtx is used to not collect issues from inner types in ctx
	        const newCtx = {
	            ...ctx,
	            common: {
	                ...ctx.common,
	                issues: [],
	            },
	        };
	        const result = this._def.innerType._parse({
	            data: newCtx.data,
	            path: newCtx.path,
	            parent: {
	                ...newCtx,
	            },
	        });
	        if (isAsync(result)) {
	            return result.then((result) => {
	                return {
	                    status: "valid",
	                    value: result.status === "valid"
	                        ? result.value
	                        : this._def.catchValue({
	                            get error() {
	                                return new ZodError(newCtx.common.issues);
	                            },
	                            input: newCtx.data,
	                        }),
	                };
	            });
	        }
	        else {
	            return {
	                status: "valid",
	                value: result.status === "valid"
	                    ? result.value
	                    : this._def.catchValue({
	                        get error() {
	                            return new ZodError(newCtx.common.issues);
	                        },
	                        input: newCtx.data,
	                    }),
	            };
	        }
	    }
	    removeCatch() {
	        return this._def.innerType;
	    }
	}
	ZodCatch.create = (type, params) => {
	    return new ZodCatch({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodCatch,
	        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
	        ...processCreateParams(params),
	    });
	};
	class ZodNaN extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.nan) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.nan,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	}
	ZodNaN.create = (params) => {
	    return new ZodNaN({
	        typeName: ZodFirstPartyTypeKind.ZodNaN,
	        ...processCreateParams(params),
	    });
	};
	const BRAND = Symbol("zod_brand");
	class ZodBranded extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const data = ctx.data;
	        return this._def.type._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    unwrap() {
	        return this._def.type;
	    }
	}
	class ZodPipeline extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.common.async) {
	            const handleAsync = async () => {
	                const inResult = await this._def.in._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inResult.status === "aborted")
	                    return INVALID;
	                if (inResult.status === "dirty") {
	                    status.dirty();
	                    return DIRTY(inResult.value);
	                }
	                else {
	                    return this._def.out._parseAsync({
	                        data: inResult.value,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                }
	            };
	            return handleAsync();
	        }
	        else {
	            const inResult = this._def.in._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	            if (inResult.status === "aborted")
	                return INVALID;
	            if (inResult.status === "dirty") {
	                status.dirty();
	                return {
	                    status: "dirty",
	                    value: inResult.value,
	                };
	            }
	            else {
	                return this._def.out._parseSync({
	                    data: inResult.value,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	            }
	        }
	    }
	    static create(a, b) {
	        return new ZodPipeline({
	            in: a,
	            out: b,
	            typeName: ZodFirstPartyTypeKind.ZodPipeline,
	        });
	    }
	}
	class ZodReadonly extends ZodType {
	    _parse(input) {
	        const result = this._def.innerType._parse(input);
	        const freeze = (data) => {
	            if (isValid(data)) {
	                data.value = Object.freeze(data.value);
	            }
	            return data;
	        };
	        return isAsync(result)
	            ? result.then((data) => freeze(data))
	            : freeze(result);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	ZodReadonly.create = (type, params) => {
	    return new ZodReadonly({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodReadonly,
	        ...processCreateParams(params),
	    });
	};
	////////////////////////////////////////
	////////////////////////////////////////
	//////////                    //////////
	//////////      z.custom      //////////
	//////////                    //////////
	////////////////////////////////////////
	////////////////////////////////////////
	function cleanParams(params, data) {
	    const p = typeof params === "function"
	        ? params(data)
	        : typeof params === "string"
	            ? { message: params }
	            : params;
	    const p2 = typeof p === "string" ? { message: p } : p;
	    return p2;
	}
	function custom(check, _params = {}, 
	/**
	 * @deprecated
	 *
	 * Pass `fatal` into the params object instead:
	 *
	 * ```ts
	 * z.string().custom((val) => val.length > 5, { fatal: false })
	 * ```
	 *
	 */
	fatal) {
	    if (check)
	        return ZodAny.create().superRefine((data, ctx) => {
	            var _a, _b;
	            const r = check(data);
	            if (r instanceof Promise) {
	                return r.then((r) => {
	                    var _a, _b;
	                    if (!r) {
	                        const params = cleanParams(_params, data);
	                        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
	                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
	                    }
	                });
	            }
	            if (!r) {
	                const params = cleanParams(_params, data);
	                const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
	                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
	            }
	            return;
	        });
	    return ZodAny.create();
	}
	const late = {
	    object: ZodObject.lazycreate,
	};
	var ZodFirstPartyTypeKind;
	(function (ZodFirstPartyTypeKind) {
	    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
	    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
	    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
	    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
	    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
	    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
	    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
	    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
	    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
	    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
	    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
	    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
	    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
	    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
	    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
	    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
	    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
	    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
	    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
	    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
	    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
	    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
	    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
	    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
	    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
	    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
	    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
	    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
	    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
	    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
	    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
	    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
	    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
	    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
	    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
	})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
	const instanceOfType = (
	// const instanceOfType = <T extends new (...args: any[]) => any>(
	cls, params = {
	    message: `Input not instance of ${cls.name}`,
	}) => custom((data) => data instanceof cls, params);
	const stringType = ZodString.create;
	const numberType = ZodNumber.create;
	const nanType = ZodNaN.create;
	const bigIntType = ZodBigInt.create;
	const booleanType = ZodBoolean.create;
	const dateType = ZodDate.create;
	const symbolType = ZodSymbol.create;
	const undefinedType = ZodUndefined.create;
	const nullType = ZodNull.create;
	const anyType = ZodAny.create;
	const unknownType = ZodUnknown.create;
	const neverType = ZodNever.create;
	const voidType = ZodVoid.create;
	const arrayType = ZodArray.create;
	const objectType = ZodObject.create;
	const strictObjectType = ZodObject.strictCreate;
	const unionType = ZodUnion.create;
	const discriminatedUnionType = ZodDiscriminatedUnion.create;
	const intersectionType = ZodIntersection.create;
	const tupleType = ZodTuple.create;
	const recordType = ZodRecord.create;
	const mapType = ZodMap.create;
	const setType = ZodSet.create;
	const functionType = ZodFunction.create;
	const lazyType = ZodLazy.create;
	const literalType = ZodLiteral.create;
	const enumType = ZodEnum.create;
	const nativeEnumType = ZodNativeEnum.create;
	const promiseType = ZodPromise.create;
	const effectsType = ZodEffects.create;
	const optionalType = ZodOptional.create;
	const nullableType = ZodNullable.create;
	const preprocessType = ZodEffects.createWithPreprocess;
	const pipelineType = ZodPipeline.create;
	const ostring = () => stringType().optional();
	const onumber = () => numberType().optional();
	const oboolean = () => booleanType().optional();
	const coerce = {
	    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
	    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
	    boolean: ((arg) => ZodBoolean.create({
	        ...arg,
	        coerce: true,
	    })),
	    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
	    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
	};
	const NEVER = INVALID;

	var z = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    defaultErrorMap: errorMap,
	    setErrorMap: setErrorMap,
	    getErrorMap: getErrorMap,
	    makeIssue: makeIssue,
	    EMPTY_PATH: EMPTY_PATH,
	    addIssueToContext: addIssueToContext,
	    ParseStatus: ParseStatus,
	    INVALID: INVALID,
	    DIRTY: DIRTY,
	    OK: OK,
	    isAborted: isAborted,
	    isDirty: isDirty,
	    isValid: isValid,
	    isAsync: isAsync,
	    get util () { return util; },
	    get objectUtil () { return objectUtil; },
	    ZodParsedType: ZodParsedType,
	    getParsedType: getParsedType,
	    ZodType: ZodType,
	    datetimeRegex: datetimeRegex,
	    ZodString: ZodString,
	    ZodNumber: ZodNumber,
	    ZodBigInt: ZodBigInt,
	    ZodBoolean: ZodBoolean,
	    ZodDate: ZodDate,
	    ZodSymbol: ZodSymbol,
	    ZodUndefined: ZodUndefined,
	    ZodNull: ZodNull,
	    ZodAny: ZodAny,
	    ZodUnknown: ZodUnknown,
	    ZodNever: ZodNever,
	    ZodVoid: ZodVoid,
	    ZodArray: ZodArray,
	    ZodObject: ZodObject,
	    ZodUnion: ZodUnion,
	    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
	    ZodIntersection: ZodIntersection,
	    ZodTuple: ZodTuple,
	    ZodRecord: ZodRecord,
	    ZodMap: ZodMap,
	    ZodSet: ZodSet,
	    ZodFunction: ZodFunction,
	    ZodLazy: ZodLazy,
	    ZodLiteral: ZodLiteral,
	    ZodEnum: ZodEnum,
	    ZodNativeEnum: ZodNativeEnum,
	    ZodPromise: ZodPromise,
	    ZodEffects: ZodEffects,
	    ZodTransformer: ZodEffects,
	    ZodOptional: ZodOptional,
	    ZodNullable: ZodNullable,
	    ZodDefault: ZodDefault,
	    ZodCatch: ZodCatch,
	    ZodNaN: ZodNaN,
	    BRAND: BRAND,
	    ZodBranded: ZodBranded,
	    ZodPipeline: ZodPipeline,
	    ZodReadonly: ZodReadonly,
	    custom: custom,
	    Schema: ZodType,
	    ZodSchema: ZodType,
	    late: late,
	    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
	    coerce: coerce,
	    any: anyType,
	    array: arrayType,
	    bigint: bigIntType,
	    boolean: booleanType,
	    date: dateType,
	    discriminatedUnion: discriminatedUnionType,
	    effect: effectsType,
	    'enum': enumType,
	    'function': functionType,
	    'instanceof': instanceOfType,
	    intersection: intersectionType,
	    lazy: lazyType,
	    literal: literalType,
	    map: mapType,
	    nan: nanType,
	    nativeEnum: nativeEnumType,
	    never: neverType,
	    'null': nullType,
	    nullable: nullableType,
	    number: numberType,
	    object: objectType,
	    oboolean: oboolean,
	    onumber: onumber,
	    optional: optionalType,
	    ostring: ostring,
	    pipeline: pipelineType,
	    preprocess: preprocessType,
	    promise: promiseType,
	    record: recordType,
	    set: setType,
	    strictObject: strictObjectType,
	    string: stringType,
	    symbol: symbolType,
	    transformer: effectsType,
	    tuple: tupleType,
	    'undefined': undefinedType,
	    union: unionType,
	    unknown: unknownType,
	    'void': voidType,
	    NEVER: NEVER,
	    ZodIssueCode: ZodIssueCode,
	    quotelessJson: quotelessJson,
	    ZodError: ZodError
	});

	const flowNodeLinkSchema = z.object({
	    key: z.string().optional(),
	    filter: z.any().optional(),
	    name: z.string().optional(),
	});
	const flowInstanceNodeCreateSchema = z.object({
	    name: z.string().optional(),
	    type: z.string().optional(),
	    userConfig: z.any().optional(),
	    config: z.any().optional(),
	    onError: z.enum(['stop', 'continue']).optional(),
	    concurrency: z.number().optional(),
	    ui: z.any().optional(),
	    links: z.array(flowNodeLinkSchema).optional(),
	    isCustomized: z.boolean().optional(),
	});
	const flowInstanceNodeUpdateSchema = z.object({
	    name: z.string().optional(),
	    type: z.string().optional(),
	    userConfig: z.any().optional(),
	    config: z.any().optional(),
	    onError: z.enum(['stop', 'continue']).optional(),
	    links: z.array(flowNodeLinkSchema).optional(),
	    concurrency: z.number().optional(),
	    isCustomized: z.boolean().optional(),
	});
	const createFlowInstanceSchema = z.object({
	    name: z.string().optional(),
	    userId: z.string().optional(),
	    flowId: z.string().optional(),
	    connectionId: z.string().optional(),
	    integrationId: z.string().optional(),
	    instanceKey: z.string().optional(),
	    parameters: z.any().optional(),
	    nodes: z.record(z.string(), flowInstanceNodeCreateSchema).optional(),
	    enabled: z.boolean().optional(),
	    customized: z
	        .object({
	        name: z.boolean().optional(),
	        nodes: z.boolean().optional(),
	    })
	        .optional(),
	});
	const updateFlowInstanceSchema = z.object({
	    name: z.string().optional(),
	    enabled: z.boolean().optional(),
	    parameters: z.any().optional(),
	    nodes: z.record(z.string(), flowInstanceNodeUpdateSchema).optional(),
	    archivedAt: z.string().optional(),
	    customized: z
	        .object({
	        name: z.boolean().optional(),
	        nodes: z.boolean().optional(),
	    })
	        .optional(),
	});

	var ConfigurationState;
	(function (ConfigurationState) {
	    ConfigurationState["CONFIGURED"] = "CONFIGURED";
	    ConfigurationState["NOT_CONFIGURED"] = "NOT_CONFIGURED";
	})(ConfigurationState || (ConfigurationState = {}));
	var WorkspaceElementType;
	(function (WorkspaceElementType) {
	    WorkspaceElementType["Customer"] = "customer";
	    WorkspaceElementType["Connector"] = "connector";
	    WorkspaceElementType["Integration"] = "integration";
	    WorkspaceElementType["Flow"] = "flow";
	    WorkspaceElementType["FlowInstance"] = "flow-instance";
	    WorkspaceElementType["FlowRun"] = "flow-run";
	    WorkspaceElementType["Action"] = "action";
	    WorkspaceElementType["Scenario"] = "scenario";
	    WorkspaceElementType["ActionInstance"] = "action-instance";
	    WorkspaceElementType["Connection"] = "connection";
	    WorkspaceElementType["FieldMapping"] = "field-mapping";
	    WorkspaceElementType["FieldMappingInstance"] = "field-mapping-instance";
	    WorkspaceElementType["DataSource"] = "data-source";
	    WorkspaceElementType["DataSourceInstance"] = "data-source-instance";
	    WorkspaceElementType["DataLinkTable"] = "data-link-table";
	    WorkspaceElementType["DataLinkTableInstance"] = "data-link-table-instance";
	    WorkspaceElementType["AppEventType"] = "app-event-type";
	    WorkspaceElementType["AppEventSubscription"] = "app-event-subscription";
	    WorkspaceElementType["AppDataSchema"] = "app-data-schema";
	    WorkspaceElementType["AppDataSchemaInstance"] = "app-data-schema-instance";
	    WorkspaceElementType["ExternalEventSubscription"] = "external-event-subscription";
	    WorkspaceElementType["ExternalEventLogRecord"] = "external-event-log-record";
	    WorkspaceElementType["ExternalEventPull"] = "external-event-pull";
	    WorkspaceElementType["Screen"] = "screen";
	})(WorkspaceElementType || (WorkspaceElementType = {}));
	var WorkspaceEventType;
	(function (WorkspaceEventType) {
	    WorkspaceEventType["ConnectionCreated"] = "connection.created";
	    WorkspaceEventType["ConnectionDeleted"] = "connection.deleted";
	    WorkspaceEventType["ConnectionDisconnected"] = "connection.disconnected";
	    WorkspaceEventType["ConnectionReconnected"] = "connection.reconnected";
	    WorkspaceEventType["FlowRunQueued"] = "flowRun.queued";
	    WorkspaceEventType["FlowRunStarted"] = "flowRun.started";
	    WorkspaceEventType["FlowRunCompleted"] = "flowRun.completed";
	    WorkspaceEventType["FlowRunFailed"] = "flowRun.failed";
	    WorkspaceEventType["FlowRunStopped"] = "flowRun.stopped";
	})(WorkspaceEventType || (WorkspaceEventType = {}));
	var WorkspaceElementState;
	(function (WorkspaceElementState) {
	    WorkspaceElementState["SETTING_UP"] = "SETTING_UP";
	    WorkspaceElementState["CONFIGURATION_ERROR"] = "CONFIGURATION_ERROR";
	    WorkspaceElementState["SETUP_FAILED"] = "SETUP_FAILED";
	    WorkspaceElementState["READY"] = "READY";
	})(WorkspaceElementState || (WorkspaceElementState = {}));
	var WorkspaceElementDependencyType;
	(function (WorkspaceElementDependencyType) {
	    WorkspaceElementDependencyType["Configuration"] = "CONFIGURATION";
	    WorkspaceElementDependencyType["Parent"] = "PARENT";
	})(WorkspaceElementDependencyType || (WorkspaceElementDependencyType = {}));

	const WorkspaceElementSpecs = {
	    [WorkspaceElementType.Customer]: {
	        type: WorkspaceElementType.Customer,
	    },
	    [WorkspaceElementType.Connector]: {
	        type: WorkspaceElementType.Connector,
	    },
	    [WorkspaceElementType.Integration]: {
	        type: WorkspaceElementType.Integration,
	    },
	    [WorkspaceElementType.Flow]: {
	        type: WorkspaceElementType.Flow,
	    },
	    [WorkspaceElementType.FlowInstance]: {
	        type: WorkspaceElementType.FlowInstance,
	        createSchema: createFlowInstanceSchema,
	        updateSchema: updateFlowInstanceSchema,
	    },
	    [WorkspaceElementType.FlowRun]: {
	        type: WorkspaceElementType.FlowRun,
	    },
	    [WorkspaceElementType.Action]: {
	        type: WorkspaceElementType.Action,
	    },
	    [WorkspaceElementType.Scenario]: {
	        type: WorkspaceElementType.Scenario,
	    },
	    [WorkspaceElementType.ActionInstance]: {
	        type: WorkspaceElementType.ActionInstance,
	    },
	    [WorkspaceElementType.Connection]: {
	        type: WorkspaceElementType.Connection,
	    },
	    [WorkspaceElementType.FieldMapping]: {
	        type: WorkspaceElementType.FieldMapping,
	    },
	    [WorkspaceElementType.FieldMappingInstance]: {
	        type: WorkspaceElementType.FieldMappingInstance,
	    },
	    [WorkspaceElementType.DataSource]: {
	        type: WorkspaceElementType.DataSource,
	    },
	    [WorkspaceElementType.DataSourceInstance]: {
	        type: WorkspaceElementType.DataSourceInstance,
	    },
	    [WorkspaceElementType.DataLinkTable]: {
	        type: WorkspaceElementType.DataLinkTable,
	    },
	    [WorkspaceElementType.DataLinkTableInstance]: {
	        type: WorkspaceElementType.DataLinkTableInstance,
	    },
	    [WorkspaceElementType.AppEventType]: {
	        type: WorkspaceElementType.AppEventType,
	    },
	    [WorkspaceElementType.AppEventSubscription]: {
	        type: WorkspaceElementType.AppEventSubscription,
	    },
	    [WorkspaceElementType.AppDataSchema]: {
	        type: WorkspaceElementType.AppDataSchema,
	    },
	    [WorkspaceElementType.AppDataSchemaInstance]: {
	        type: WorkspaceElementType.AppDataSchemaInstance,
	    },
	    [WorkspaceElementType.ExternalEventSubscription]: {
	        type: WorkspaceElementType.ExternalEventSubscription,
	    },
	    [WorkspaceElementType.ExternalEventLogRecord]: {
	        type: WorkspaceElementType.ExternalEventLogRecord,
	    },
	    [WorkspaceElementType.ExternalEventPull]: {
	        type: WorkspaceElementType.ExternalEventPull,
	    },
	    [WorkspaceElementType.Screen]: {
	        type: WorkspaceElementType.Screen,
	    },
	};

	class ElementAccessor {
	    constructor(options) {
	        this.options = options;
	    }
	    getUniqueIdentifier() {
	        return this.getPath();
	    }
	    async get() {
	        return this.options.client.get(this.getPath());
	    }
	    async put(data) {
	        return this.options.client.put(this.getPath(), data);
	    }
	    async patch(data) {
	        return this.options.client.patch(this.getPath(), data);
	    }
	    async archive() {
	        await this.options.client.delete(this.getPath());
	    }
	    getPath(operation = '') {
	        const { path, selector } = this.options;
	        if (typeof selector === 'string') {
	            return `${path}s/${selector}${operation ? '/' + operation : ''}`;
	        }
	        const query = qs.stringify(selector);
	        return `${path}${operation ? '/' + operation : ''}?${query}`;
	    }
	}
	class ElementListAccessor {
	    constructor(client, path) {
	        this.client = client;
	        this.path = path;
	    }
	    async find(query) {
	        return this.client.get(this.path, query);
	    }
	    async findAll(query) {
	        let allItems = [];
	        let currentCursor = '0';
	        while (true) {
	            const { items, cursor } = await this.client.get(this.path, {
	                ...query,
	                limit: 1000,
	                cursor: currentCursor,
	            });
	            allItems = allItems.concat(items);
	            if (!cursor) {
	                break;
	            }
	            else {
	                currentCursor = cursor;
	            }
	        }
	        return allItems;
	    }
	    async create(data) {
	        return this.client.post(this.path, data);
	    }
	}
	class ElementInstanceListAccessor {
	    constructor(client, path) {
	        this.client = client;
	        this.path = path;
	    }
	    async find(query) {
	        return this.client.get(this.path, query);
	    }
	}
	class ElementInstanceAccessor {
	    constructor(options) {
	        this.options = options;
	    }
	    getUniqueIdentifier() {
	        return this.getPath();
	    }
	    async get() {
	        return this.options.client.get(this.getPath());
	    }
	    async getId() {
	        if (!this.id) {
	            if (this.options.selector && typeof this.options.selector === 'string') {
	                this.id = this.options.selector;
	            }
	            else {
	                const element = await this.get();
	                if (!element) {
	                    throw new Error(`Element not found using selector ${JSON.stringify(this.options.selector)}`);
	                }
	                this.id = element.id;
	            }
	        }
	        return this.id;
	    }
	    async create(data) {
	        if (this.id) {
	            throw new Error('Cannot create: element already exists');
	        }
	        if (this.options.type) {
	            const createSchema = WorkspaceElementSpecs[this.options.type].createSchema;
	            if (createSchema) {
	                if (data) {
	                    data = createSchema.parse(data);
	                }
	            }
	        }
	        const element = await this.options.client.post(this.getPath(), data);
	        this.id = element.id;
	        return element;
	    }
	    async put(data) {
	        if (this.options.type) {
	            const createSchema = WorkspaceElementSpecs[this.options.type].createSchema;
	            if (createSchema) {
	                data = createSchema.parse(data);
	            }
	        }
	        return this.options.client.put(this.getPath(), data);
	    }
	    async patch(data) {
	        if (this.options.type) {
	            const updateSchema = WorkspaceElementSpecs[this.options.type].updateSchema;
	            if (updateSchema) {
	                data = updateSchema.parse(data);
	            }
	        }
	        return this.options.client.patch(this.getPath(), data);
	    }
	    async archive() {
	        return this.options.client.delete(this.getPath());
	    }
	    async delete() {
	        return this.options.client.delete(this.getPath());
	    }
	    getPath(operation = '') {
	        return (this.options.instancePath +
	            (operation ? `/${operation}` : '') +
	            '?' +
	            qs.stringify(this.getSelector()));
	    }
	    getSelector() {
	        return typeof this.options.selector === 'string'
	            ? {
	                id: this.options.selector,
	            }
	            : this.options.selector;
	    }
	}

	var insertCss = {exports: {}};

	var hasRequiredInsertCss;

	function requireInsertCss () {
		if (hasRequiredInsertCss) return insertCss.exports;
		hasRequiredInsertCss = 1;
		var containers = []; // will store container HTMLElement references
		var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

		var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';

		function insertCss$1(css, options) {
		    options = options || {};

		    if (css === undefined) {
		        throw new Error(usage);
		    }

		    var position = options.prepend === true ? 'prepend' : 'append';
		    var container = options.container !== undefined ? options.container : document.querySelector('head');
		    var containerId = containers.indexOf(container);

		    // first time we see this container, create the necessary entries
		    if (containerId === -1) {
		        containerId = containers.push(container) - 1;
		        styleElements[containerId] = {};
		    }

		    // try to get the correponding container + position styleElement, create it otherwise
		    var styleElement;

		    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
		        styleElement = styleElements[containerId][position];
		    } else {
		        styleElement = styleElements[containerId][position] = createStyleElement();

		        if (position === 'prepend') {
		            container.insertBefore(styleElement, container.childNodes[0]);
		        } else {
		            container.appendChild(styleElement);
		        }
		    }

		    // strip potential UTF-8 BOM if css was read from a file
		    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }

		    // actually add the stylesheet
		    if (styleElement.styleSheet) {
		        styleElement.styleSheet.cssText += css;
		    } else {
		        styleElement.textContent += css;
		    }

		    return styleElement;
		}
		function createStyleElement() {
		    var styleElement = document.createElement('style');
		    styleElement.setAttribute('type', 'text/css');
		    return styleElement;
		}

		insertCss.exports = insertCss$1;
		insertCss.exports.insertCss = insertCss$1;
		return insertCss.exports;
	}

	var insertCssExports = requireInsertCss();

	var MessageType;
	(function (MessageType) {
	    MessageType["Call"] = "call";
	    MessageType["Reply"] = "reply";
	    MessageType["Syn"] = "syn";
	    MessageType["SynAck"] = "synAck";
	    MessageType["Ack"] = "ack";
	})(MessageType || (MessageType = {}));
	var Resolution;
	(function (Resolution) {
	    Resolution["Fulfilled"] = "fulfilled";
	    Resolution["Rejected"] = "rejected";
	})(Resolution || (Resolution = {}));
	var ErrorCode;
	(function (ErrorCode) {
	    ErrorCode["ConnectionDestroyed"] = "ConnectionDestroyed";
	    ErrorCode["ConnectionTimeout"] = "ConnectionTimeout";
	    ErrorCode["NoIframeSrc"] = "NoIframeSrc";
	})(ErrorCode || (ErrorCode = {}));
	var NativeErrorName;
	(function (NativeErrorName) {
	    NativeErrorName["DataCloneError"] = "DataCloneError";
	})(NativeErrorName || (NativeErrorName = {}));
	var NativeEventType;
	(function (NativeEventType) {
	    NativeEventType["Message"] = "message";
	})(NativeEventType || (NativeEventType = {}));

	var createDestructor = (localName, log) => {
	    const callbacks = [];
	    let destroyed = false;
	    return {
	        destroy(error) {
	            if (!destroyed) {
	                destroyed = true;
	                log(`${localName}: Destroying connection`);
	                callbacks.forEach((callback) => {
	                    callback(error);
	                });
	            }
	        },
	        onDestroy(callback) {
	            destroyed ? callback() : callbacks.push(callback);
	        },
	    };
	};

	var createLogger = (debug) => {
	    /**
	     * Logs a message if debug is enabled.
	     */
	    return (...args) => {
	        if (debug) {
	            console.log('[Penpal]', ...args); // eslint-disable-line no-console
	        }
	    };
	};

	const DEFAULT_PORT_BY_PROTOCOL = {
	    'http:': '80',
	    'https:': '443',
	};
	const URL_REGEX = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/;
	const opaqueOriginSchemes = ['file:', 'data:'];
	/**
	 * Converts a src value into an origin.
	 */
	var getOriginFromSrc = (src) => {
	    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {
	        // The origin of the child document is an opaque origin and its
	        // serialization is "null"
	        // https://html.spec.whatwg.org/multipage/origin.html#origin
	        return 'null';
	    }
	    // Note that if src is undefined, then srcdoc is being used instead of src
	    // and we can follow this same logic below to get the origin of the parent,
	    // which is the origin that we will need to use.
	    const location = document.location;
	    const regexResult = URL_REGEX.exec(src);
	    let protocol;
	    let hostname;
	    let port;
	    if (regexResult) {
	        // It's an absolute URL. Use the parsed info.
	        // regexResult[1] will be undefined if the URL starts with //
	        protocol = regexResult[1] ? regexResult[1] : location.protocol;
	        hostname = regexResult[2];
	        port = regexResult[4];
	    }
	    else {
	        // It's a relative path. Use the current location's info.
	        protocol = location.protocol;
	        hostname = location.hostname;
	        port = location.port;
	    }
	    // If the port is the default for the protocol, we don't want to add it to the origin string
	    // or it won't match the message's event.origin.
	    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';
	    return `${protocol}//${hostname}${portSuffix}`;
	};

	/**
	 * Converts an error object into a plain object.
	 */
	const serializeError = ({ name, message, stack, }) => ({
	    name,
	    message,
	    stack,
	});
	/**
	 * Converts a plain object into an error object.
	 */
	const deserializeError = (obj) => {
	    const deserializedError = new Error();
	    // @ts-ignore
	    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));
	    return deserializedError;
	};

	/**
	 * Listens for "call" messages coming from the remote, executes the corresponding method, and
	 * responds with the return value.
	 */
	var connectCallReceiver = (info, serializedMethods, log) => {
	    const { localName, local, remote, originForSending, originForReceiving, } = info;
	    let destroyed = false;
	    const handleMessageEvent = (event) => {
	        if (event.source !== remote || event.data.penpal !== MessageType.Call) {
	            return;
	        }
	        if (originForReceiving !== '*' && event.origin !== originForReceiving) {
	            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
	            return;
	        }
	        const callMessage = event.data;
	        const { methodName, args, id } = callMessage;
	        log(`${localName}: Received ${methodName}() call`);
	        const createPromiseHandler = (resolution) => {
	            return (returnValue) => {
	                log(`${localName}: Sending ${methodName}() reply`);
	                if (destroyed) {
	                    // It's possible to throw an error here, but it would need to be thrown asynchronously
	                    // and would only be catchable using window.onerror. This is because the consumer
	                    // is merely returning a value from their method and not calling any function
	                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,
	                    // the value of doing so is questionable. Instead, we'll just log a message.
	                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);
	                    return;
	                }
	                const message = {
	                    penpal: MessageType.Reply,
	                    id,
	                    resolution,
	                    returnValue,
	                };
	                if (resolution === Resolution.Rejected &&
	                    returnValue instanceof Error) {
	                    message.returnValue = serializeError(returnValue);
	                    message.returnValueIsError = true;
	                }
	                try {
	                    remote.postMessage(message, originForSending);
	                }
	                catch (err) {
	                    // If a consumer attempts to send an object that's not cloneable (e.g., window),
	                    // we want to ensure the receiver's promise gets rejected.
	                    if (err.name === NativeErrorName.DataCloneError) {
	                        const errorReplyMessage = {
	                            penpal: MessageType.Reply,
	                            id,
	                            resolution: Resolution.Rejected,
	                            returnValue: serializeError(err),
	                            returnValueIsError: true,
	                        };
	                        remote.postMessage(errorReplyMessage, originForSending);
	                    }
	                    throw err;
	                }
	            };
	        };
	        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));
	    };
	    local.addEventListener(NativeEventType.Message, handleMessageEvent);
	    return () => {
	        destroyed = true;
	        local.removeEventListener(NativeEventType.Message, handleMessageEvent);
	    };
	};

	let id = 0;
	/**
	 * @return {number} A unique ID (not universally unique)
	 */
	var generateId = () => ++id;

	const KEY_PATH_DELIMITER = '.';
	const keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];
	const segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);
	const createKeyPath = (key, prefix) => {
	    const segments = keyPathToSegments(prefix || '');
	    segments.push(key);
	    return segmentsToKeyPath(segments);
	};
	/**
	 * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate
	 * objects along the way.
	 *
	 * @param {Object} subject The object on which to set value.
	 * @param {string} keyPath The key path at which to set value.
	 * @param {Object} value The value to store at the given key path.
	 * @returns {Object} Updated subject.
	 */
	const setAtKeyPath = (subject, keyPath, value) => {
	    const segments = keyPathToSegments(keyPath);
	    segments.reduce((prevSubject, key, idx) => {
	        if (typeof prevSubject[key] === 'undefined') {
	            prevSubject[key] = {};
	        }
	        if (idx === segments.length - 1) {
	            prevSubject[key] = value;
	        }
	        return prevSubject[key];
	    }, subject);
	    return subject;
	};
	/**
	 * Given a dictionary of (nested) keys to function, flatten them to a map
	 * from key path to function.
	 *
	 * @param {Object} methods The (potentially nested) object to serialize.
	 * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.
	 * @returns {Object} An map from key path in `methods` to functions.
	 */
	const serializeMethods = (methods, prefix) => {
	    const flattenedMethods = {};
	    Object.keys(methods).forEach((key) => {
	        const value = methods[key];
	        const keyPath = createKeyPath(key, prefix);
	        if (typeof value === 'object') {
	            // Recurse into any nested children.
	            Object.assign(flattenedMethods, serializeMethods(value, keyPath));
	        }
	        if (typeof value === 'function') {
	            // If we've found a method, expose it.
	            flattenedMethods[keyPath] = value;
	        }
	    });
	    return flattenedMethods;
	};
	/**
	 * Given a map of key paths to functions, unpack the key paths to an object.
	 *
	 * @param {Object} flattenedMethods A map of key paths to functions to unpack.
	 * @returns {Object} A (potentially nested) map of functions.
	 */
	const deserializeMethods = (flattenedMethods) => {
	    const methods = {};
	    for (const keyPath in flattenedMethods) {
	        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);
	    }
	    return methods;
	};

	/**
	 * Augments an object with methods that match those defined by the remote. When these methods are
	 * called, a "call" message will be sent to the remote, the remote's corresponding method will be
	 * executed, and the method's return value will be returned via a message.
	 * @param {Object} callSender Sender object that should be augmented with methods.
	 * @param {Object} info Information about the local and remote windows.
	 * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.
	 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
	 * connection.
	 * @returns {Object} The call sender object with methods that may be called.
	 */
	var connectCallSender = (callSender, info, methodKeyPaths, destroyConnection, log) => {
	    const { localName, local, remote, originForSending, originForReceiving, } = info;
	    let destroyed = false;
	    log(`${localName}: Connecting call sender`);
	    const createMethodProxy = (methodName) => {
	        return (...args) => {
	            log(`${localName}: Sending ${methodName}() call`);
	            // This handles the case where the iframe has been removed from the DOM
	            // (and therefore its window closed), the consumer has not yet
	            // called destroy(), and the user calls a method exposed by
	            // the remote. We detect the iframe has been removed and force
	            // a destroy() immediately so that the consumer sees the error saying
	            // the connection has been destroyed. We wrap this check in a try catch
	            // because Edge throws an "Object expected" error when accessing
	            // contentWindow.closed on a contentWindow from an iframe that's been
	            // removed from the DOM.
	            let iframeRemoved;
	            try {
	                if (remote.closed) {
	                    iframeRemoved = true;
	                }
	            }
	            catch (e) {
	                iframeRemoved = true;
	            }
	            if (iframeRemoved) {
	                destroyConnection();
	            }
	            if (destroyed) {
	                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);
	                error.code = ErrorCode.ConnectionDestroyed;
	                throw error;
	            }
	            return new Promise((resolve, reject) => {
	                const id = generateId();
	                const handleMessageEvent = (event) => {
	                    if (event.source !== remote ||
	                        event.data.penpal !== MessageType.Reply ||
	                        event.data.id !== id) {
	                        return;
	                    }
	                    if (originForReceiving !== '*' &&
	                        event.origin !== originForReceiving) {
	                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);
	                        return;
	                    }
	                    const replyMessage = event.data;
	                    log(`${localName}: Received ${methodName}() reply`);
	                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);
	                    let returnValue = replyMessage.returnValue;
	                    if (replyMessage.returnValueIsError) {
	                        returnValue = deserializeError(returnValue);
	                    }
	                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);
	                };
	                local.addEventListener(NativeEventType.Message, handleMessageEvent);
	                const callMessage = {
	                    penpal: MessageType.Call,
	                    id,
	                    methodName,
	                    args,
	                };
	                remote.postMessage(callMessage, originForSending);
	            });
	        };
	    };
	    // Wrap each method in a proxy which sends it to the corresponding receiver.
	    const flattenedMethods = methodKeyPaths.reduce((api, name) => {
	        api[name] = createMethodProxy(name);
	        return api;
	    }, {});
	    // Unpack the structure of the provided methods object onto the CallSender, exposing
	    // the methods in the same shape they were provided.
	    Object.assign(callSender, deserializeMethods(flattenedMethods));
	    return () => {
	        destroyed = true;
	    };
	};

	/**
	 * Handles an ACK handshake message.
	 */
	var handleAckMessageFactory = (serializedMethods, childOrigin, originForSending, destructor, log) => {
	    const { destroy, onDestroy } = destructor;
	    let destroyCallReceiver;
	    let receiverMethodNames;
	    // We resolve the promise with the call sender. If the child reconnects
	    // (for example, after refreshing or navigating to another page that
	    // uses Penpal, we'll update the call sender with methods that match the
	    // latest provided by the child.
	    const callSender = {};
	    return (event) => {
	        if (childOrigin !== '*' && event.origin !== childOrigin) {
	            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);
	            return;
	        }
	        log('Parent: Handshake - Received ACK');
	        const info = {
	            localName: 'Parent',
	            local: window,
	            remote: event.source,
	            originForSending: originForSending,
	            originForReceiving: childOrigin,
	        };
	        // If the child reconnected, we need to destroy the prior call receiver
	        // before setting up a new one.
	        if (destroyCallReceiver) {
	            destroyCallReceiver();
	        }
	        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);
	        onDestroy(destroyCallReceiver);
	        // If the child reconnected, we need to remove the methods from the
	        // previous call receiver off the sender.
	        if (receiverMethodNames) {
	            receiverMethodNames.forEach((receiverMethodName) => {
	                delete callSender[receiverMethodName];
	            });
	        }
	        receiverMethodNames = event.data.methodNames;
	        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);
	        onDestroy(destroyCallSender);
	        return callSender;
	    };
	};

	/**
	 * Handles a SYN handshake message.
	 */
	var handleSynMessageFactory = (log, serializedMethods, childOrigin, originForSending) => {
	    return (event) => {
	        // Under specific timing circumstances, we can receive an event
	        // whose source is null. This seems to happen when the child iframe is
	        // removed from the DOM about the same time it has sent the SYN event.
	        // https://github.com/Aaronius/penpal/issues/85
	        if (!event.source) {
	            return;
	        }
	        if (childOrigin !== '*' && event.origin !== childOrigin) {
	            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);
	            return;
	        }
	        log('Parent: Handshake - Received SYN, responding with SYN-ACK');
	        const synAckMessage = {
	            penpal: MessageType.SynAck,
	            methodNames: Object.keys(serializedMethods),
	        };
	        event.source.postMessage(synAckMessage, originForSending);
	    };
	};

	const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;
	/**
	 * Monitors for iframe removal and destroys connection if iframe
	 * is found to have been removed from DOM. This is to prevent memory
	 * leaks when the iframe is removed from the document and the consumer
	 * hasn't called destroy(). Without this, event listeners attached to
	 * the window would stick around and since the event handlers have a
	 * reference to the iframe in their closures, the iframe would stick
	 * around too.
	 */
	var monitorIframeRemoval = (iframe, destructor) => {
	    const { destroy, onDestroy } = destructor;
	    const checkIframeInDocIntervalId = setInterval(() => {
	        if (!iframe.isConnected) {
	            clearInterval(checkIframeInDocIntervalId);
	            destroy();
	        }
	    }, CHECK_IFRAME_IN_DOC_INTERVAL);
	    onDestroy(() => {
	        clearInterval(checkIframeInDocIntervalId);
	    });
	};

	/**
	 * Starts a timeout and calls the callback with an error
	 * if the timeout completes before the stop function is called.
	 */
	var startConnectionTimeout = (timeout, callback) => {
	    let timeoutId;
	    if (timeout !== undefined) {
	        timeoutId = window.setTimeout(() => {
	            const error = new Error(`Connection timed out after ${timeout}ms`);
	            error.code = ErrorCode.ConnectionTimeout;
	            callback(error);
	        }, timeout);
	    }
	    return () => {
	        clearTimeout(timeoutId);
	    };
	};

	var validateIframeHasSrcOrSrcDoc = (iframe) => {
	    if (!iframe.src && !iframe.srcdoc) {
	        const error = new Error('Iframe must have src or srcdoc property defined.');
	        error.code = ErrorCode.NoIframeSrc;
	        throw error;
	    }
	};

	/**
	 * Attempts to establish communication with an iframe.
	 */
	var connectToChild = (options) => {
	    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;
	    const log = createLogger(debug);
	    const destructor = createDestructor('Parent', log);
	    const { onDestroy, destroy } = destructor;
	    if (!childOrigin) {
	        validateIframeHasSrcOrSrcDoc(iframe);
	        childOrigin = getOriginFromSrc(iframe.src);
	    }
	    // If event.origin is "null", the remote protocol is file: or data: and we
	    // must post messages with "*" as targetOrigin when sending messages.
	    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions
	    const originForSending = childOrigin === 'null' ? '*' : childOrigin;
	    const serializedMethods = serializeMethods(methods);
	    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);
	    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);
	    const promise = new Promise((resolve, reject) => {
	        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);
	        const handleMessage = (event) => {
	            if (event.source !== iframe.contentWindow || !event.data) {
	                return;
	            }
	            if (event.data.penpal === MessageType.Syn) {
	                handleSynMessage(event);
	                return;
	            }
	            if (event.data.penpal === MessageType.Ack) {
	                const callSender = handleAckMessage(event);
	                if (callSender) {
	                    stopConnectionTimeout();
	                    resolve(callSender);
	                }
	                return;
	            }
	        };
	        window.addEventListener(NativeEventType.Message, handleMessage);
	        log('Parent: Awaiting handshake');
	        monitorIframeRemoval(iframe, destructor);
	        onDestroy((error) => {
	            window.removeEventListener(NativeEventType.Message, handleMessage);
	            if (error) {
	                reject(error);
	            }
	        });
	    });
	    return {
	        promise,
	        destroy() {
	            // Don't allow consumer to pass an error into destroy.
	            destroy();
	        },
	    };
	};

	const POPUP_ELEMENT_ID = '__integration-app-popup';
	const CONTAINER_ELEMENT_ID = '__integration-app-container';
	const CONTAINER_ELEMENT_CLASS = '__integration-app-container';
	const CONTAINER_ELEMENT_CLASS__LOADER = '__integration-app-container__loader';
	const BODY_CLASS = '__integration-app-open';
	let initialized = false;
	let IFRAME_START_SHOW_LOADER_TIME = 0;
	let IFRAME_SHOW_LOADER_TIMEOUT_ID;
	const IFRAME_SHOW_LOADER_MINIMAL_TIME = 500;
	const IFRAME_LAYOUT_SHIFT_TIME = 300;
	function showIframeLoader() {
	    if (!initialized) {
	        initialized = true;
	        init();
	    }
	    const container = getContainer();
	    container === null || container === void 0 ? void 0 : container.classList.add(CONTAINER_ELEMENT_CLASS__LOADER);
	    IFRAME_START_SHOW_LOADER_TIME = Date.now();
	}
	function hideIframeLoader(waitLayoutShift = IFRAME_LAYOUT_SHIFT_TIME) {
	    if (IFRAME_SHOW_LOADER_TIMEOUT_ID) {
	        clearTimeout(IFRAME_SHOW_LOADER_TIMEOUT_ID);
	    }
	    const delta = Date.now() - IFRAME_START_SHOW_LOADER_TIME;
	    if (delta >= IFRAME_SHOW_LOADER_MINIMAL_TIME) {
	        setTimeout(() => {
	            const container = getContainer();
	            container === null || container === void 0 ? void 0 : container.classList.remove(CONTAINER_ELEMENT_CLASS__LOADER);
	            IFRAME_START_SHOW_LOADER_TIME = 0;
	        }, waitLayoutShift);
	        return;
	    }
	    else {
	        const waitLayoutShift = delta >= IFRAME_LAYOUT_SHIFT_TIME ? 0 : IFRAME_LAYOUT_SHIFT_TIME - delta;
	        const timeoutTime = IFRAME_SHOW_LOADER_MINIMAL_TIME - delta;
	        IFRAME_SHOW_LOADER_TIMEOUT_ID = setTimeout(() => {
	            hideIframeLoader(waitLayoutShift);
	        }, timeoutTime);
	        return;
	    }
	}
	async function openIframe(uri, callbacks = {}) {
	    if (!initialized) {
	        initialized = true;
	        init();
	    }
	    close();
	    return new Promise((resolve) => {
	        function complete(callback) {
	            close(callback);
	            resolve();
	        }
	        function doOpen() {
	            const iframe = document.createElement('iframe');
	            iframe.src = uri;
	            iframe.id = POPUP_ELEMENT_ID;
	            iframe.onload = () => {
	                hideIframeLoader();
	            };
	            if (!!getContainer()) {
	                document.body.classList.add(BODY_CLASS);
	                showIframeLoader();
	                appendToContainer(iframe);
	                connectToChild({
	                    iframe,
	                    methods: {
	                        ...callbacks,
	                        handshake: (...args) => {
	                            var _a;
	                            hideIframeLoader();
	                            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.handshake) === null || _a === void 0 ? void 0 : _a.call(callbacks, ...args);
	                        },
	                        close: () => complete(callbacks.onClose),
	                    },
	                });
	            }
	            else {
	                throw Error('Integration.app container element not found. Was it manually removed?');
	            }
	        }
	        if (document.readyState === 'complete' ||
	            document.readyState === 'interactive') {
	            doOpen();
	        }
	        else {
	            document.addEventListener('DOMContentLoaded', () => {
	                doOpen();
	            });
	        }
	    });
	}
	function close(callback) {
	    document.body.classList.remove(BODY_CLASS);
	    if (!!getContainer()) {
	        clearContainer();
	        if (callback) {
	            callback();
	        }
	    }
	}
	function init() {
	    if (!!getContainer()) {
	        return;
	    }
	    insertCssExports.insertCss(`
    .${CONTAINER_ELEMENT_CLASS}:empty {
      display: none;
    }
    .${CONTAINER_ELEMENT_CLASS} {
      position: fixed;
      inset: 0;
      z-index: 2147483647;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: auto;
      background: rgba(0, 0, 0, 0);
      transition: background 0.2s ease-out;
    }

    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER} {
      background: rgba(0, 0, 0, 0.8);
    }
    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER}::before {
      content: "";
      width: 5rem;
      height: 4rem;
      background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 32 22" fill="%23000" xmlns="http://www.w3.org/2000/svg" %3E%3Cdefs%3E%3Cmask id="a"%3E%3Crect width="100%25" height="100%25" fill="%23fff" /%3E%3Cpath d="M11.8 13.12a3 3 0 0 1 0-4.24l7.08-7.07a3 3 0 0 1 4.24 0l7.07 7.07a3 3 0 0 1 0 4.24l-7.07 7.07a3 3 0 0 1-4.24 0l-7.07-7.07Z"%3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 21 11" to="-360 21 11" /%3E%3C/path%3E%3C/mask%3E%3Cmask id="b"%3E%3Crect width="100%25" height="100%25" fill="%23fff"/%3E%3Cpath fill-rule="evenodd" clip-rule="evenodd" d="M1.8 8.88a3 3 0 0 0 0 4.24l7.08 7.07a3 3 0 0 0 4.24 0l7.07-7.07a3 3 0 0 0 0-4.24L13.12 1.8a3 3 0 0 0-4.24 0L1.8 8.88Zm.71.7a2 2 0 0 0 0 2.83L9.6 19.5a2 2 0 0 0 2.82 0l7.08-7.08a2 2 0 0 0 0-2.82l-7.1-7.1a2 2 0 0 0-2.82 0L2.5 9.6Z" %3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 11 11" to="720 11 11" /%3E%3C/path%3E%3C/mask%3E%3C/defs%3E%3Cg mask="url(%23a)"%3E%3Cpath fill-rule="evenodd" clip-rule="evenodd" d="M1.8 8.88a3 3 0 0 0 0 4.24l7.08 7.07a3 3 0 0 0 4.24 0l7.07-7.07a3 3 0 0 0 0-4.24L13.12 1.8a3 3 0 0 0-4.24 0L1.8 8.88Zm.71.7a2 2 0 0 0 0 2.83L9.6 19.5a2 2 0 0 0 2.82 0l7.08-7.08a2 2 0 0 0 0-2.82l-7.1-7.1a2 2 0 0 0-2.82 0L2.5 9.6Z"%0A%3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 11 11" to="720 11 11" /%3E%3C/path%3E%3C/g%3E%3Cg mask="url(%23b)"%3E%3Cpath d="M11.8 13.12a3 3 0 0 1 0-4.24l7.08-7.07a3 3 0 0 1 4.24 0l7.07 7.07a3 3 0 0 1 0 4.24l-7.07 7.07a3 3 0 0 1-4.24 0l-7.07-7.07Z"%3E%3CanimateTransform attributeName="transform" attributeType="XML" type="rotate" repeatCount="indefinite" calcMode="spline" keyTimes="0;1" dur="5s" keySplines="0 0 0.1 1" from="0 21 11" to="-360 21 11" /%3E%3C/path%3E%3C/g%3E%3C/svg%3E');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      filter: invert(1);
    }

    .${CONTAINER_ELEMENT_CLASS} iframe {
      position: absolute;
      width: 100%;
      height: 100%;
      border-width: 0;

      /* fix transparent bg, because iframe document has light scheme */
      color-scheme: light;
    }

    .${CONTAINER_ELEMENT_CLASS}.${CONTAINER_ELEMENT_CLASS__LOADER} iframe {
      visibility: hidden;
    }

    body.${BODY_CLASS} {
      overflow: hidden;
    }
  `);
	    const container = document.createElement('div');
	    container.id = CONTAINER_ELEMENT_ID;
	    container.classList.add(CONTAINER_ELEMENT_CLASS);
	    document.body.appendChild(container);
	}
	function getContainer() {
	    return document.getElementById(CONTAINER_ELEMENT_ID);
	}
	function appendToContainer(el) {
	    const container = getContainer();
	    container === null || container === void 0 ? void 0 : container.appendChild(el);
	}
	function clearContainer() {
	    const container = getContainer();
	    if (container.firstChild) {
	        container.removeChild(container.firstChild);
	    }
	}

	class ConnectionLevelElementAccessor {
	    constructor(client, connectionSelector, selector, elementKey, query) {
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	        this.selector = selector;
	        this.elementKey = elementKey;
	        this.query = query;
	        this.endpoint = `/connections/${this.connectionSelector}/${elementKey}/${selector}`;
	    }
	    uri(path = '', query = {}) {
	        return (this.endpoint + path + '?' + qs.stringify({ ...this.query, ...query }));
	    }
	    getUniqueIdentifier() {
	        return this.endpoint;
	    }
	    async get(query = {}) {
	        return this.client.get(this.uri('', query));
	    }
	    async create() {
	        return this.client.put(this.uri());
	    }
	    async patch(data) {
	        return this.client.patch(this.uri(), data);
	    }
	    async put(data) {
	        return this.client.put(this.uri(), data);
	    }
	    async archive() {
	        return this.client.delete(this.uri());
	    }
	    async reset() {
	        return this.client.post(this.uri('/reset'));
	    }
	    async setup() {
	        return this.client.post(this.uri('/setup'));
	    }
	}
	class ConnectionLevelElementsListAccessor {
	    constructor(client, connectionSelector, elementKey) {
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	        this.elementKey = elementKey;
	    }
	    async list(query) {
	        const endpoint = `/connections/${this.connectionSelector}/${this.elementKey}?${qs.stringify(query !== null && query !== void 0 ? query : {})}`;
	        return this.client.get(endpoint);
	    }
	}

	class IntegrationLevelElementAccessor {
	    constructor(client, integrationSelector, elementSelector, elementKey) {
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	        this.elementSelector = elementSelector;
	        this.elementKey = elementKey;
	        this.endpoint = `/integrations/${this.integrationSelector}/${elementKey}/${elementSelector}`;
	    }
	    getUniqueIdentifier() {
	        return this.endpoint;
	    }
	    async get() {
	        return this.client.get(this.endpoint);
	    }
	    async patch(data) {
	        return this.client.patch(this.endpoint, data);
	    }
	    async put(data) {
	        return this.client.put(this.endpoint, data);
	    }
	    async archive() {
	        return this.client.delete(this.endpoint);
	    }
	    async reset() {
	        return this.client.post(this.endpoint + '/reset');
	    }
	}
	class IntegrationLevelElementsListAccessor {
	    constructor(client, integrationSelector, elementKey) {
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	        this.elementKey = elementKey;
	        this.endpoint = `/integrations/${integrationSelector}/${elementKey}`;
	    }
	    async list(query) {
	        return this.client.get(this.endpoint, query !== null && query !== void 0 ? query : {});
	    }
	    async create(data) {
	        return this.client.post(this.endpoint, data);
	    }
	}

	class ActionsAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'actions');
	    }
	}
	class ActionAccessor extends ElementAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            path: 'action',
	        });
	    }
	    async apply(integrationKeys) {
	        return await this.options.client.post(this.getPath('apply'), {
	            integrationKeys,
	        });
	    }
	    async reset() {
	        return await this.options.client.post(this.getPath('reset'));
	    }
	}
	class ActionInstancesAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'action-instances');
	    }
	}
	class ActionInstanceAccessor extends ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'action-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async setup() {
	        await this.client.post(this.getPath('setup'));
	    }
	    async reset() {
	        await this.client.post(this.getPath('reset'));
	    }
	    async run(input) {
	        return this.client.post(this.getPath('run'), input);
	    }
	    async open({ onClose = () => { }, } = {}) {
	        const id = await this.getId();
	        const uri = await this.client.getEmbedUri(`action-instances/${id}/configuration`);
	        return openIframe(uri, { onClose });
	    }
	}
	class IntegrationLevelActionAccessor extends IntegrationLevelElementAccessor {
	    constructor(client, integrationSelector, actionSelector) {
	        super(client, integrationSelector, actionSelector, 'actions');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	        this.actionSelector = actionSelector;
	    }
	}
	class IntegrationLevelActionsListAccessor extends IntegrationLevelElementsListAccessor {
	    constructor(client, integrationSelector) {
	        super(client, integrationSelector, 'actions');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	    }
	}
	class ConnectionLevelActionAccessor extends ConnectionLevelElementAccessor {
	    constructor(client, connectionSelector, actionSelector, query) {
	        super(client, connectionSelector, actionSelector, 'actions', query);
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	        this.actionSelector = actionSelector;
	        this.query = query;
	    }
	    async run(input) {
	        return this.client.post(this.uri('/run'), input);
	    }
	}
	class ConnectionLevelActionsAccessor extends ConnectionLevelElementsListAccessor {
	    constructor(client, connectionSelector) {
	        super(client, connectionSelector, 'actions');
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	    }
	}

	class FieldMappingsAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'field-mappings');
	    }
	}
	class FieldMappingAccessor extends ElementAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            path: 'field-mapping',
	        });
	    }
	    async getAppSchema() {
	        return await this.options.client.get(this.getPath('app-schema'));
	    }
	    async apply(integrationKeys) {
	        return await this.options.client.post(this.getPath('apply'), {
	            integrationKeys,
	        });
	    }
	    async reset() {
	        return await this.options.client.post(this.getPath('reset'));
	    }
	}
	class FieldMappingInstancesAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'field-mapping-instances');
	    }
	}
	class FieldMappingInstanceAccessor extends ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'field-mapping-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async setup() {
	        const id = await this.getId();
	        return this.client.post(`/field-mapping-instances/${id}/setup`);
	    }
	    async reset() {
	        const id = await this.getId();
	        return this.client.post(`/field-mapping-instances/${id}/reset`);
	    }
	    async openConfiguration({ onClose = () => { }, } = {}) {
	        const id = await this.getId();
	        const uri = await this.client.getEmbedUri(`field-mapping-instances/${id}/configuration`);
	        return openIframe(uri, {
	            onClose,
	        });
	    }
	}
	class IntegrationLevelFieldMappingAccessor extends IntegrationLevelElementAccessor {
	    constructor(client, integrationSelector, fieldMappingSelector) {
	        super(client, integrationSelector, fieldMappingSelector, 'field-mappings');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	        this.fieldMappingSelector = fieldMappingSelector;
	    }
	}
	class IntegrationLevelFieldMappingsListAccessor extends IntegrationLevelElementsListAccessor {
	    constructor(client, integrationSelector) {
	        super(client, integrationSelector, 'field-mappings');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	    }
	}
	class ConnectionLevelFieldMappingAccessor extends ConnectionLevelElementAccessor {
	    constructor(client, connectionSelector, fieldMappingSelector, query) {
	        super(client, connectionSelector, fieldMappingSelector, 'field-mappings', query);
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	        this.fieldMappingSelector = fieldMappingSelector;
	        this.query = query;
	    }
	    async openConfiguration({ onClose, } = {}) {
	        const instance = await this.get({ autoCreate: true });
	        const uri = await this.client.getEmbedUri(`field-mapping-instances/${instance.id}/configuration`);
	        return openIframe(uri, { onClose: onClose !== null && onClose !== void 0 ? onClose : (() => { }) });
	    }
	}
	class ConnectionLevelFieldMappingsAccessor extends ConnectionLevelElementsListAccessor {
	    constructor(client, connectionSelector) {
	        super(client, connectionSelector, 'field-mappings');
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	    }
	}

	var LogRecordType;
	(function (LogRecordType) {
	    LogRecordType["MSG"] = "message";
	    LogRecordType["TEXT"] = "text";
	    LogRecordType["ERR"] = "error";
	    LogRecordType["DATA"] = "data";
	    LogRecordType["COMP"] = "compare";
	    LogRecordType["API"] = "api-request";
	})(LogRecordType || (LogRecordType = {}));

	var ErrorDoc;
	(function (ErrorDoc) {
	    ErrorDoc["AuthenticationTokenErrors"] = "authentication-token-errors";
	    ErrorDoc["DataSourceNoCollectionSelected"] = "data-source-no-collection-selected";
	    ErrorDoc["FlowInstanceSetupFailed"] = "flow-instance-setup-failed";
	    ErrorDoc["FlowInstanceSetupTimeout"] = "flow-instance-setup-timeout";
	    ErrorDoc["WebhookCannotFindUser"] = "webhook-cannot-find-user";
	})(ErrorDoc || (ErrorDoc = {}));

	var ErrorType;
	(function (ErrorType) {
	    ErrorType["BAD_REQUEST"] = "bad_request";
	    ErrorType["CONNECTION"] = "connection";
	    ErrorType["CONFIGURATION"] = "configuration";
	    ErrorType["DEPENDENCY_ERROR"] = "dependency_error";
	    ErrorType["FLOW_RUN"] = "flow_run";
	    ErrorType["FLOW_INSTANCE_SETUP"] = "flow_instance_setup";
	    ErrorType["CONCURRENCY"] = "concurrency";
	    ErrorType["INTERNAL"] = "internal";
	    ErrorType["ACTION_RUN"] = "action_run";
	    ErrorType["ACTION_INSTANCE_SETUP"] = "action_instance_setup";
	    ErrorType["UNIT_RUN"] = "unit_run";
	})(ErrorType || (ErrorType = {}));
	var BadRequestErrorKey;
	(function (BadRequestErrorKey) {
	    BadRequestErrorKey["NOT_FOUND"] = "not_found";
	    BadRequestErrorKey["NOT_AUTHENTICATED"] = "not_authenticated";
	    BadRequestErrorKey["ACCESS_DENIED"] = "access_denied";
	    BadRequestErrorKey["ALREADY_EXISTS"] = "already_exists";
	    BadRequestErrorKey["RATE_LIMIT_EXCEEDED"] = "rate_limit_exceeded";
	})(BadRequestErrorKey || (BadRequestErrorKey = {}));
	var ConnectionErrorKey;
	(function (ConnectionErrorKey) {
	    ConnectionErrorKey["CONNECTION_IS_DEFUNCT"] = "connection_is_defunct";
	    ConnectionErrorKey["ACCESS_TOKEN_EXPIRED"] = "access_token_expired";
	    ConnectionErrorKey["RATE_LIMIT_EXCEEDED"] = "rate_limit_exceeded";
	})(ConnectionErrorKey || (ConnectionErrorKey = {}));
	var ConcurrencyErrorKey;
	(function (ConcurrencyErrorKey) {
	    ConcurrencyErrorKey["LOCK_TIMEOUT"] = "lock_timeout";
	})(ConcurrencyErrorKey || (ConcurrencyErrorKey = {}));
	class ErrorData {
	    constructor(arg) {
	        if (arg instanceof Error) {
	            this.message = arg.message;
	            this.stack = arg.stack;
	            this.type = ErrorType.INTERNAL;
	        }
	        else if (typeof arg === 'string') {
	            this.message = arg;
	            this.type = ErrorType.INTERNAL;
	        }
	        else if (typeof arg === 'object' && arg !== null) {
	            Object.assign(this, arg);
	        }
	        else {
	            throw new Error('Invalid argument when creating BaseErrorData: ' + JSON.stringify(arg));
	        }
	    }
	}
	class IntegrationAppError extends Error {
	    constructor(arg) {
	        const errorData = new ErrorData(arg);
	        super(errorData.message);
	        this.isIntegrationAppError = true;
	        this.data = errorData;
	        if (!this.data.type) {
	            this.data.type = ErrorType.INTERNAL;
	        }
	        if (typeof window !== 'undefined') {
	            this.message = buildUserFriendlyErrorMessage(this.data);
	        }
	    }
	}
	class InternalError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.INTERNAL;
	    }
	}
	class BadRequestError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.BAD_REQUEST;
	    }
	}
	class ConcurrencyError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.CONCURRENCY;
	    }
	}
	class ConfigurationError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.CONFIGURATION;
	    }
	}
	class DependencyError extends IntegrationAppError {
	    constructor(arg, workspaceElementReference) {
	        super(arg);
	        this.data.type = ErrorType.DEPENDENCY_ERROR;
	        this.data.data = { workspaceElementReference };
	    }
	}
	class FlowInstanceSetupError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.FLOW_INSTANCE_SETUP;
	    }
	}
	class FlowRunError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.FLOW_RUN;
	    }
	}
	class ActionRunError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.ACTION_RUN;
	    }
	}
	class ActionInstanceSetupError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.ACTION_INSTANCE_SETUP;
	    }
	}
	class UnitRunError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.UNIT_RUN;
	    }
	}
	class ConnectionError extends IntegrationAppError {
	    constructor(arg) {
	        super(arg);
	        this.data.type = ErrorType.CONNECTION;
	    }
	}
	const ERROR_CLASS_BY_TYPE = {
	    [ErrorType.BAD_REQUEST]: BadRequestError,
	    [ErrorType.CONNECTION]: ConnectionError,
	    [ErrorType.CONFIGURATION]: ConfigurationError,
	    [ErrorType.DEPENDENCY_ERROR]: DependencyError,
	    [ErrorType.FLOW_RUN]: FlowRunError,
	    [ErrorType.FLOW_INSTANCE_SETUP]: FlowInstanceSetupError,
	    [ErrorType.INTERNAL]: InternalError,
	    [ErrorType.CONCURRENCY]: ConcurrencyError,
	    [ErrorType.ACTION_RUN]: ActionRunError,
	    [ErrorType.ACTION_INSTANCE_SETUP]: ActionInstanceSetupError,
	    [ErrorType.UNIT_RUN]: UnitRunError,
	};
	function getErrorFromData(data) {
	    if (typeof data === 'object' &&
	        data !== null &&
	        Object.values(ErrorType).includes(data.type) &&
	        data.type in ERROR_CLASS_BY_TYPE) {
	        return new ERROR_CLASS_BY_TYPE[data.type](data);
	    }
	    return null;
	}
	function buildUserFriendlyErrorMessage({ message, doc }) {
	    const docsLink = !doc
	        ? ''
	        : `https://console.integration.app/docs/errors/${doc}`;
	    return `${message} ${docsLink}`;
	}

	var DataBuilderFormulaType;
	(function (DataBuilderFormulaType) {
	    DataBuilderFormulaType["VAR"] = "var";
	    DataBuilderFormulaType["COPY"] = "copy";
	    DataBuilderFormulaType["TPL"] = "tpl";
	    DataBuilderFormulaType["RECORD"] = "record";
	    DataBuilderFormulaType["LOOKUP"] = "lookup";
	    DataBuilderFormulaType["PLAIN"] = "plain";
	    DataBuilderFormulaType["MAP"] = "map";
	    DataBuilderFormulaType["CONCAT"] = "concat";
	    DataBuilderFormulaType["FIRST_NAME"] = "firstName";
	    DataBuilderFormulaType["LAST_NAME"] = "lastName";
	    DataBuilderFormulaType["ITERATE"] = "iterate";
	    DataBuilderFormulaType["CASE"] = "case";
	    DataBuilderFormulaType["EXTRACT_DATE"] = "extractDate";
	    DataBuilderFormulaType["EXTRACT_TIME"] = "extractTime";
	    DataBuilderFormulaType["FIND_EXTERNAL_RECORD_ID"] = "findExternalRecordId";
	    DataBuilderFormulaType["FIND_APP_RECORD_ID"] = "findAppRecordId";
	    DataBuilderFormulaType["EVAL"] = "eval";
	    DataBuilderFormulaType["AND"] = "and";
	    DataBuilderFormulaType["OR"] = "or";
	    DataBuilderFormulaType["MERGE_OBJECTS"] = "mergeObjects";
	    DataBuilderFormulaType["FIRST_NOT_EMPTY"] = "firstNotEmpty";
	    DataBuilderFormulaType["DOMAIN_FROM_EMAIL"] = "domainFromEmail";
	    DataBuilderFormulaType["FORMULA"] = "formula";
	    DataBuilderFormulaType["JSONATA"] = "jsonata";
	    DataBuilderFormulaType["DATA_SCHEMA_REF"] = "dataSchemaRef";
	})(DataBuilderFormulaType || (DataBuilderFormulaType = {}));

	var lib = {};

	var jsCamelcase = {};

	var hasRequiredJsCamelcase;

	function requireJsCamelcase () {
		if (hasRequiredJsCamelcase) return jsCamelcase;
		hasRequiredJsCamelcase = 1;
		Object.defineProperty(jsCamelcase, "__esModule", { value: true });
		function toCamelCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/[^A-Za-z0-9]+/g, '$')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + "$" + b; })
		        .toLowerCase()
		        .replace(/(\$)(\w)/g, function (m, a, b) { return b.toUpperCase(); });
		}
		jsCamelcase.default = toCamelCase;
		return jsCamelcase;
	}

	var jsSnakecase = {};

	var hasRequiredJsSnakecase;

	function requireJsSnakecase () {
		if (hasRequiredJsSnakecase) return jsSnakecase;
		hasRequiredJsSnakecase = 1;
		Object.defineProperty(jsSnakecase, "__esModule", { value: true });
		function toSnakeCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + '_' + b.toLowerCase(); })
		        .replace(/[^A-Za-z0-9]+|_+/g, '_')
		        .toLowerCase();
		}
		jsSnakecase.default = toSnakeCase;
		return jsSnakecase;
	}

	var jsPascalcase = {};

	var hasRequiredJsPascalcase;

	function requireJsPascalcase () {
		if (hasRequiredJsPascalcase) return jsPascalcase;
		hasRequiredJsPascalcase = 1;
		Object.defineProperty(jsPascalcase, "__esModule", { value: true });
		function toPascalCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '$')
		        .replace(/[^A-Za-z0-9]+/g, '$')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + "$" + b; })
		        .toLowerCase()
		        .replace(/(\$)(\w?)/g, function (m, a, b) { return b.toUpperCase(); });
		}
		jsPascalcase.default = toPascalCase;
		return jsPascalcase;
	}

	var jsDotcase = {};

	var hasRequiredJsDotcase;

	function requireJsDotcase () {
		if (hasRequiredJsDotcase) return jsDotcase;
		hasRequiredJsDotcase = 1;
		Object.defineProperty(jsDotcase, "__esModule", { value: true });
		function toDotCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + "_" + b.toLowerCase(); })
		        .replace(/[^A-Za-z0-9]+|_+/g, '.')
		        .toLowerCase();
		}
		jsDotcase.default = toDotCase;
		return jsDotcase;
	}

	var jsPathcase = {};

	var hasRequiredJsPathcase;

	function requireJsPathcase () {
		if (hasRequiredJsPathcase) return jsPathcase;
		hasRequiredJsPathcase = 1;
		Object.defineProperty(jsPathcase, "__esModule", { value: true });
		function toPathCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + "_" + b.toLowerCase(); })
		        .replace(/[^A-Za-z0-9]+|_+/g, '/')
		        .toLowerCase();
		}
		jsPathcase.default = toPathCase;
		return jsPathcase;
	}

	var jsTextcase = {};

	var hasRequiredJsTextcase;

	function requireJsTextcase () {
		if (hasRequiredJsTextcase) return jsTextcase;
		hasRequiredJsTextcase = 1;
		Object.defineProperty(jsTextcase, "__esModule", { value: true });
		function toTextCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + '_' + b.toLowerCase(); })
		        .replace(/[^A-Za-z0-9]+|_+/g, ' ')
		        .toLowerCase();
		}
		jsTextcase.default = toTextCase;
		return jsTextcase;
	}

	var jsSentencecase = {};

	var hasRequiredJsSentencecase;

	function requireJsSentencecase () {
		if (hasRequiredJsSentencecase) return jsSentencecase;
		hasRequiredJsSentencecase = 1;
		Object.defineProperty(jsSentencecase, "__esModule", { value: true });
		function toSentenceCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    var textcase = String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + "_" + b.toLowerCase(); })
		        .replace(/[^A-Za-z0-9]+|_+/g, ' ')
		        .toLowerCase();
		    return textcase.charAt(0).toUpperCase() + textcase.slice(1);
		}
		jsSentencecase.default = toSentenceCase;
		return jsSentencecase;
	}

	var jsHeadercase = {};

	var hasRequiredJsHeadercase;

	function requireJsHeadercase () {
		if (hasRequiredJsHeadercase) return jsHeadercase;
		hasRequiredJsHeadercase = 1;
		Object.defineProperty(jsHeadercase, "__esModule", { value: true });
		function toHeaderCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + "_" + b.toLowerCase(); })
		        .replace(/[^A-Za-z0-9]+|_+/g, ' ')
		        .toLowerCase()
		        .replace(/( ?)(\w+)( ?)/g, function (m, a, b, c) { return a + b.charAt(0).toUpperCase() + b.slice(1) + c; });
		}
		jsHeadercase.default = toHeaderCase;
		return jsHeadercase;
	}

	var jsKebabcase = {};

	var hasRequiredJsKebabcase;

	function requireJsKebabcase () {
		if (hasRequiredJsKebabcase) return jsKebabcase;
		hasRequiredJsKebabcase = 1;
		Object.defineProperty(jsKebabcase, "__esModule", { value: true });
		function toKebabCase(str) {
		    if (str === void 0) { str = ''; }
		    if (!str)
		        return '';
		    return String(str)
		        .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, '')
		        .replace(/([a-z])([A-Z])/g, function (m, a, b) { return a + "_" + b.toLowerCase(); })
		        .replace(/[^A-Za-z0-9]+|_+/g, '-')
		        .toLowerCase();
		}
		jsKebabcase.default = toKebabCase;
		return jsKebabcase;
	}

	var lowercaseKeysObject = {};

	var utils$2 = {};

	var hasRequiredUtils;

	function requireUtils () {
		if (hasRequiredUtils) return utils$2;
		hasRequiredUtils = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.belongToTypes = exports.isValidObject = exports.isArrayObject = exports.validateOptions = exports.DefaultOption = void 0;
			/**
			 * Default options for convert function. This option is not recursive.
			 */
			exports.DefaultOption = {
			    recursive: false,
			    recursiveInArray: false,
			    keepTypesOnRecursion: []
			};
			exports.validateOptions = function (opt) {
			    if (opt === void 0) { opt = exports.DefaultOption; }
			    if (opt.recursive == null) {
			        opt = exports.DefaultOption;
			    }
			    else if (opt.recursiveInArray == null) {
			        opt.recursiveInArray = false;
			    }
			    return opt;
			};
			exports.isArrayObject = function (obj) { return obj != null && Array.isArray(obj); };
			exports.isValidObject = function (obj) { return obj != null && typeof obj === 'object' && !Array.isArray(obj); };
			exports.belongToTypes = function (obj, types) { return (types || []).some(function (Type) { return obj instanceof Type; }); }; 
		} (utils$2));
		return utils$2;
	}

	var hasRequiredLowercaseKeysObject;

	function requireLowercaseKeysObject () {
		if (hasRequiredLowercaseKeysObject) return lowercaseKeysObject;
		hasRequiredLowercaseKeysObject = 1;
		var __spreadArrays = (lowercaseKeysObject && lowercaseKeysObject.__spreadArrays) || function () {
		    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
		    for (var r = Array(s), k = 0, i = 0; i < il; i++)
		        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
		            r[k] = a[j];
		    return r;
		};
		Object.defineProperty(lowercaseKeysObject, "__esModule", { value: true });
		var utils_1 = requireUtils();
		/**
		 * Convert string keys in an object to lowercase format.
		 * @param obj: object to convert keys. If `obj` isn't a json object, `null` is returned.
		 * @param opt: (optional) Options parameter, default is non-recursive.
		 */
		function lowerKeys(obj, opt) {
		    if (opt === void 0) { opt = utils_1.DefaultOption; }
		    if (!utils_1.isValidObject(obj))
		        return null;
		    opt = utils_1.validateOptions(opt);
		    var res = {};
		    Object.keys(obj).forEach(function (key) {
		        var value = obj[key];
		        var nkey = key.toLowerCase();
		        if (opt.recursive) {
		            if (utils_1.isValidObject(value)) {
		                if (!utils_1.belongToTypes(value, opt.keepTypesOnRecursion)) {
		                    value = lowerKeys(value, opt);
		                }
		            }
		            else if (opt.recursiveInArray && utils_1.isArrayObject(value)) {
		                value = __spreadArrays(value).map(function (v) {
		                    var ret = v;
		                    if (utils_1.isValidObject(v)) {
		                        // object in array
		                        if (!utils_1.belongToTypes(ret, opt.keepTypesOnRecursion)) {
		                            ret = lowerKeys(v, opt);
		                        }
		                    }
		                    else if (utils_1.isArrayObject(v)) {
		                        // array in array
		                        // workaround by using an object holding array value
		                        var temp = lowerKeys({ key: v }, opt);
		                        ret = temp.key;
		                    }
		                    return ret;
		                });
		            }
		        }
		        res[nkey] = value;
		    });
		    return res;
		}
		lowercaseKeysObject.default = lowerKeys;
		return lowercaseKeysObject;
	}

	var uppercaseKeysObject = {};

	var hasRequiredUppercaseKeysObject;

	function requireUppercaseKeysObject () {
		if (hasRequiredUppercaseKeysObject) return uppercaseKeysObject;
		hasRequiredUppercaseKeysObject = 1;
		var __spreadArrays = (uppercaseKeysObject && uppercaseKeysObject.__spreadArrays) || function () {
		    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
		    for (var r = Array(s), k = 0, i = 0; i < il; i++)
		        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
		            r[k] = a[j];
		    return r;
		};
		Object.defineProperty(uppercaseKeysObject, "__esModule", { value: true });
		var utils_1 = requireUtils();
		/**
		 * Convert string keys in an object to UPPERCASE format.
		 * @param obj: object to convert keys. If `obj` isn't a json object, `null` is returned.
		 * @param opt: (optional) Options parameter, default is non-recursive.
		 */
		function upperKeys(obj, opt) {
		    if (opt === void 0) { opt = utils_1.DefaultOption; }
		    if (!utils_1.isValidObject(obj))
		        return null;
		    opt = utils_1.validateOptions(opt);
		    var res = {};
		    Object.keys(obj).forEach(function (key) {
		        var value = obj[key];
		        var nkey = key.toUpperCase();
		        if (opt.recursive) {
		            if (utils_1.isValidObject(value)) {
		                if (!utils_1.belongToTypes(value, opt.keepTypesOnRecursion)) {
		                    value = upperKeys(value, opt);
		                }
		            }
		            else if (opt.recursiveInArray && utils_1.isArrayObject(value)) {
		                value = __spreadArrays(value).map(function (v) {
		                    var ret = v;
		                    if (utils_1.isValidObject(v)) {
		                        // object in array
		                        if (!utils_1.belongToTypes(ret, opt.keepTypesOnRecursion)) {
		                            ret = upperKeys(v, opt);
		                        }
		                    }
		                    else if (utils_1.isArrayObject(v)) {
		                        // array in array
		                        // workaround by using an object holding array value
		                        var temp = upperKeys({ key: v }, opt);
		                        ret = temp.key;
		                    }
		                    return ret;
		                });
		            }
		        }
		        res[nkey] = value;
		    });
		    return res;
		}
		uppercaseKeysObject.default = upperKeys;
		return uppercaseKeysObject;
	}

	var camelcaseKeysObject = {};

	var hasRequiredCamelcaseKeysObject;

	function requireCamelcaseKeysObject () {
		if (hasRequiredCamelcaseKeysObject) return camelcaseKeysObject;
		hasRequiredCamelcaseKeysObject = 1;
		var __spreadArrays = (camelcaseKeysObject && camelcaseKeysObject.__spreadArrays) || function () {
		    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
		    for (var r = Array(s), k = 0, i = 0; i < il; i++)
		        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
		            r[k] = a[j];
		    return r;
		};
		Object.defineProperty(camelcaseKeysObject, "__esModule", { value: true });
		var utils_1 = requireUtils();
		var js_camelcase_1 = requireJsCamelcase();
		/**
		 * Convert string keys in an object to camelCase format.
		 * @param obj: object to convert keys. If `obj` isn't a json object, `null` is returned.
		 * @param opt: (optional) Options parameter, default is non-recursive.
		 */
		function camelKeys(obj, opt) {
		    if (opt === void 0) { opt = utils_1.DefaultOption; }
		    if (!utils_1.isValidObject(obj))
		        return null;
		    opt = utils_1.validateOptions(opt);
		    var res = {};
		    Object.keys(obj).forEach(function (key) {
		        var value = obj[key];
		        var nkey = js_camelcase_1.default(key);
		        if (opt.recursive) {
		            if (utils_1.isValidObject(value)) {
		                if (!utils_1.belongToTypes(value, opt.keepTypesOnRecursion)) {
		                    value = camelKeys(value, opt);
		                }
		            }
		            else if (opt.recursiveInArray && utils_1.isArrayObject(value)) {
		                value = __spreadArrays(value).map(function (v) {
		                    var ret = v;
		                    if (utils_1.isValidObject(v)) {
		                        // object in array
		                        if (!utils_1.belongToTypes(ret, opt.keepTypesOnRecursion)) {
		                            ret = camelKeys(v, opt);
		                        }
		                    }
		                    else if (utils_1.isArrayObject(v)) {
		                        // array in array
		                        // workaround by using an object holding array value
		                        var temp = camelKeys({ key: v }, opt);
		                        ret = temp.key;
		                    }
		                    return ret;
		                });
		            }
		        }
		        res[nkey] = value;
		    });
		    return res;
		}
		camelcaseKeysObject.default = camelKeys;
		return camelcaseKeysObject;
	}

	var snakecaseKeysObject = {};

	var hasRequiredSnakecaseKeysObject;

	function requireSnakecaseKeysObject () {
		if (hasRequiredSnakecaseKeysObject) return snakecaseKeysObject;
		hasRequiredSnakecaseKeysObject = 1;
		var __spreadArrays = (snakecaseKeysObject && snakecaseKeysObject.__spreadArrays) || function () {
		    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
		    for (var r = Array(s), k = 0, i = 0; i < il; i++)
		        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
		            r[k] = a[j];
		    return r;
		};
		Object.defineProperty(snakecaseKeysObject, "__esModule", { value: true });
		var utils_1 = requireUtils();
		var js_snakecase_1 = requireJsSnakecase();
		/**
		 * Convert string keys in an object to snake_case format.
		 * @param obj: object to convert keys. If `obj` isn't a json object, `null` is returned.
		 * @param opt: (optional) Options parameter, default is non-recursive.
		 */
		function snakeKeys(obj, opt) {
		    if (opt === void 0) { opt = utils_1.DefaultOption; }
		    if (!utils_1.isValidObject(obj))
		        return null;
		    opt = utils_1.validateOptions(opt);
		    var res = {};
		    Object.keys(obj).forEach(function (key) {
		        var value = obj[key];
		        var nkey = js_snakecase_1.default(key);
		        if (opt.recursive) {
		            if (utils_1.isValidObject(value)) {
		                if (!utils_1.belongToTypes(value, opt.keepTypesOnRecursion)) {
		                    value = snakeKeys(value, opt);
		                }
		            }
		            else if (opt.recursiveInArray && utils_1.isArrayObject(value)) {
		                value = __spreadArrays(value).map(function (v) {
		                    var ret = v;
		                    if (utils_1.isValidObject(v)) {
		                        // object in array
		                        if (!utils_1.belongToTypes(ret, opt.keepTypesOnRecursion)) {
		                            ret = snakeKeys(v, opt);
		                        }
		                    }
		                    else if (utils_1.isArrayObject(v)) {
		                        // array in array
		                        // workaround by using an object holding array value
		                        var temp = snakeKeys({ key: v }, opt);
		                        ret = temp.key;
		                    }
		                    return ret;
		                });
		            }
		        }
		        res[nkey] = value;
		    });
		    return res;
		}
		snakecaseKeysObject.default = snakeKeys;
		return snakecaseKeysObject;
	}

	var pascalcaseKeysObject = {};

	var hasRequiredPascalcaseKeysObject;

	function requirePascalcaseKeysObject () {
		if (hasRequiredPascalcaseKeysObject) return pascalcaseKeysObject;
		hasRequiredPascalcaseKeysObject = 1;
		var __spreadArrays = (pascalcaseKeysObject && pascalcaseKeysObject.__spreadArrays) || function () {
		    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
		    for (var r = Array(s), k = 0, i = 0; i < il; i++)
		        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
		            r[k] = a[j];
		    return r;
		};
		Object.defineProperty(pascalcaseKeysObject, "__esModule", { value: true });
		var utils_1 = requireUtils();
		var js_pascalcase_1 = requireJsPascalcase();
		/**
		 * Convert string keys in an object to PascalCase format.
		 * @param obj: object to convert keys. If `obj` isn't a json object, `null` is returned.
		 * @param opt: (optional) Options parameter, default is non-recursive.
		 */
		function pascalKeys(obj, opt) {
		    if (opt === void 0) { opt = utils_1.DefaultOption; }
		    if (!utils_1.isValidObject(obj))
		        return null;
		    opt = utils_1.validateOptions(opt);
		    var res = {};
		    Object.keys(obj).forEach(function (key) {
		        var value = obj[key];
		        var nkey = js_pascalcase_1.default(key);
		        if (opt.recursive) {
		            if (utils_1.isValidObject(value)) {
		                if (!utils_1.belongToTypes(value, opt.keepTypesOnRecursion)) {
		                    value = pascalKeys(value, opt);
		                }
		            }
		            else if (opt.recursiveInArray && utils_1.isArrayObject(value)) {
		                value = __spreadArrays(value).map(function (v) {
		                    var ret = v;
		                    if (utils_1.isValidObject(v)) {
		                        // object in array
		                        if (!utils_1.belongToTypes(ret, opt.keepTypesOnRecursion)) {
		                            ret = pascalKeys(v, opt);
		                        }
		                    }
		                    else if (utils_1.isArrayObject(v)) {
		                        // array in array
		                        // workaround by using an object holding array value
		                        var temp = pascalKeys({ key: v }, opt);
		                        ret = temp.key;
		                    }
		                    return ret;
		                });
		            }
		        }
		        res[nkey] = value;
		    });
		    return res;
		}
		pascalcaseKeysObject.default = pascalKeys;
		return pascalcaseKeysObject;
	}

	var kebabcaseKeysObject = {};

	var hasRequiredKebabcaseKeysObject;

	function requireKebabcaseKeysObject () {
		if (hasRequiredKebabcaseKeysObject) return kebabcaseKeysObject;
		hasRequiredKebabcaseKeysObject = 1;
		var __spreadArrays = (kebabcaseKeysObject && kebabcaseKeysObject.__spreadArrays) || function () {
		    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
		    for (var r = Array(s), k = 0, i = 0; i < il; i++)
		        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
		            r[k] = a[j];
		    return r;
		};
		Object.defineProperty(kebabcaseKeysObject, "__esModule", { value: true });
		var utils_1 = requireUtils();
		var js_kebabcase_1 = requireJsKebabcase();
		/**
		 * Convert string keys in an object to kebab-case format.
		 * @param obj: object to convert keys. If `obj` isn't a json object, `null` is returned.
		 * @param opt: (optional) Options parameter, default is non-recursive.
		 */
		function kebabKeys(obj, opt) {
		    if (opt === void 0) { opt = utils_1.DefaultOption; }
		    if (!utils_1.isValidObject(obj))
		        return null;
		    opt = utils_1.validateOptions(opt);
		    var res = {};
		    Object.keys(obj).forEach(function (key) {
		        var value = obj[key];
		        var nkey = js_kebabcase_1.default(key);
		        if (opt.recursive) {
		            if (utils_1.isValidObject(value)) {
		                if (!utils_1.belongToTypes(value, opt.keepTypesOnRecursion)) {
		                    value = kebabKeys(value, opt);
		                }
		            }
		            else if (opt.recursiveInArray && utils_1.isArrayObject(value)) {
		                value = __spreadArrays(value).map(function (v) {
		                    var ret = v;
		                    if (utils_1.isValidObject(v)) {
		                        // object in array
		                        if (!utils_1.belongToTypes(ret, opt.keepTypesOnRecursion)) {
		                            ret = kebabKeys(v, opt);
		                        }
		                    }
		                    else if (utils_1.isArrayObject(v)) {
		                        // array in array
		                        // workaround by using an object holding array value
		                        var temp = kebabKeys({ key: v }, opt);
		                        ret = temp.key;
		                    }
		                    return ret;
		                });
		            }
		        }
		        res[nkey] = value;
		    });
		    return res;
		}
		kebabcaseKeysObject.default = kebabKeys;
		return kebabcaseKeysObject;
	}

	var hasRequiredLib;

	function requireLib () {
		if (hasRequiredLib) return lib;
		hasRequiredLib = 1;
		/**
		 * Author: <Ha Huynh> https://github.com/huynhsamha
		 * Github: https://github.com/huynhsamha/js-convert-case
		 * NPM Package: https://www.npmjs.com/package/js-convert-case
		 */
		Object.defineProperty(lib, "__esModule", { value: true });
		lib.kebabKeys = lib.pascalKeys = lib.snakeKeys = lib.camelKeys = lib.upperKeys = lib.lowerKeys = lib.toLowerCase = lib.toUpperCase = lib.toKebabCase = lib.toHeaderCase = lib.toSentenceCase = lib.toTextCase = lib.toPathCase = lib.toDotCase = lib.toPascalCase = lib.toSnakeCase = lib.toCamelCase = void 0;
		var js_camelcase_1 = requireJsCamelcase();
		lib.toCamelCase = js_camelcase_1.default;
		var js_snakecase_1 = requireJsSnakecase();
		lib.toSnakeCase = js_snakecase_1.default;
		var js_pascalcase_1 = requireJsPascalcase();
		lib.toPascalCase = js_pascalcase_1.default;
		var js_dotcase_1 = requireJsDotcase();
		lib.toDotCase = js_dotcase_1.default;
		var js_pathcase_1 = requireJsPathcase();
		lib.toPathCase = js_pathcase_1.default;
		var js_textcase_1 = requireJsTextcase();
		lib.toTextCase = js_textcase_1.default;
		var js_sentencecase_1 = requireJsSentencecase();
		lib.toSentenceCase = js_sentencecase_1.default;
		var js_headercase_1 = requireJsHeadercase();
		lib.toHeaderCase = js_headercase_1.default;
		var js_kebabcase_1 = requireJsKebabcase();
		lib.toKebabCase = js_kebabcase_1.default;
		var lowercase_keys_object_1 = requireLowercaseKeysObject();
		lib.lowerKeys = lowercase_keys_object_1.default;
		var uppercase_keys_object_1 = requireUppercaseKeysObject();
		lib.upperKeys = uppercase_keys_object_1.default;
		var camelcase_keys_object_1 = requireCamelcaseKeysObject();
		lib.camelKeys = camelcase_keys_object_1.default;
		var snakecase_keys_object_1 = requireSnakecaseKeysObject();
		lib.snakeKeys = snakecase_keys_object_1.default;
		var pascalcase_keys_object_1 = requirePascalcaseKeysObject();
		lib.pascalKeys = pascalcase_keys_object_1.default;
		var kebabcase_keys_object_1 = requireKebabcaseKeysObject();
		lib.kebabKeys = kebabcase_keys_object_1.default;
		var toLowerCase = function (str) { return String(str || '').toLowerCase(); };
		lib.toLowerCase = toLowerCase;
		var toUpperCase = function (str) { return String(str || '').toUpperCase(); };
		lib.toUpperCase = toUpperCase;
		var jsConvert = {
		    toCamelCase: js_camelcase_1.default,
		    toSnakeCase: js_snakecase_1.default,
		    toPascalCase: js_pascalcase_1.default,
		    toDotCase: js_dotcase_1.default,
		    toPathCase: js_pathcase_1.default,
		    toTextCase: js_textcase_1.default,
		    toSentenceCase: js_sentencecase_1.default,
		    toHeaderCase: js_headercase_1.default,
		    toKebabCase: js_kebabcase_1.default,
		    toUpperCase: toUpperCase,
		    toLowerCase: toLowerCase,
		    lowerKeys: lowercase_keys_object_1.default,
		    upperKeys: uppercase_keys_object_1.default,
		    camelKeys: camelcase_keys_object_1.default,
		    snakeKeys: snakecase_keys_object_1.default,
		    pascalKeys: pascalcase_keys_object_1.default,
		    kebabKeys: kebabcase_keys_object_1.default
		};
		lib.default = jsConvert;
		return lib;
	}

	var jsConvertCase;
	var hasRequiredJsConvertCase;

	function requireJsConvertCase () {
		if (hasRequiredJsConvertCase) return jsConvertCase;
		hasRequiredJsConvertCase = 1;
		jsConvertCase = requireLib();
		return jsConvertCase;
	}

	requireJsConvertCase();

	function isNil(value) {
	    return value == null;
	}
	function omitBy(obj, check) {
	    obj = { ...obj };
	    Object.entries(obj).forEach(([key, value]) => check(value) && delete obj[key]);
	    return obj;
	}
	function isEmptyValue(value) {
	    if (isNil(value)) {
	        return true;
	    }
	    if (typeof value === 'symbol') {
	        return true;
	    }
	    if (typeof value === 'boolean') {
	        return false;
	    }
	    if (typeof value === 'number') {
	        return isNaN(value);
	    }
	    if (typeof value === 'string') {
	        return value.trim().length === 0;
	    }
	    const tag = value.toString();
	    if (tag === '[object Map]' || tag === '[object Set]') {
	        return !value.size;
	    }
	    return typeof value === 'object' && Object.keys(value).length === 0;
	}

	var DataLocatorStepType;
	(function (DataLocatorStepType) {
	    DataLocatorStepType["OBJECT_PROPERTY"] = "object_property";
	    DataLocatorStepType["ARRAY_ITEM"] = "array_item";
	})(DataLocatorStepType || (DataLocatorStepType = {}));

	var ConnectorMethodImplementationType;
	(function (ConnectorMethodImplementationType) {
	    ConnectorMethodImplementationType["mapping"] = "mapping";
	    ConnectorMethodImplementationType["operationMapping"] = "operation-mapping";
	    ConnectorMethodImplementationType["restApiMapping"] = "rest-api-mapping";
	    ConnectorMethodImplementationType["graphqlApiMapping"] = "graphql-api-mapping";
	    ConnectorMethodImplementationType["javascript"] = "javascript";
	    ConnectorMethodImplementationType["notSupported"] = "not-supported";
	})(ConnectorMethodImplementationType || (ConnectorMethodImplementationType = {}));
	({
	    [ConnectorMethodImplementationType.restApiMapping]: ['.rest.yml', '.api.yml'],
	    [ConnectorMethodImplementationType.graphqlApiMapping]: ['.graphql.yml'],
	    [ConnectorMethodImplementationType.operationMapping]: ['.op.yml'],
	    [ConnectorMethodImplementationType.javascript]: ['.js', '.ts'],
	    [ConnectorMethodImplementationType.mapping]: ['.map.yml', '.yml'],
	});

	({
	    getOAuthConfig: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.mapping,
	            ConnectorMethodImplementationType.javascript,
	        ]},
	    getTokenData: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.mapping,
	            ConnectorMethodImplementationType.javascript,
	        ]},
	    getCredentialsFromAccessTokenResponse: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.javascript,
	        ]},
	    getCredentialsFromRefreshTokenResponse: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.javascript,
	        ]},
	    getCredentialsFromConnectionParameters: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.mapping,
	            ConnectorMethodImplementationType.javascript,
	        ]},
	    refreshCredentials: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.javascript,
	        ]},
	    makeApiClient: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.mapping,
	            ConnectorMethodImplementationType.javascript,
	        ]},
	    test: {
	        supportedImplementationTypes: [
	            ConnectorMethodImplementationType.operationMapping,
	            ConnectorMethodImplementationType.restApiMapping,
	            ConnectorMethodImplementationType.javascript,
	        ]},
	});
	({
	    items: {
	        properties: {
	            error: {
	                properties: {
	                    key: {
	                        enum: [
	                            ConnectionErrorKey.ACCESS_TOKEN_EXPIRED,
	                            ConnectionErrorKey.CONNECTION_IS_DEFUNCT,
	                            ConnectionErrorKey.RATE_LIMIT_EXCEEDED,
	                        ],
	                    }},
	            },
	        },
	    },
	});

	const udm$G = {
	    };

	const udm$F = {
	    };

	const udm$E = {
	    };

	const udm$D = {
	    };

	const udm$C = {
	    };

	const udm$B = {
	    };

	const udm$A = {
	    };

	const udm$z = {
	    };

	const udm$y = {
	    };

	const udm$x = {
	    };

	const udm$w = {
	    };

	const udm$v = {
	    };

	const udm$u = {
	    };

	const udm$t = {
	    };

	const udm$s = {
	    };

	const udm$r = {
	    };

	const udm$q = {
	    };

	const udm$p = {
	    };

	const udm$o = {
	    };

	const udm$n = {
	    };

	const udm$m = {
	    };

	const udm$l = {
	    };

	const udm$k = {
	    };

	const udm$j = {
	    };

	const udm$i = {
	    };

	const udm$h = {
	    };

	const udm$g = {
	    };

	const udm$f = {
	    };

	const udm$e = {
	    };

	const udm$d = {
	    };

	const udm$c = {
	    };

	const udm$b = {
	    };

	const udm$a = {
	    };

	const udm$9 = {
	    };

	const udm$8 = {
	    };

	const udm$7 = {
	    };

	const udm$6 = {
	    };

	const udm$5 = {
	    };

	const udm$4 = {
	    };

	const udm$3 = {
	    };

	const udm$2 = {
	    };

	const udm$1 = {
	    };

	const udm = {
	    };

	var UDM;
	(function (UDM) {
	    UDM["ACTIVITIES"] = "activities";
	    UDM["BILLS"] = "bills";
	    UDM["CAMPAIGN_MEMBERS"] = "campaign-members";
	    UDM["CAMPAIGNS"] = "campaigns";
	    UDM["COMPANIES"] = "companies";
	    UDM["CONTACTS"] = "contacts";
	    UDM["CONTACT_LISTS"] = "contact-lists";
	    UDM["CREDIT_NOTES"] = "credit-notes";
	    UDM["CUSTOMERS"] = "customers";
	    UDM["DEAL_PRODUCTS"] = "deal-products";
	    UDM["DEALS"] = "deals";
	    UDM["DEAL_STAGES"] = "deal-stages";
	    UDM["DOCUMENTS"] = "documents";
	    UDM["DRIVES"] = "drives";
	    UDM["DRIVE_ITEMS"] = "drive-items";
	    UDM["EEOCS"] = "eeocs";
	    UDM["EMAILS"] = "emails";
	    UDM["EMPLOYEES"] = "employees";
	    UDM["FILES"] = "files";
	    UDM["FOLDERS"] = "folders";
	    UDM["INVOICES"] = "invoices";
	    UDM["JOB_APPLICATIONS"] = "job-applications";
	    UDM["JOB_CANDIDATES"] = "job-candidates";
	    UDM["JOB_INTERVIEWS"] = "job-interviews";
	    UDM["JOB_OFFERS"] = "job-offers";
	    UDM["JOBS"] = "jobs";
	    UDM["JOURNAL_ENTRIES"] = "journal-entries";
	    UDM["LEADS"] = "leads";
	    UDM["LEDGER_ACCOUNTS"] = "ledger-accounts";
	    UDM["MEETINGS"] = "meetings";
	    UDM["MESSAGES"] = "messages";
	    UDM["NOTES"] = "notes";
	    UDM["ORDERS"] = "orders";
	    UDM["PAYMENTS"] = "payments";
	    UDM["PAYROLLS"] = "payrolls";
	    UDM["PRODUCTS"] = "products";
	    UDM["PROJECTS"] = "projects";
	    UDM["SUPPLIERS"] = "suppliers";
	    UDM["TASKS"] = "tasks";
	    UDM["TAX_RATES"] = "tax-rates";
	    UDM["USERS"] = "users";
	    UDM["TIMEOFF_BALANCES"] = "timeoff-balances";
	    UDM["TIMEOFF_REQUESTS"] = "timeoff-requests";
	})(UDM || (UDM = {}));
	({
	    [UDM.ACTIVITIES]: udm$G,
	    [UDM.BILLS]: udm$F,
	    [UDM.CAMPAIGN_MEMBERS]: udm$E,
	    [UDM.CAMPAIGNS]: udm$D,
	    [UDM.COMPANIES]: udm$C,
	    [UDM.CONTACTS]: udm$A,
	    [UDM.CONTACT_LISTS]: udm$B,
	    [UDM.CREDIT_NOTES]: udm$z,
	    [UDM.CUSTOMERS]: udm$y,
	    [UDM.DEAL_PRODUCTS]: udm$x,
	    [UDM.DEALS]: udm$v,
	    [UDM.DEAL_STAGES]: udm$w,
	    [UDM.DOCUMENTS]: udm$u,
	    [UDM.DRIVES]: udm$s,
	    [UDM.DRIVE_ITEMS]: udm$t,
	    [UDM.EEOCS]: udm$r,
	    [UDM.EMAILS]: udm$q,
	    [UDM.EMPLOYEES]: udm$p,
	    [UDM.FILES]: udm$o,
	    [UDM.FOLDERS]: udm$n,
	    [UDM.INVOICES]: udm$m,
	    [UDM.JOB_APPLICATIONS]: udm$l,
	    [UDM.JOB_CANDIDATES]: udm$k,
	    [UDM.JOB_INTERVIEWS]: udm$j,
	    [UDM.JOB_OFFERS]: udm$i,
	    [UDM.JOBS]: udm$h,
	    [UDM.JOURNAL_ENTRIES]: udm$g,
	    [UDM.LEADS]: udm$f,
	    [UDM.LEDGER_ACCOUNTS]: udm$e,
	    [UDM.MEETINGS]: udm$d,
	    [UDM.MESSAGES]: udm$c,
	    [UDM.NOTES]: udm$b,
	    [UDM.ORDERS]: udm$a,
	    [UDM.PAYMENTS]: udm$9,
	    [UDM.PAYROLLS]: udm$8,
	    [UDM.PRODUCTS]: udm$7,
	    [UDM.PROJECTS]: udm$6,
	    [UDM.SUPPLIERS]: udm$5,
	    [UDM.TASKS]: udm$4,
	    [UDM.TAX_RATES]: udm$3,
	    [UDM.USERS]: udm,
	    [UDM.TIMEOFF_BALANCES]: udm$2,
	    [UDM.TIMEOFF_REQUESTS]: udm$1,
	});

	const DataLocationMethodImplementationTypes = [
	    ConnectorMethodImplementationType.operationMapping,
	    ConnectorMethodImplementationType.restApiMapping,
	    ConnectorMethodImplementationType.graphqlApiMapping,
	    ConnectorMethodImplementationType.javascript,
	    ConnectorMethodImplementationType.notSupported,
	];

	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.mapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.mapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});

	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.javascript,
	    ],
	});

	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.restApiMapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});

	var DataCollectionEventType;
	(function (DataCollectionEventType) {
	    DataCollectionEventType["CREATED"] = "created";
	    DataCollectionEventType["UPDATED"] = "updated";
	    DataCollectionEventType["DELETED"] = "deleted";
	})(DataCollectionEventType || (DataCollectionEventType = {}));

	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.restApiMapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.restApiMapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.mapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.restApiMapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});

	({
	    supportedImplementationTypes: [ConnectorMethodImplementationType.javascript],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.mapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.mapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [ConnectorMethodImplementationType.mapping],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.javascript,
	    ],
	});
	({
	    supportedImplementationTypes: [ConnectorMethodImplementationType.mapping],
	});
	({
	    supportedImplementationTypes: [ConnectorMethodImplementationType.javascript],
	});
	({
	    supportedImplementationTypes: [ConnectorMethodImplementationType.javascript],
	});
	({
	    supportedImplementationTypes: [ConnectorMethodImplementationType.javascript],
	});
	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.mapping,
	        ConnectorMethodImplementationType.javascript,
	    ],
	});

	({
	    supportedImplementationTypes: [
	        ConnectorMethodImplementationType.mapping,
	        ...DataLocationMethodImplementationTypes,
	    ],
	});

	({
	    supportedImplementationTypes: [ConnectorMethodImplementationType.javascript],
	});

	var DataLocationType;
	(function (DataLocationType) {
	    DataLocationType["directory"] = "directory";
	    DataLocationType["collection"] = "collection";
	})(DataLocationType || (DataLocationType = {}));
	var DataDirectoryOperation;
	(function (DataDirectoryOperation) {
	    DataDirectoryOperation["list"] = "list";
	})(DataDirectoryOperation || (DataDirectoryOperation = {}));

	var urlJoin$1 = {exports: {}};

	var urlJoin = urlJoin$1.exports;

	var hasRequiredUrlJoin;

	function requireUrlJoin () {
		if (hasRequiredUrlJoin) return urlJoin$1.exports;
		hasRequiredUrlJoin = 1;
		(function (module) {
			(function (name, context, definition) {
			  if (module.exports) module.exports = definition();
			  else context[name] = definition();
			})('urljoin', urlJoin, function () {

			  function normalize (strArray) {
			    var resultArray = [];
			    if (strArray.length === 0) { return ''; }

			    if (typeof strArray[0] !== 'string') {
			      throw new TypeError('Url must be a string. Received ' + strArray[0]);
			    }

			    // If the first part is a plain protocol, we combine it with the next part.
			    if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
			      var first = strArray.shift();
			      strArray[0] = first + strArray[0];
			    }

			    // There must be two or three slashes in the file protocol, two slashes in anything else.
			    if (strArray[0].match(/^file:\/\/\//)) {
			      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
			    } else {
			      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
			    }

			    for (var i = 0; i < strArray.length; i++) {
			      var component = strArray[i];

			      if (typeof component !== 'string') {
			        throw new TypeError('Url must be a string. Received ' + component);
			      }

			      if (component === '') { continue; }

			      if (i > 0) {
			        // Removing the starting slashes for each component but the first.
			        component = component.replace(/^[\/]+/, '');
			      }
			      if (i < strArray.length - 1) {
			        // Removing the ending slashes for each component but the last.
			        component = component.replace(/[\/]+$/, '');
			      } else {
			        // For the last component we will combine multiple slashes to a single one.
			        component = component.replace(/[\/]+$/, '/');
			      }

			      resultArray.push(component);

			    }

			    var str = resultArray.join('/');
			    // Each input component is now separated by a single slash except the possible first plain protocol part.

			    // remove trailing slash before parameters or hash
			    str = str.replace(/\/(\?|&|#[^!])/g, '$1');

			    // replace ? in parameters with &
			    var parts = str.split('?');
			    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

			    return str;
			  }

			  return function () {
			    var input;

			    if (typeof arguments[0] === 'object') {
			      input = arguments[0];
			    } else {
			      input = [].slice.call(arguments);
			    }

			    return normalize(input);
			  };

			}); 
		} (urlJoin$1));
		return urlJoin$1.exports;
	}

	var urlJoinExports = requireUrlJoin();
	var urljoin = /*@__PURE__*/getDefaultExportFromCjs(urlJoinExports);

	[
	    ConnectorMethodImplementationType.restApiMapping,
	    ConnectorMethodImplementationType.javascript,
	];

	var ConnectorStatus;
	(function (ConnectorStatus) {
	    ConnectorStatus["production"] = "production";
	    ConnectorStatus["beta"] = "beta";
	    ConnectorStatus["planned"] = "planned";
	})(ConnectorStatus || (ConnectorStatus = {}));

	var ConnectorEventImplementationType;
	(function (ConnectorEventImplementationType) {
	    ConnectorEventImplementationType["GlobalWebhook"] = "global-webhook";
	    ConnectorEventImplementationType["Webhook"] = "webhook";
	})(ConnectorEventImplementationType || (ConnectorEventImplementationType = {}));
	({
	    [ConnectorEventImplementationType.GlobalWebhook]: {
	        getEventSelector: {
	            supportedImplementationTypes: [
	                ConnectorMethodImplementationType.mapping,
	                ConnectorMethodImplementationType.javascript,
	            ]},
	    },
	    [ConnectorEventImplementationType.Webhook]: {
	        subscribe: {
	            supportedImplementationTypes: [
	                ConnectorMethodImplementationType.restApiMapping,
	                ConnectorMethodImplementationType.javascript,
	            ]},
	        unsubscribe: {
	            supportedImplementationTypes: [
	                ConnectorMethodImplementationType.restApiMapping,
	                ConnectorMethodImplementationType.javascript,
	            ]},
	        handle: {
	            supportedImplementationTypes: [
	                ConnectorMethodImplementationType.mapping,
	                ConnectorMethodImplementationType.javascript,
	            ]},
	        refresh: {
	            supportedImplementationTypes: [
	                ConnectorMethodImplementationType.restApiMapping,
	                ConnectorMethodImplementationType.javascript,
	            ]},
	    },
	});

	var humanparser = {exports: {}};

	var hasRequiredHumanparser;

	function requireHumanparser () {
		if (hasRequiredHumanparser) return humanparser.exports;
		hasRequiredHumanparser = 1;
		const parser = humanparser.exports = {};

		function diff(a1, a2) {
			return a1.concat(a2).filter((val, index, arr) => {
				return arr.indexOf(val) === arr.lastIndexOf(val);
			});
		}

		const lc = value => value.toLowerCase();

		parser.parseName = function (name, opts = {}) {
			let extraCompound = [];
			let extraSalutations = [];
			let extraSuffixes = [];
			let ignoreCompound = [];
			let ignoreSalutation = [];
			let ignoreSuffix = [];

			if (Array.isArray(opts)) {
				ignoreSuffix = opts.map(v => v.toLowerCase());
			} else {
				({
					extraCompound = [],
					extraSalutations = [], 
					extraSuffixes = [], 
					ignoreCompound = [],
					ignoreSalutation = [],
					ignoreSuffix = []
				} = opts);

				extraCompound = extraCompound.map(lc);
				extraSalutations = extraSalutations.map(lc);
				extraSuffixes = extraSuffixes.map(lc);
				ignoreCompound = ignoreCompound.map(lc);
				ignoreSalutation = ignoreSalutation.map(lc);
				ignoreSuffix = ignoreSuffix.map(lc);
			}
			const salutations = ['mr', 'master', 'mister', 'mrs', 'miss', 'ms', 'dr', 'prof', 'rev', 'fr', 'judge', 'honorable', 'hon', 'tuan', 'sr', 'srta', 'br', 'pr', 'mx', 'sra', ...extraSalutations].filter(salutation => !ignoreSalutation.includes(salutation));
			const suffixes = ['i', 'ii', 'iii', 'iv', 'v', 'senior', 'junior', 'jr', 'sr', 'phd', 'apr', 'rph', 'pe', 'md', 'ma', 'dmd', 'cme', 'qc', 'kc', ...extraSuffixes].filter(suffix => !ignoreSuffix.includes(suffix));
			const compound = ['vere', 'von', 'van', 'de', 'del', 'della', 'der', 'den', 'di', 'da', 'pietro', 'vanden', 'du', 'st.', 'st', 'la', 'lo', 'ter', 'bin', 'ibn', 'te', 'ten', 'op', 'ben', 'al', ...extraCompound].filter(compound => !ignoreCompound.includes(compound));

			let parts = name
				.trim()
				.replace(/\b\s+(,\s+)\b/, '$1') // fix name , suffix -> name, suffix
				.replace(/\b,\b/, ', ');         // fix name,suffix -> name, suffix
			// look for quoted compound names
			parts = (parts.match(/[^\s"]+|"[^"]+"/g) || parts.split(/\s+/)).map(n => n.match(/^".*"$/) ? n.slice(1, -1) : n);
			const attrs = {};

			if (!parts.length) {
				return attrs;
			}

			if (parts.length === 1) {
				attrs.firstName = parts[0];
			}

			//handle suffix first always, remove trailing comma if there is one
			if (parts.length > 1 && suffixes.indexOf(parts[parts.length - 1].toLowerCase().replace(/\./g, '')) > -1) {
				attrs.suffix = parts.pop();
				parts[parts.length - 1] = parts[parts.length - 1].replace(',', '');
			}

			//look for a comma to know we have last name first format
			const firstNameFirstFormat = parts.every(part => {
				return part.indexOf(',') === -1;
			});

			if (!firstNameFirstFormat) {
				//last name first format
				//assuming salutations are never used in this format

				//tracker variable for where first name begins in parts array
				let firstNameIndex;

				//location of first comma will separate last name from rest
				//join all parts leading to first comma as last name
				const lastName = parts.reduce((lastName, current, index) => {
					if (!Array.isArray(lastName)) {
						return lastName;
					}
					if (current.indexOf(',') === -1) {
						lastName.push(current);
						return lastName;
					} else {
						current = current.replace(',', '');

						// handle case where suffix is included in part of last name (ie: 'Hearst Jr., Willian Randolph')
						if (suffixes.indexOf(current.toLowerCase().replace(/\./g, '')) > -1) {
							attrs.suffix = current;
						} else {
							lastName.push(current);
						}

						firstNameIndex = index + 1;
						return lastName.join(' ');
					}
				}, []);

				attrs.lastName = lastName;

				var remainingParts = parts.slice(firstNameIndex);
				if (remainingParts.length > 1) {
					attrs.firstName = remainingParts.shift();
					attrs.middleName = remainingParts.join(' ');
				} else if (remainingParts.length) {
					attrs.firstName = remainingParts[0];
				}

				//create full name from attrs object
				const nameWords = [];
				if (attrs.firstName) {
					nameWords.push(attrs.firstName);
				}
				if (attrs.middleName) {
					nameWords.push(attrs.middleName);
				}
				nameWords.push(attrs.lastName);
				if (attrs.suffix) {
					nameWords.push(attrs.suffix);
				}
				attrs.fullName = nameWords.join(' ');


			} else {
				//first name first format


				if (parts.length > 1 && salutations.indexOf(parts[0].toLowerCase().replace(/\./g, '')) > -1) {
					attrs.salutation = parts.shift();

					// if we have a salutation assume 2nd part is last name
					if (parts.length === 1) {
						attrs.lastName = parts.shift();
					} else {
						attrs.firstName = parts.shift();
					}
				} else {
					attrs.firstName = parts.shift();
				}

				if (!attrs.lastName) {
					attrs.lastName = parts.length ? parts.pop() : '';
				}

				// test for compound last name, we reverse because middle name is last bit to be defined.
				// We already know lastname, so check next word if its part of a compound last name.
				const revParts = parts.slice(0).reverse();
				const compoundParts = [];

				revParts.every(part => {
					const test = part.toLowerCase().replace(/\./g, '');

					if (compound.indexOf(test) > -1) {
						compoundParts.push(part);

						return true;
					}

					//break on first non compound word
					return false;
				});

				//join compound parts with known last name
				if (compoundParts.length) {
					attrs.lastName = compoundParts.reverse().join(' ') + ' ' + attrs.lastName;

					parts = diff(parts, compoundParts);
				}

				if (parts.length) {
					attrs.middleName = parts.join(' ');
				}

				//remove comma like "<lastName>, Jr."
				if (attrs.lastName) {
					attrs.lastName = attrs.lastName.replace(',', '');
				}

				//save a copy of original
				attrs.fullName = name;

			}
			//console.log('attrs:', JSON.stringify(attrs));

			for (const [k, v] of Object.entries(attrs)) {
				attrs[k] = v.trim();
			}
			return attrs;
		};

		parser.getFullestName = (str) => {
			let name = str;
			let names = [];

			//find fullname from strings like 'Jon and Sue Doyle'
			if (name.indexOf('&') > -1 || name.toLowerCase().indexOf(' and ') > -1) {
				names = name.split(/\s+(?:and|&)\s+/gi);

				//pluck the name with the most parts (first, middle, last) from the array.
				//will grab 'Sue Doyle' in 'Jon & Sue Anne Doyle'
				if (names.length) {
					name = names.sort(function (a, b) {
						return b.split(/\s+/).length - a.split(/\s+/).length;
					})[0];
				}
			}

			return name;
		};

		parser.parseAddress = (str) => {
			str = str.replace(/\n/gi, ', ');
			//416 W. Manchester Blvd., Inglewood, CA  90301
			const parts = str.split(/,\s+/).reverse();
			let stateZip;
			let city;
			const address = {};

			stateZip = parts[0].split(/\s+/);
			parts.shift();

			city = parts.shift();

			address.address = parts.reverse().join(', ');
			address.city = city;
			address.state = stateZip[0];
			address.zip = stateZip[1];
			address.fullAddress = str;

			return address;
		};
		return humanparser.exports;
	}

	requireHumanparser();

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var jsonata = {exports: {}};

	var hasRequiredJsonata;

	function requireJsonata () {
		if (hasRequiredJsonata) return jsonata.exports;
		hasRequiredJsonata = 1;
		(function (module, exports) {
			(function(f){{module.exports=f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!f&&c)return c(i,true);if(u)return u(i,true);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u="function"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
			/**
			 * © Copyright IBM Corp. 2018 All Rights Reserved
			 *   Project name: JSONata
			 *   This project is licensed under the MIT License, see LICENSE
			 */

			const utils = require('./utils');

			/**
			 * DateTime formatting and parsing functions
			 * Implements the xpath-functions format-date-time specification
			 * @type {{formatInteger, formatDateTime, parseInteger, parseDateTime}}
			 */
			const dateTime = (function () {

			    const stringToArray = utils.stringToArray;

			    const few = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten',
			        'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'];
			    const ordinals = ['Zeroth', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth',
			        'Eleventh', 'Twelfth', 'Thirteenth', 'Fourteenth', 'Fifteenth', 'Sixteenth', 'Seventeenth', 'Eighteenth', 'Nineteenth'];
			    const decades = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety', 'Hundred'];
			    const magnitudes = ['Thousand', 'Million', 'Billion', 'Trillion'];

			    /**
			     * converts a number into english words
			     * @param {string} value - the value to format
			     * @param {boolean} ordinal - ordinal or cardinal form
			     * @returns {string} - representation in words
			     */
			    function numberToWords(value, ordinal) {
			        var lookup = function (num, prev, ord) {
			            var words = '';
			            if (num <= 19) {
			                words = (prev ? ' and ' : '') + (ord ? ordinals[num] : few[num]);
			            } else if (num < 100) {
			                const tens = Math.floor(num / 10);
			                const remainder = num % 10;
			                words = (prev ? ' and ' : '') + decades[tens - 2];
			                if (remainder > 0) {
			                    words += '-' + lookup(remainder, false, ord);
			                } else if (ord) {
			                    words = words.substring(0, words.length - 1) + 'ieth';
			                }
			            } else if (num < 1000) {
			                const hundreds = Math.floor(num / 100);
			                const remainder = num % 100;
			                words = (prev ? ', ' : '') + few[hundreds] + ' Hundred';
			                if (remainder > 0) {
			                    words += lookup(remainder, true, ord);
			                } else if (ord) {
			                    words += 'th';
			                }
			            } else {
			                var mag = Math.floor(Math.log10(num) / 3);
			                if (mag > magnitudes.length) {
			                    mag = magnitudes.length; // the largest word
			                }
			                const factor = Math.pow(10, mag * 3);
			                const mant = Math.floor(num / factor);
			                const remainder = num - mant * factor;
			                words = (prev ? ', ' : '') + lookup(mant, false, false) + ' ' + magnitudes[mag - 1];
			                if (remainder > 0) {
			                    words += lookup(remainder, true, ord);
			                } else if (ord) {
			                    words += 'th';
			                }
			            }
			            return words;
			        };

			        var words = lookup(value, false, ordinal);
			        return words;
			    }

			    const wordValues = {};
			    few.forEach(function (word, index) {
			        wordValues[word.toLowerCase()] = index;
			    });
			    ordinals.forEach(function (word, index) {
			        wordValues[word.toLowerCase()] = index;
			    });
			    decades.forEach(function (word, index) {
			        const lword = word.toLowerCase();
			        wordValues[lword] = (index + 2) * 10;
			        wordValues[lword.substring(0, word.length - 1) + 'ieth'] = wordValues[lword];
			    });
			    wordValues.hundredth = 100;
			    magnitudes.forEach(function (word, index) {
			        const lword = word.toLowerCase();
			        const val = Math.pow(10, (index + 1) * 3);
			        wordValues[lword] = val;
			        wordValues[lword + 'th'] = val;
			    });

			    /**
			     * Converts a number in english words to numeric value
			     * @param {string} text - the number in words
			     * @returns {number} - the numeric value
			     */
			    function wordsToNumber(text) {
			        const parts = text.split(/,\s|\sand\s|[\s\\-]/);
			        const values = parts.map(part => wordValues[part]);
			        let segs = [0];
			        values.forEach(value => {
			            if (value < 100) {
			                let top = segs.pop();
			                if (top >= 1000) {
			                    segs.push(top);
			                    top = 0;
			                }
			                segs.push(top + value);
			            } else {
			                segs.push(segs.pop() * value);
			            }
			        });
			        const result = segs.reduce((a, b) => a + b, 0);
			        return result;
			    }

			    const romanNumerals = [
			        [1000, 'm'],
			        [900, 'cm'],
			        [500, 'd'],
			        [400, 'cd'],
			        [100, 'c'],
			        [90, 'xc'],
			        [50, 'l'],
			        [40, 'xl'],
			        [10, 'x'],
			        [9, 'ix'],
			        [5, 'v'],
			        [4, 'iv'],
			        [1, 'i']
			    ];

			    const romanValues = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1};

			    /**
			     * converts a number to roman numerals
			     * @param {number} value - the number
			     * @returns {string} - the number in roman numerals
			     */
			    function decimalToRoman(value) {
			        for (var index = 0; index < romanNumerals.length; index++) {
			            const numeral = romanNumerals[index];
			            if (value >= numeral[0]) {
			                return numeral[1] + decimalToRoman(value - numeral[0]);
			            }
			        }
			        return '';
			    }

			    /**
			     * converts roman numerals to a number
			     * @param {string} roman - roman number
			     * @returns {number} - the numeric value
			     */
			    function romanToDecimal(roman) {
			        var decimal = 0;
			        var max = 1;
			        for (var i = roman.length - 1; i >= 0; i--) {
			            const digit = roman[i];
			            const value = romanValues[digit];
			            if (value < max) {
			                decimal -= value;
			            } else {
			                max = value;
			                decimal += value;
			            }
			        }
			        return decimal;
			    }

			    /**
			     * converts a number to spreadsheet style letters
			     * @param {number} value - the number
			     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'
			     * @returns {string} - the letters
			     */
			    function decimalToLetters(value, aChar) {
			        var letters = [];
			        var aCode = aChar.charCodeAt(0);
			        while (value > 0) {
			            letters.unshift(String.fromCharCode((value - 1) % 26 + aCode));
			            value = Math.floor((value - 1) / 26);
			        }
			        return letters.join('');
			    }

			    /**
			     * converts spreadsheet style letters to a number
			     * @param {string} letters - the letters
			     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'
			     * @returns {number} - the numeric value
			     */
			    function lettersToDecimal(letters, aChar) {
			        var aCode = aChar.charCodeAt(0);
			        var decimal = 0;
			        for (var i = 0; i < letters.length; i++) {
			            decimal += (letters.charCodeAt(letters.length - i - 1) - aCode + 1) * Math.pow(26, i);
			        }
			        return decimal;
			    }

			    /**
			     * Formats an integer as specified by the XPath fn:format-integer function
			     * See https://www.w3.org/TR/xpath-functions-31/#func-format-integer
			     * @param {number} value - the number to be formatted
			     * @param {string} picture - the picture string that specifies the format
			     * @returns {string} - the formatted number
			     */
			    function formatInteger(value, picture) {
			        if (typeof value === 'undefined') {
			            return undefined;
			        }

			        value = Math.floor(value);

			        const format = analyseIntegerPicture(picture);
			        return _formatInteger(value, format);
			    }

			    const formats = {
			        DECIMAL: 'decimal',
			        LETTERS: 'letters',
			        ROMAN: 'roman',
			        WORDS: 'words',
			        SEQUENCE: 'sequence'
			    };

			    const tcase = {
			        UPPER: 'upper',
			        LOWER: 'lower',
			        TITLE: 'title'
			    };

			    /**
			     * formats an integer using a preprocessed representation of the picture string
			     * @param {number} value - the number to be formatted
			     * @param {object} format - the preprocessed representation of the pucture string
			     * @returns {string} - the formatted number
			     * @private
			     */
			    function _formatInteger(value, format) {
			        let formattedInteger;
			        const negative = value < 0;
			        value = Math.abs(value);
			        switch (format.primary) {
			            case formats.LETTERS:
			                formattedInteger = decimalToLetters(value, format.case === tcase.UPPER ? 'A' : 'a');
			                break;
			            case formats.ROMAN:
			                formattedInteger = decimalToRoman(value);
			                if (format.case === tcase.UPPER) {
			                    formattedInteger = formattedInteger.toUpperCase();
			                }
			                break;
			            case formats.WORDS:
			                formattedInteger = numberToWords(value, format.ordinal);
			                if (format.case === tcase.UPPER) {
			                    formattedInteger = formattedInteger.toUpperCase();
			                } else if (format.case === tcase.LOWER) {
			                    formattedInteger = formattedInteger.toLowerCase();
			                }
			                break;
			            case formats.DECIMAL:
			                formattedInteger = '' + value;
			                // TODO use functionPad
			                var padLength = format.mandatoryDigits - formattedInteger.length;
			                if (padLength > 0) {
			                    var padding = (new Array(padLength + 1)).join('0');
			                    formattedInteger = padding + formattedInteger;
			                }
			                if (format.zeroCode !== 0x30) {
			                    formattedInteger = stringToArray(formattedInteger).map(code => {
			                        return String.fromCodePoint(code.codePointAt(0) + format.zeroCode - 0x30);
			                    }).join('');
			                }
			                // insert the grouping-separator-signs, if any
			                if (format.regular) {
			                    const n = Math.floor((formattedInteger.length - 1) / format.groupingSeparators.position);
			                    for (let ii = n; ii > 0; ii--) {
			                        const pos = formattedInteger.length - ii * format.groupingSeparators.position;
			                        formattedInteger = formattedInteger.substr(0, pos) + format.groupingSeparators.character + formattedInteger.substr(pos);
			                    }
			                } else {
			                    format.groupingSeparators.reverse().forEach(separator => {
			                        const pos = formattedInteger.length - separator.position;
			                        formattedInteger = formattedInteger.substr(0, pos) + separator.character + formattedInteger.substr(pos);
			                    });
			                }

			                if (format.ordinal) {
			                    var suffix123 = {'1': 'st', '2': 'nd', '3': 'rd'};
			                    var lastDigit = formattedInteger[formattedInteger.length - 1];
			                    var suffix = suffix123[lastDigit];
			                    if (!suffix || (formattedInteger.length > 1 && formattedInteger[formattedInteger.length - 2] === '1')) {
			                        suffix = 'th';
			                    }
			                    formattedInteger = formattedInteger + suffix;
			                }
			                break;
			            case formats.SEQUENCE:
			                throw {
			                    code: 'D3130',
			                    value: format.token
			                };
			        }
			        if (negative) {
			            formattedInteger = '-' + formattedInteger;
			        }

			        return formattedInteger;
			    }

			    //TODO what about decimal groups in the unicode supplementary planes (surrogate pairs) ???
			    const decimalGroups = [0x30, 0x0660, 0x06F0, 0x07C0, 0x0966, 0x09E6, 0x0A66, 0x0AE6, 0x0B66, 0x0BE6, 0x0C66, 0x0CE6, 0x0D66, 0x0DE6, 0x0E50, 0x0ED0, 0x0F20, 0x1040, 0x1090, 0x17E0, 0x1810, 0x1946, 0x19D0, 0x1A80, 0x1A90, 0x1B50, 0x1BB0, 0x1C40, 0x1C50, 0xA620, 0xA8D0, 0xA900, 0xA9D0, 0xA9F0, 0xAA50, 0xABF0, 0xFF10];

			    /**
			     * preprocesses the picture string
			     * @param {string} picture - picture string
			     * @returns {{type: string, primary: string, case: string, ordinal: boolean}} - analysed picture
			     */
			    function analyseIntegerPicture(picture) {
			        const format = {
			            type: 'integer',
			            primary: formats.DECIMAL,
			            case: tcase.LOWER,
			            ordinal: false
			        };

			        let primaryFormat, formatModifier;
			        const semicolon = picture.lastIndexOf(';');
			        if (semicolon === -1) {
			            primaryFormat = picture;
			        } else {
			            primaryFormat = picture.substring(0, semicolon);
			            formatModifier = picture.substring(semicolon + 1);
			            if (formatModifier[0] === 'o') {
			                format.ordinal = true;
			            }
			        }

			        /* eslnt-disable-next no-fallthrough */
			        switch (primaryFormat) {
			            case 'A':
			                format.case = tcase.UPPER;
			            /* eslnt-disable-next-line no-fallthrough */
			            case 'a':
			                format.primary = formats.LETTERS;
			                break;
			            case 'I':
			                format.case = tcase.UPPER;
			            /* eslnt-disable-next-line no-fallthrough */
			            case 'i':
			                format.primary = formats.ROMAN;
			                break;
			            case 'W':
			                format.case = tcase.UPPER;
			                format.primary = formats.WORDS;
			                break;
			            case 'Ww':
			                format.case = tcase.TITLE;
			                format.primary = formats.WORDS;
			                break;
			            case 'w':
			                format.primary = formats.WORDS;
			                break;
			            default: {
			                // this is a decimal-digit-pattern if it contains a decimal digit (from any unicode decimal digit group)
			                let zeroCode = null;
			                let mandatoryDigits = 0;
			                let optionalDigits = 0;
			                let groupingSeparators = [];
			                let separatorPosition = 0;
			                const formatCodepoints = stringToArray(primaryFormat).map(c => c.codePointAt(0)).reverse(); // reverse the array to determine positions of grouping-separator-signs
			                formatCodepoints.forEach((codePoint) => {
			                    // step though each char in the picture to determine the digit group
			                    let digit = false;
			                    for (let ii = 0; ii < decimalGroups.length; ii++) {
			                        const group = decimalGroups[ii];
			                        if (codePoint >= group && codePoint <= group + 9) {
			                            // codepoint is part of this decimal group
			                            digit = true;
			                            mandatoryDigits++;
			                            separatorPosition++;
			                            if (zeroCode === null) {
			                                zeroCode = group;
			                            } else if (group !== zeroCode) {
			                                // error! different decimal groups in the same pattern
			                                throw {
			                                    code: 'D3131'
			                                };
			                            }
			                            break;
			                        }
			                    }
			                    if (!digit) {
			                        if (codePoint === 0x23) { // # - optional-digit-sign
			                            separatorPosition++;
			                            optionalDigits++;
			                        } else {
			                            // neither a decimal-digit-sign ot optional-digit-sign, assume it is a grouping-separator-sign
			                            groupingSeparators.push({
			                                position: separatorPosition,
			                                character: String.fromCodePoint(codePoint)
			                            });
			                        }
			                    }
			                });
			                if (mandatoryDigits > 0) {
			                    format.primary = formats.DECIMAL;
			                    // TODO validate decimal-digit-pattern

			                    // the decimal digit family (codepoint offset)
			                    format.zeroCode = zeroCode;
			                    // the number of mandatory digits
			                    format.mandatoryDigits = mandatoryDigits;
			                    // the number of optional digits
			                    format.optionalDigits = optionalDigits;
			                    // grouping separator template
			                    // are the grouping-separator-signs 'regular'?
			                    const regularRepeat = function (separators) {
			                        // are the grouping positions regular? i.e. same interval between each of them
			                        // is there at least one separator?
			                        if (separators.length === 0) {
			                            return 0;
			                        }
			                        // are all the characters the same?
			                        const sepChar = separators[0].character;
			                        for (let ii = 1; ii < separators.length; ii++) {
			                            if (separators[ii].character !== sepChar) {
			                                return 0;
			                            }
			                        }
			                        // are they equally spaced?
			                        const indexes = separators.map(separator => separator.position);
			                        const gcd = function (a, b) {
			                            return b === 0 ? a : gcd(b, a % b);
			                        };
			                        // find the greatest common divisor of all the positions
			                        const factor = indexes.reduce(gcd);
			                        // is every position separated by this divisor? If so, it's regular
			                        for (let index = 1; index <= indexes.length; index++) {
			                            if (indexes.indexOf(index * factor) === -1) {
			                                return 0;
			                            }
			                        }
			                        return factor;
			                    };

			                    const regular = regularRepeat(groupingSeparators);
			                    if (regular > 0) {
			                        format.regular = true;
			                        format.groupingSeparators = {
			                            position: regular,
			                            character: groupingSeparators[0].character
			                        };
			                    } else {
			                        format.regular = false;
			                        format.groupingSeparators = groupingSeparators;
			                    }

			                } else {
			                    // this is a 'numbering sequence' which the spec says is implementation-defined
			                    // this implementation doesn't support any numbering sequences at the moment.
			                    format.primary = formats.SEQUENCE;
			                    format.token = primaryFormat;
			                }
			            }
			        }

			        return format;
			    }

			    const defaultPresentationModifiers = {
			        Y: '1', M: '1', D: '1', d: '1', F: 'n', W: '1', w: '1', X: '1', x: '1', H: '1', h: '1',
			        P: 'n', m: '01', s: '01', f: '1', Z: '01:01', z: '01:01', C: 'n', E: 'n'
			    };

			    // §9.8.4.1 the format specifier is an array of string literals and variable markers
			    /**
			     * analyse the date-time picture string
			     * @param {string} picture - picture string
			     * @returns {{type: string, parts: Array}} - the analysed string
			     */
			    function analyseDateTimePicture(picture) {
			        var spec = [];
			        const format = {
			            type: 'datetime',
			            parts: spec
			        };
			        const addLiteral = function (start, end) {
			            if (end > start) {
			                let literal = picture.substring(start, end);
			                // replace any doubled ]] with single ]
			                // what if there are instances of single ']' ? - the spec doesn't say
			                literal = literal.split(']]').join(']');
			                spec.push({type: 'literal', value: literal});
			            }
			        };

			        var start = 0, pos = 0;
			        while (pos < picture.length) {
			            if (picture.charAt(pos) === '[') {
			                // check it's not a doubled [[
			                if (picture.charAt(pos + 1) === '[') {
			                    // literal [
			                    addLiteral(start, pos);
			                    spec.push({type: 'literal', value: '['});
			                    pos += 2;
			                    start = pos;
			                    continue;
			                }
			                // start of variable marker
			                // push the string literal (if there is one) onto the array
			                addLiteral(start, pos);
			                start = pos;
			                // search forward to closing ]
			                pos = picture.indexOf(']', start);
			                // TODO handle error case if pos === -1
			                if(pos === -1) {
			                    // error - no closing bracket
			                    throw {
			                        code: 'D3135'
			                    };
			                }
			                let marker = picture.substring(start + 1, pos);
			                // whitespace within a variable marker is ignored (i.e. remove it)
			                marker = marker.split(/\s+/).join('');
			                var def = {
			                    type: 'marker',
			                    component: marker.charAt(0)  // 1. The component specifier is always present and is always a single letter.
			                };
			                var comma = marker.lastIndexOf(','); // 2. The width modifier may be recognized by the presence of a comma
			                var presMod; // the presentation modifiers
			                if (comma !== -1) {
			                    // §9.8.4.2 The Width Modifier
			                    const widthMod = marker.substring(comma + 1);
			                    const dash = widthMod.indexOf('-');
			                    let min, max;
			                    const parseWidth = function (wm) {
			                        if (typeof wm === 'undefined' || wm === '*') {
			                            return undefined;
			                        } else {
			                            // TODO validate wm is an unsigned int
			                            return parseInt(wm);
			                        }
			                    };
			                    if (dash === -1) {
			                        min = widthMod;
			                    } else {
			                        min = widthMod.substring(0, dash);
			                        max = widthMod.substring(dash + 1);
			                    }
			                    const widthDef = {
			                        min: parseWidth(min),
			                        max: parseWidth(max)
			                    };
			                    def.width = widthDef;
			                    presMod = marker.substring(1, comma);
			                } else {
			                    presMod = marker.substring(1);
			                }
			                if (presMod.length === 1) {
			                    def.presentation1 = presMod; // first presentation modifier
			                    //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture
			                } else if (presMod.length > 1) {
			                    var lastChar = presMod.charAt(presMod.length - 1);
			                    if ('atco'.indexOf(lastChar) !== -1) {
			                        def.presentation2 = lastChar;
			                        if (lastChar === 'o') {
			                            def.ordinal = true;
			                        }
			                        // 'c' means 'cardinal' and is the default (i.e. not 'ordinal')
			                        // 'a' & 't' are ignored (not sure of their relevance to English numbering)
			                        def.presentation1 = presMod.substring(0, presMod.length - 1);
			                    } else {
			                        def.presentation1 = presMod;
			                        //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture,
			                        // doesn't use ] as grouping separator, and if grouping separator is , then must have width modifier
			                    }
			                } else {
			                    // no presentation modifier specified - apply the default;
			                    def.presentation1 = defaultPresentationModifiers[def.component];
			                }
			                if (typeof def.presentation1 === 'undefined') {
			                    // unknown component specifier
			                    throw {
			                        code: 'D3132',
			                        value: def.component
			                    };
			                }
			                if (def.presentation1[0] === 'n') {
			                    def.names = tcase.LOWER;
			                } else if (def.presentation1[0] === 'N') {
			                    if (def.presentation1[1] === 'n') {
			                        def.names = tcase.TITLE;
			                    } else {
			                        def.names = tcase.UPPER;
			                    }
			                } else if ('YMDdFWwXxHhmsf'.indexOf(def.component) !== -1) {
			                    var integerPattern = def.presentation1;
			                    if (def.presentation2) {
			                        integerPattern += ';' + def.presentation2;
			                    }
			                    def.integerFormat = analyseIntegerPicture(integerPattern);
			                    if (def.width && def.width.min !== undefined) {
			                        if (def.integerFormat.mandatoryDigits < def.width.min) {
			                            def.integerFormat.mandatoryDigits = def.width.min;
			                        }
			                    }
			                    if ('YMD'.indexOf(def.component) !== -1) {
			                        // §9.8.4.4
			                        def.n = -1;
			                        if (def.width && def.width.max !== undefined) {
			                            def.n = def.width.max;
			                            def.integerFormat.mandatoryDigits = def.n;
			                        } else {
			                            var w = def.integerFormat.mandatoryDigits + def.integerFormat.optionalDigits;
			                            if (w >= 2) {
			                                def.n = w;
			                            }
			                        }
			                    }
			                }
			                if (def.component === 'Z' || def.component === 'z') {
			                    def.integerFormat = analyseIntegerPicture(def.presentation1);
			                }
			                spec.push(def);
			                start = pos + 1;
			            }
			            pos++;
			        }
			        addLiteral(start, pos);
			        return format;
			    }

			    const days = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
			    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
			    const millisInADay = 1000 * 60 * 60 * 24;

			    const startOfFirstWeek = function (ym) {
			        // ISO 8601 defines the first week of the year to be the week that contains the first Thursday
			        // XPath F&O extends this same definition for the first week of a month
			        // the week starts on a Monday - calculate the millis for the start of the first week
			        // millis for given 1st Jan of that year (at 00:00 UTC)
			        const jan1 = Date.UTC(ym.year, ym.month);
			        var dayOfJan1 = (new Date(jan1)).getUTCDay();
			        if (dayOfJan1 === 0) {
			            dayOfJan1 = 7;
			        }
			        // if Jan 1 is Fri, Sat or Sun, then add the number of days (in millis) to jan1 to get the start of week 1
			        return dayOfJan1 > 4 ? jan1 + (8 - dayOfJan1) * millisInADay : jan1 - (dayOfJan1 - 1) * millisInADay;
			    };

			    const yearMonth = function (year, month) {
			        return {
			            year: year,
			            month: month,
			            nextMonth: function () {
			                return (month === 11) ? yearMonth(year + 1, 0) : yearMonth(year, month + 1);
			            },
			            previousMonth: function () {
			                return (month === 0) ? yearMonth(year - 1, 11) : yearMonth(year, month - 1);
			            },
			            nextYear: function () {
			                return yearMonth(year + 1, month);
			            },
			            previousYear: function () {
			                return yearMonth(year - 1, month);
			            }
			        };
			    };

			    const deltaWeeks = function (start, end) {
			        return (end - start) / (millisInADay * 7) + 1;
			    };

			    const getDateTimeFragment = (date, component) => {
			        let componentValue;
			        switch (component) {
			            case 'Y': // year
			                componentValue = date.getUTCFullYear();
			                break;
			            case 'M': // month in year
			                componentValue = date.getUTCMonth() + 1;
			                break;
			            case 'D': // day in month
			                componentValue = date.getUTCDate();
			                break;
			            case 'd': { // day in year
			                // millis for given date (at 00:00 UTC)
			                const today = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
			                // millis for given 1st Jan of that year (at 00:00 UTC)
			                const firstJan = Date.UTC(date.getUTCFullYear(), 0);
			                componentValue = (today - firstJan) / millisInADay + 1;
			                break;
			            }
			            case 'F': // day of week
			                componentValue = date.getUTCDay();
			                if (componentValue === 0) {
			                    // ISO 8601 defines days 1-7: Mon-Sun
			                    componentValue = 7;
			                }
			                break;
			            case 'W': { // week in year
			                const thisYear = yearMonth(date.getUTCFullYear(), 0);
			                const startOfWeek1 = startOfFirstWeek(thisYear);
			                const today = Date.UTC(thisYear.year, date.getUTCMonth(), date.getUTCDate());
			                let week = deltaWeeks(startOfWeek1, today);
			                if (week > 52) {
			                    // might be first week of the following year
			                    const startOfFollowingYear = startOfFirstWeek(thisYear.nextYear());
			                    if (today >= startOfFollowingYear) {
			                        week = 1;
			                    }
			                } else if (week < 1) {
			                    // must be end of the previous year
			                    const startOfPreviousYear = startOfFirstWeek(thisYear.previousYear());
			                    week = deltaWeeks(startOfPreviousYear, today);
			                }
			                componentValue = Math.floor(week);
			                break;
			            }
			            case 'w': { // week in month
			                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());
			                const startOfWeek1 = startOfFirstWeek(thisMonth);
			                const today = Date.UTC(thisMonth.year, thisMonth.month, date.getUTCDate());
			                let week = deltaWeeks(startOfWeek1, today);
			                if (week > 4) {
			                    // might be first week of the following month
			                    const startOfFollowingMonth = startOfFirstWeek(thisMonth.nextMonth());
			                    if (today >= startOfFollowingMonth) {
			                        week = 1;
			                    }
			                } else if (week < 1) {
			                    // must be end of the previous month
			                    const startOfPreviousMonth = startOfFirstWeek(thisMonth.previousMonth());
			                    week = deltaWeeks(startOfPreviousMonth, today);
			                }
			                componentValue = Math.floor(week);
			                break;
			            }
			            case 'X': { // ISO week-numbering year
			                // Extension: The F&O spec says nothing about how to access the year associated with the week-of-the-year
			                // e.g. Sat 1 Jan 2005 is in the 53rd week of 2004.
			                // The 'W' component specifier gives 53, but 'Y' will give 2005.
			                // I propose to add 'X' as the component specifier to give the ISO week-numbering year (2004 in this example)
			                const thisYear = yearMonth(date.getUTCFullYear(), 0);
			                const startOfISOYear = startOfFirstWeek(thisYear);
			                const endOfISOYear = startOfFirstWeek(thisYear.nextYear());
			                const now = date.getTime();
			                if (now < startOfISOYear) {
			                    componentValue = thisYear.year - 1;
			                } else if (now >= endOfISOYear) {
			                    componentValue = thisYear.year + 1;
			                } else {
			                    componentValue = thisYear.year;
			                }
			                break;
			            }
			            case 'x': { // ISO week-numbering month
			                // Extension: The F&O spec says nothing about how to access the month associated with the week-of-the-month
			                // e.g. Sat 1 Jan 2005 is in the 5th week of December 2004.
			                // The 'w' component specifier gives 5, but 'W' will give January and 'Y' will give 2005.
			                // I propose to add 'x' as the component specifier to give the 'week-numbering' month (December in this example)
			                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());
			                const startOfISOMonth = startOfFirstWeek(thisMonth);
			                const nextMonth = thisMonth.nextMonth();
			                const endOfISOMonth = startOfFirstWeek(nextMonth);
			                const now = date.getTime();
			                if (now < startOfISOMonth) {
			                    componentValue = thisMonth.previousMonth().month + 1;
			                } else if (now >= endOfISOMonth) {
			                    componentValue = nextMonth.month + 1;
			                } else {
			                    componentValue = thisMonth.month + 1;
			                }
			                break;
			            }
			            case 'H': // hour in day (24 hours)
			                componentValue = date.getUTCHours();
			                break;
			            case 'h': // hour in half-day (12 hours)
			                componentValue = date.getUTCHours();
			                componentValue = componentValue % 12;
			                if (componentValue === 0) {
			                    componentValue = 12;
			                }
			                break;
			            case 'P': // am/pm marker
			                componentValue = date.getUTCHours() >= 12 ? 'pm' : 'am';
			                break;
			            case 'm': // minute in hour
			                componentValue = date.getUTCMinutes();
			                break;
			            case 's': // second in minute
			                componentValue = date.getUTCSeconds();
			                break;
			            case 'f': // fractional seconds
			                componentValue = date.getUTCMilliseconds();
			                break;
			            case 'Z': // timezone
			            case 'z':
			                // since the date object is constructed from epoch millis, the TZ component is always be UTC.
			                break;
			            case 'C': // calendar name
			                componentValue = 'ISO';
			                break;
			            case 'E': // era
			                componentValue = 'ISO';
			                break;
			        }
			        return componentValue;
			    };

			    let iso8601Spec = null;

			    /**
			     * formats the date/time as specified by the XPath fn:format-dateTime function
			     * @param {number} millis - the timestamp to be formatted, in millis since the epoch
			     * @param {string} picture - the picture string that specifies the format
			     * @param {string} timezone - the timezone to use
			     * @returns {string} - the formatted timestamp
			     */
			    function formatDateTime(millis, picture, timezone) {
			        var offsetHours = 0;
			        var offsetMinutes = 0;

			        if (typeof timezone !== 'undefined') {
			            // parse the hour and minute offsets
			            // assume for now the format supplied is +hhmm
			            const offset = parseInt(timezone);
			            offsetHours = Math.floor(offset / 100);
			            offsetMinutes = offset % 100;
			        }

			        var formatComponent = function (date, markerSpec) {
			            var componentValue = getDateTimeFragment(date, markerSpec.component);

			            // §9.8.4.3 Formatting Integer-Valued Date/Time Components
			            if ('YMDdFWwXxHhms'.indexOf(markerSpec.component) !== -1) {
			                if (markerSpec.component === 'Y') {
			                    // §9.8.4.4 Formatting the Year Component
			                    if (markerSpec.n !== -1) {
			                        componentValue = componentValue % Math.pow(10, markerSpec.n);
			                    }
			                }
			                if (markerSpec.names) {
			                    if (markerSpec.component === 'M' || markerSpec.component === 'x') {
			                        componentValue = months[componentValue - 1];
			                    } else if (markerSpec.component === 'F') {
			                        componentValue = days[componentValue];
			                    } else {
			                        throw {
			                            code: 'D3133',
			                            value: markerSpec.component
			                        };
			                    }
			                    if (markerSpec.names === tcase.UPPER) {
			                        componentValue = componentValue.toUpperCase();
			                    } else if (markerSpec.names === tcase.LOWER) {
			                        componentValue = componentValue.toLowerCase();
			                    }
			                    if (markerSpec.width && componentValue.length > markerSpec.width.max) {
			                        componentValue = componentValue.substring(0, markerSpec.width.max);
			                    }
			                } else {
			                    componentValue = _formatInteger(componentValue, markerSpec.integerFormat);
			                }
			            } else if (markerSpec.component === 'f') {
			                // TODO §9.8.4.5 Formatting Fractional Seconds
			                componentValue = _formatInteger(componentValue, markerSpec.integerFormat);
			            } else if (markerSpec.component === 'Z' || markerSpec.component === 'z') {
			                // §9.8.4.6 Formatting timezones
			                const offset = offsetHours * 100 + offsetMinutes;
			                if (markerSpec.integerFormat.regular) {
			                    componentValue = _formatInteger(offset, markerSpec.integerFormat);
			                } else {
			                    const numDigits = markerSpec.integerFormat.mandatoryDigits;
			                    if (numDigits === 1 || numDigits === 2) {
			                        componentValue = _formatInteger(offsetHours, markerSpec.integerFormat);
			                        if (offsetMinutes !== 0) {
			                            componentValue += ':' + formatInteger(offsetMinutes, '00');
			                        }
			                    } else if (numDigits === 3 || numDigits === 4) {
			                        componentValue = _formatInteger(offset, markerSpec.integerFormat);
			                    } else {
			                        throw {
			                            code: 'D3134',
			                            value: numDigits
			                        };
			                    }
			                }
			                if (offset >= 0) {
			                    componentValue = '+' + componentValue;
			                }
			                if (markerSpec.component === 'z') {
			                    componentValue = 'GMT' + componentValue;
			                }
			                if (offset === 0 && markerSpec.presentation2 === 't') {
			                    componentValue = 'Z';
			                }
			            }
			            return componentValue;
			        };

			        let formatSpec;
			        if(typeof picture === 'undefined') {
			            // default to ISO 8601 format
			            if (iso8601Spec === null) {
			                iso8601Spec = analyseDateTimePicture('[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]');
			            }
			            formatSpec = iso8601Spec;
			        } else {
			            formatSpec = analyseDateTimePicture(picture);
			        }

			        const offsetMillis = (60 * offsetHours + offsetMinutes) * 60 * 1000;
			        const dateTime = new Date(millis + offsetMillis);

			        let result = '';
			        formatSpec.parts.forEach(function (part) {
			            if (part.type === 'literal') {
			                result += part.value;
			            } else {
			                result += formatComponent(dateTime, part);
			            }
			        });

			        return result;
			    }

			    /**
			     * Generate a regex to parse integers or timestamps
			     * @param {object} formatSpec - object representing the format
			     * @returns {object} - regex
			     */
			    function generateRegex(formatSpec) {
			        var matcher = {};
			        if (formatSpec.type === 'datetime') {
			            matcher.type = 'datetime';
			            matcher.parts = formatSpec.parts.map(function (part) {
			                var res = {};
			                if (part.type === 'literal') {
			                    res.regex = part.value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			                } else if (part.component === 'Z' || part.component === 'z') {
			                    // timezone
			                    let separator;
			                    if (!Array.isArray(part.integerFormat.groupingSeparators)) {
			                        separator = part.integerFormat.groupingSeparators;
			                    }
			                    res.regex = '';
			                    if (part.component === 'z') {
			                        res.regex = 'GMT';
			                    }
			                    res.regex += '[-+][0-9]+';
			                    if (separator) {
			                        res.regex += separator.character + '[0-9]+';
			                    }
			                    res.parse = function(value) {
			                        if (part.component === 'z') {
			                            value = value.substring(3); // remove the leading GMT
			                        }
			                        let offsetHours = 0, offsetMinutes = 0;
			                        if (separator) {
			                            offsetHours = Number.parseInt(value.substring(0, value.indexOf(separator.character)));
			                            offsetMinutes = Number.parseInt(value.substring(value.indexOf(separator.character) + 1));
			                        } else {
			                            // depends on number of digits
			                            const numdigits = value.length - 1;
			                            if (numdigits <= 2) {
			                                // just hour offset
			                                offsetHours = Number.parseInt(value);
			                            } else {
			                                offsetHours = Number.parseInt(value.substring(0, 3));
			                                offsetMinutes = Number.parseInt(value.substring(3));
			                            }
			                        }
			                        return offsetHours * 60 + offsetMinutes;
			                    };
			                } else if (part.integerFormat) {
			                    part.integerFormat.n = part.n;
			                    res = generateRegex(part.integerFormat);
			                } else {
			                    // must be a month or day name
			                    res.regex = '[a-zA-Z]+';
			                    var lookup = {};
			                    if (part.component === 'M' || part.component === 'x') {
			                        // months
			                        months.forEach(function (name, index) {
			                            if (part.width && part.width.max) {
			                                lookup[name.substring(0, part.width.max)] = index + 1;
			                            } else {
			                                lookup[name] = index + 1;
			                            }
			                        });
			                    } else if (part.component === 'F') {
			                        // days
			                        days.forEach(function (name, index) {
			                            if (index > 0) {
			                                if (part.width && part.width.max) {
			                                    lookup[name.substring(0, part.width.max)] = index;
			                                } else {
			                                    lookup[name] = index;
			                                }
			                            }
			                        });
			                    } else if (part.component === 'P') {
			                        lookup = {'am': 0, 'AM': 0, 'pm': 1, 'PM': 1};
			                    } else {
			                        // unsupported 'name' option for this component
			                        throw {
			                            code: 'D3133',
			                            value: part.component
			                        };
			                    }
			                    res.parse = function (value) {
			                        return lookup[value];
			                    };
			                }
			                res.component = part.component;
			                return res;
			            });
			        } else { // type === 'integer'
			            matcher.type = 'integer';
			            const isUpper = formatSpec.case === tcase.UPPER;
			            let occurrences;
			            if(formatSpec.n && formatSpec.n > 0){
			                if(formatSpec.optionalDigits === 0){
			                    occurrences = `{${formatSpec.n}}`;
			                } else {
			                    occurrences = `{${formatSpec.n - formatSpec.optionalDigits},${formatSpec.n}}`;
			                }
			            } else {
			                occurrences = '+';
			            }

			            switch (formatSpec.primary) {
			                case formats.LETTERS:
			                    matcher.regex = isUpper ? '[A-Z]+' : '[a-z]+';
			                    matcher.parse = function (value) {
			                        return lettersToDecimal(value, isUpper ? 'A' : 'a');
			                    };
			                    break;
			                case formats.ROMAN:
			                    matcher.regex = isUpper ? '[MDCLXVI]+' : '[mdclxvi]+';
			                    matcher.parse = function (value) {
			                        return romanToDecimal(isUpper ? value : value.toUpperCase());
			                    };
			                    break;
			                case formats.WORDS:
			                    matcher.regex = '(?:' + Object.keys(wordValues).concat('and', '[\\-, ]').join('|') + ')+';
			                    matcher.parse = function (value) {
			                        return wordsToNumber(value.toLowerCase());
			                    };
			                    break;
			                case formats.DECIMAL:
			                    matcher.regex = `[0-9]${occurrences}`;
			                    if (formatSpec.ordinal) {
			                        // ordinals
			                        matcher.regex += '(?:th|st|nd|rd)';
			                    }
			                    matcher.parse = function (value) {
			                        let digits = value;
			                        if (formatSpec.ordinal) {
			                            // strip off the suffix
			                            digits = value.substring(0, value.length - 2);
			                        }
			                        // strip out the separators
			                        if (formatSpec.regular) {
			                            digits = digits.split(',').join('');
			                        } else {
			                            formatSpec.groupingSeparators.forEach(sep => {
			                                digits = digits.split(sep.character).join('');
			                            });
			                        }
			                        if (formatSpec.zeroCode !== 0x30) {
			                            // apply offset
			                            digits = digits.split('').map(char => String.fromCodePoint(char.codePointAt(0) - formatSpec.zeroCode + 0x30)).join('');
			                        }
			                        return parseInt(digits);
			                    };
			                    break;
			                case formats.SEQUENCE:
			                    throw {
			                        code: 'D3130',
			                        value: formatSpec.token
			                    };
			            }

			        }
			        return matcher;
			    }

			    /**
			     * parse a string containing an integer as specified by the picture string
			     * @param {string} value - the string to parse
			     * @param {string} picture - the picture string
			     * @returns {number} - the parsed number
			     */
			    function parseInteger(value, picture) {
			        if (typeof value === 'undefined') {
			            return undefined;
			        }

			        const formatSpec = analyseIntegerPicture(picture);
			        const matchSpec = generateRegex(formatSpec);
			        //const fullRegex = '^' + matchSpec.regex + '$';
			        //const matcher = new RegExp(fullRegex);
			        // TODO validate input based on the matcher regex
			        const result = matchSpec.parse(value);
			        return result;
			    }

			    /**
			     * parse a string containing a timestamp as specified by the picture string
			     * @param {string} timestamp - the string to parse
			     * @param {string} picture - the picture string
			     * @returns {number} - the parsed timestamp in millis since the epoch
			     */
			    function parseDateTime(timestamp, picture) {
			        const formatSpec = analyseDateTimePicture(picture);
			        const matchSpec = generateRegex(formatSpec);
			        const fullRegex = '^' + matchSpec.parts.map(part => '(' + part.regex + ')').join('') + '$';

			        const matcher = new RegExp(fullRegex, 'i'); // TODO can cache this against the picture
			        var info = matcher.exec(timestamp);
			        if (info !== null) {
			            // validate what we've just parsed - do we have enough information to create a timestamp?
			            // rules:
			            // The date is specified by one of:
			            //    {Y, M, D}    (dateA)
			            // or {Y, d}       (dateB)
			            // or {Y, x, w, F} (dateC)
			            // or {X, W, F}    (dateD)
			            // The time is specified by one of:
			            //    {H, m, s, f}    (timeA)
			            // or {P, h, m, s, f} (timeB)
			            // All sets can have an optional Z
			            // To create a timestamp (epoch millis) we need both date and time, but we can default missing
			            // information according to the following rules:
			            // - line up one combination of the above from date, and one from time, most significant value (MSV) to least significant (LSV
			            // - for the values that have been captured, if there are any gaps between MSV and LSV, then throw an error
			            //     (e.g.) if hour and seconds, but not minutes is given - throw
			            //     (e.g.) if month, hour and minutes, but not day-of-month is given - throw
			            // - anything right of the LSV should be defaulted to zero
			            //     (e.g.) if hour and minutes given, default seconds and fractional seconds to zero
			            //     (e.g.) if date only given, default the time to 0:00:00.000 (midnight)
			            // - anything left of the MSV should be defaulted to the value of that component returned by $now()
			            //     (e.g.) if time only given, default the date to today
			            //     (e.g.) if month and date given, default to this year (and midnight, by previous rule)
			            //   -- default values for X, x, W, w, F will be derived from the values returned by $now()

			            // implement the above rules
			            // determine which of the above date/time combinations we have by using bit masks

			            //        Y X M x W w d D F P H h m s f Z
			            // dateA  1 0 1 0 0 0 0 1 ?                     0 - must not appear
			            // dateB  1 0 0 0 0 0 1 0 ?                     1 - can appear - relevant
			            // dateC  0 1 0 1 0 1 0 0 1                     ? - can appear - ignored
			            // dateD  0 1 0 0 1 0 0 0 1
			            // timeA                    0 1 0 1 1 1
			            // timeB                    1 0 1 1 1 1

			            // create bitmasks based on the above
			            //    date mask             YXMxWwdD
			            const dmA = 161;  // binary 10100001
			            const dmB = 130;  // binary 10000010
			            const dmC = 84;   // binary 01010100
			            const dmD = 72;   // binary 01001000
			            //    time mask             PHhmsf
			            const tmA = 23;   // binary 010111
			            const tmB = 47;   // binary 101111

			            const components = {};
			            for (let i = 1; i < info.length; i++) {
			                const mpart = matchSpec.parts[i - 1];
			                if (mpart.parse) {
			                    components[mpart.component] = mpart.parse(info[i]);
			                }
			            }

			            if(Object.getOwnPropertyNames(components).length === 0) {
			                // nothing specified
			                return undefined;
			            }

			            let mask = 0;

			            const shift = bit => {
			                mask <<= 1;
			                mask += bit ? 1 : 0;
			            };

			            const isType = type => {
			                // shouldn't match any 0's, must match at least one 1
			                return !(~type & mask) && !!(type & mask);
			            };

			            'YXMxWwdD'.split('').forEach(part => shift(components[part]));

			            const dateA = isType(dmA);
			            const dateB = !dateA && isType(dmB);
			            const dateC = isType(dmC);
			            const dateD = !dateC && isType(dmD);

			            mask = 0;
			            'PHhmsf'.split('').forEach(part => shift(components[part]));

			            const timeA = isType(tmA);
			            const timeB = !timeA && isType(tmB);

			            // should only be zero or one date type and zero or one time type

			            const dateComps = dateB ? 'YD' : dateC ? 'XxwF' : dateD? 'XWF' : 'YMD';
			            const timeComps = timeB ? 'Phmsf' : 'Hmsf';

			            const comps = dateComps + timeComps;

			            // step through the candidate parts from most significant to least significant
			            // default the most significant unspecified parts to current timestamp component
			            // default the least significant unspecified parts to zero
			            // if any gaps in between the specified parts, throw an error

			            const now = this.environment.timestamp; // must get the fixed timestamp from jsonata

			            let startSpecified = false;
			            let endSpecified = false;
			            comps.split('').forEach(part => {
			                if(typeof components[part] === 'undefined') {
			                    if(startSpecified) {
			                        // past the specified block - default to zero
			                        components[part] = ('MDd'.indexOf(part) !== -1) ? 1 : 0;
			                        endSpecified = true;
			                    } else {
			                        // haven't hit the specified block yet, default to current timestamp
			                        components[part] = getDateTimeFragment(now, part);
			                    }
			                } else {
			                    startSpecified = true;
			                    if(endSpecified) {
			                        throw {
			                            code: 'D3136'
			                        };
			                    }
			                }
			            });

			            // validate and fill in components
			            if (components.M > 0) {
			                components.M -= 1;  // Date.UTC requires a zero-indexed month
			            } else {
			                components.M = 0; // default to January
			            }
			            if (dateB) {
			                // millis for given 1st Jan of that year (at 00:00 UTC)
			                const firstJan = Date.UTC(components.Y, 0);
			                const offsetMillis = (components.d - 1) * 1000 * 60 * 60 * 24;
			                const derivedDate = new Date(firstJan + offsetMillis);
			                components.M = derivedDate.getUTCMonth();
			                components.D = derivedDate.getUTCDate();
			            }
			            if (dateC) {
			                // TODO implement this
			                // parsing this format not currently supported
			                throw {
			                    code: 'D3136'
			                };
			            }
			            if (dateD) {
			                // TODO implement this
			                // parsing this format (ISO week date) not currently supported
			                throw {
			                    code: 'D3136'
			                };
			            }
			            if (timeB) {
			                // 12hr to 24hr
			                components.H = components.h === 12 ? 0 : components.h;
			                if (components.P === 1) {
			                    components.H += 12;
			                }
			            }

			            var millis = Date.UTC(components.Y, components.M, components.D, components.H, components.m, components.s, components.f);
			            if(components.Z || components.z) {
			                // adjust for timezone
			                millis -= (components.Z || components.z) * 60 * 1000;
			            }
			            return millis;
			        }
			    }

			    // Regular expression to match an ISO 8601 formatted timestamp
			    var iso8601regex = new RegExp('^\\d{4}(-[01]\\d)*(-[0-3]\\d)*(T[0-2]\\d:[0-5]\\d:[0-5]\\d)*(\\.\\d+)?([+-][0-2]\\d:?[0-5]\\d|Z)?$');

			    /**
			     * Converts an ISO 8601 timestamp to milliseconds since the epoch
			     *
			     * @param {string} timestamp - the timestamp to be converted
			     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)
			     * @returns {Number} - milliseconds since the epoch
			     */
			    function toMillis(timestamp, picture) {
			        // undefined inputs always return undefined
			        if(typeof timestamp === 'undefined') {
			            return undefined;
			        }

			        if(typeof picture === 'undefined') {
			            if (!iso8601regex.test(timestamp)) {
			                throw {
			                    stack: (new Error()).stack,
			                    code: "D3110",
			                    value: timestamp
			                };
			            }

			            return Date.parse(timestamp);
			        } else {
			            return parseDateTime.call(this, timestamp, picture);
			        }
			    }

			    /**
			     * Converts milliseconds since the epoch to an ISO 8601 timestamp
			     * @param {Number} millis - milliseconds since the epoch to be converted
			     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)
			     * @param {string} [timezone] - the timezone to format the timestamp in (defaults to UTC)
			     * @returns {String} - the formatted timestamp
			     */
			    function fromMillis(millis, picture, timezone) {
			        // undefined inputs always return undefined
			        if(typeof millis === 'undefined') {
			            return undefined;
			        }

			        return formatDateTime.call(this, millis, picture, timezone);
			    }

			    return {
			        formatInteger, parseInteger, fromMillis, toMillis
			    };
			})();

			module.exports = dateTime;

			},{"./utils":6}],2:[function(require,module,exports){
			(function (global){(function (){
			/**
			 * © Copyright IBM Corp. 2016, 2018 All Rights Reserved
			 *   Project name: JSONata
			 *   This project is licensed under the MIT License, see LICENSE
			 */

			var utils = require('./utils');

			const functions = (() => {

			    var isNumeric = utils.isNumeric;
			    var isArrayOfStrings = utils.isArrayOfStrings;
			    var isArrayOfNumbers = utils.isArrayOfNumbers;
			    var createSequence = utils.createSequence;
			    var isSequence = utils.isSequence;
			    var isFunction = utils.isFunction;
			    var isLambda = utils.isLambda;
			    var isIterable = utils.isIterable;
			    var getFunctionArity = utils.getFunctionArity;
			    var deepEquals = utils.isDeepEqual;
			    var stringToArray = utils.stringToArray;

			    /**
			     * Sum function
			     * @param {Object} args - Arguments
			     * @returns {number} Total value of arguments
			     */
			    function sum(args) {
			        // undefined inputs always return undefined
			        if (typeof args === 'undefined') {
			            return undefined;
			        }

			        var total = 0;
			        args.forEach(function (num) {
			            total += num;
			        });
			        return total;
			    }

			    /**
			     * Count function
			     * @param {Object} args - Arguments
			     * @returns {number} Number of elements in the array
			     */
			    function count(args) {
			        // undefined inputs always return undefined
			        if (typeof args === 'undefined') {
			            return 0;
			        }

			        return args.length;
			    }

			    /**
			     * Max function
			     * @param {Object} args - Arguments
			     * @returns {number} Max element in the array
			     */
			    function max(args) {
			        // undefined inputs always return undefined
			        if (typeof args === 'undefined' || args.length === 0) {
			            return undefined;
			        }

			        return Math.max.apply(Math, args);
			    }

			    /**
			     * Min function
			     * @param {Object} args - Arguments
			     * @returns {number} Min element in the array
			     */
			    function min(args) {
			        // undefined inputs always return undefined
			        if (typeof args === 'undefined' || args.length === 0) {
			            return undefined;
			        }

			        return Math.min.apply(Math, args);
			    }

			    /**
			     * Average function
			     * @param {Object} args - Arguments
			     * @returns {number} Average element in the array
			     */
			    function average(args) {
			        // undefined inputs always return undefined
			        if (typeof args === 'undefined' || args.length === 0) {
			            return undefined;
			        }

			        var total = 0;
			        args.forEach(function (num) {
			            total += num;
			        });
			        return total / args.length;
			    }

			    /**
			     * Stringify arguments
			     * @param {Object} arg - Arguments
			     * @param {boolean} [prettify] - Pretty print the result
			     * @returns {String} String from arguments
			     */
			    function string(arg, prettify = false) {
			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        var str;

			        if (typeof arg === 'string') {
			            // already a string
			            str = arg;
			        } else if (isFunction(arg)) {
			            // functions (built-in and lambda convert to empty string
			            str = '';
			        } else if (typeof arg === 'number' && !isFinite(arg)) {
			            throw {
			                code: "D3001",
			                value: arg,
			                stack: (new Error()).stack
			            };
			        } else {
			            var space = prettify ? 2 : 0;
			            if(Array.isArray(arg) && arg.outerWrapper) {
			                arg = arg[0];
			            }
			            str = JSON.stringify(arg, function (key, val) {
			                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(15)) :
			                    (val && isFunction(val)) ? '' : val;
			            }, space);
			        }
			        return str;
			    }

			    /**
			     * Create substring based on character number and length
			     * @param {String} str - String to evaluate
			     * @param {Integer} start - Character number to start substring
			     * @param {Integer} [length] - Number of characters in substring
			     * @returns {string|*} Substring
			     */
			    function substring(str, start, length) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        var strArray = stringToArray(str);
			        var strLength = strArray.length;

			        if (strLength + start < 0) {
			            start = 0;
			        }

			        if (typeof length !== 'undefined') {
			            if (length <= 0) {
			                return '';
			            }
			            var end = start >= 0 ? start + length : strLength + start + length;
			            return strArray.slice(start, end).join('');
			        }

			        return strArray.slice(start).join('');
			    }

			    /**
			     * Create substring up until a character
			     * @param {String} str - String to evaluate
			     * @param {String} chars - Character to define substring boundary
			     * @returns {*} Substring
			     */
			    function substringBefore(str, chars) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        var pos = str.indexOf(chars);
			        if (pos > -1) {
			            return str.substr(0, pos);
			        } else {
			            return str;
			        }
			    }

			    /**
			     * Create substring after a character
			     * @param {String} str - String to evaluate
			     * @param {String} chars - Character to define substring boundary
			     * @returns {*} Substring
			     */
			    function substringAfter(str, chars) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        var pos = str.indexOf(chars);
			        if (pos > -1) {
			            return str.substr(pos + chars.length);
			        } else {
			            return str;
			        }
			    }

			    /**
			     * Lowercase a string
			     * @param {String} str - String to evaluate
			     * @returns {string} Lowercase string
			     */
			    function lowercase(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        return str.toLowerCase();
			    }

			    /**
			     * Uppercase a string
			     * @param {String} str - String to evaluate
			     * @returns {string} Uppercase string
			     */
			    function uppercase(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        return str.toUpperCase();
			    }

			    /**
			     * length of a string
			     * @param {String} str - string
			     * @returns {Number} The number of characters in the string
			     */
			    function length(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        return stringToArray(str).length;
			    }

			    /**
			     * Normalize and trim whitespace within a string
			     * @param {string} str - string to be trimmed
			     * @returns {string} - trimmed string
			     */
			    function trim(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        // normalize whitespace
			        var result = str.replace(/[ \t\n\r]+/gm, ' ');
			        if (result.charAt(0) === ' ') {
			            // strip leading space
			            result = result.substring(1);
			        }
			        if (result.charAt(result.length - 1) === ' ') {
			            // strip trailing space
			            result = result.substring(0, result.length - 1);
			        }
			        return result;
			    }

			    /**
			     * Pad a string to a minimum width by adding characters to the start or end
			     * @param {string} str - string to be padded
			     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left
			     * @param {string} [char] - the pad character(s); defaults to ' '
			     * @returns {string} - padded string
			     */
			    function pad(str, width, char) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        if (typeof char === 'undefined' || char.length === 0) {
			            char = ' ';
			        }

			        var result;
			        var padLength = Math.abs(width) - length(str);
			        if (padLength > 0) {
			            var padding = (new Array(padLength + 1)).join(char);
			            if (char.length > 1) {
			                padding = substring(padding, 0, padLength);
			            }
			            if (width > 0) {
			                result = str + padding;
			            } else {
			                result = padding + str;
			            }
			        } else {
			            result = str;
			        }
			        return result;
			    }

			    /**
			     * Evaluate the matcher function against the str arg
			     *
			     * @param {*} matcher - matching function (native or lambda)
			     * @param {string} str - the string to match against
			     * @returns {object} - structure that represents the match(es)
			     */
			    function* evaluateMatcher(matcher, str) {
			        var result = matcher.apply(this, [str]); // eslint-disable-line no-useless-call
			        if(isIterable(result)) {
			            result = yield * result;
			        }
			        if(result && !(typeof result.start === 'number' || result.end === 'number' || Array.isArray(result.groups) || isFunction(result.next))) {
			            // the matcher function didn't return the correct structure
			            throw {
			                code: "T1010",
			                stack: (new Error()).stack,
			            };
			        }
			        return result;
			    }

			    /**
			     * Tests if the str contains the token
			     * @param {String} str - string to test
			     * @param {String} token - substring or regex to find
			     * @returns {Boolean} - true if str contains token
			     */
			    function* contains(str, token) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        var result;

			        if (typeof token === 'string') {
			            result = (str.indexOf(token) !== -1);
			        } else {
			            var matches = yield* evaluateMatcher(token, str);
			            result = (typeof matches !== 'undefined');
			        }

			        return result;
			    }

			    /**
			     * Match a string with a regex returning an array of object containing details of each match
			     * @param {String} str - string
			     * @param {String} regex - the regex applied to the string
			     * @param {Integer} [limit] - max number of matches to return
			     * @returns {Array} The array of match objects
			     */
			    function* match(str, regex, limit) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        // limit, if specified, must be a non-negative number
			        if (limit < 0) {
			            throw {
			                stack: (new Error()).stack,
			                value: limit,
			                code: 'D3040',
			                index: 3
			            };
			        }

			        var result = createSequence();

			        if (typeof limit === 'undefined' || limit > 0) {
			            var count = 0;
			            var matches = yield* evaluateMatcher(regex, str);
			            if (typeof matches !== 'undefined') {
			                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
			                    result.push({
			                        match: matches.match,
			                        index: matches.start,
			                        groups: matches.groups
			                    });
			                    matches = yield* evaluateMatcher(matches.next);
			                    count++;
			                }
			            }
			        }

			        return result;
			    }

			    /**
			     * Match a string with a regex returning an array of object containing details of each match
			     * @param {String} str - string
			     * @param {String} pattern - the substring/regex applied to the string
			     * @param {String} replacement - text to replace the matched substrings
			     * @param {Integer} [limit] - max number of matches to return
			     * @returns {Array} The array of match objects
			     */
			    function* replace(str, pattern, replacement, limit) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        var self = this;

			        // pattern cannot be an empty string
			        if (pattern === '') {
			            throw {
			                code: "D3010",
			                stack: (new Error()).stack,
			                value: pattern,
			                index: 2
			            };
			        }

			        // limit, if specified, must be a non-negative number
			        if (limit < 0) {
			            throw {
			                code: "D3011",
			                stack: (new Error()).stack,
			                value: limit,
			                index: 4
			            };
			        }

			        var replacer;
			        if (typeof replacement === 'string') {
			            replacer = function (regexMatch) {
			                var substitute = '';
			                // scan forward, copying the replacement text into the substitute string
			                // and replace any occurrence of $n with the values matched by the regex
			                var position = 0;
			                var index = replacement.indexOf('$', position);
			                while (index !== -1 && position < replacement.length) {
			                    substitute += replacement.substring(position, index);
			                    position = index + 1;
			                    var dollarVal = replacement.charAt(position);
			                    if (dollarVal === '$') {
			                        // literal $
			                        substitute += '$';
			                        position++;
			                    } else if (dollarVal === '0') {
			                        substitute += regexMatch.match;
			                        position++;
			                    } else {
			                        var maxDigits;
			                        if (regexMatch.groups.length === 0) {
			                            // no sub-matches; any $ followed by a digit will be replaced by an empty string
			                            maxDigits = 1;
			                        } else {
			                            // max number of digits to parse following the $
			                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
			                        }
			                        index = parseInt(replacement.substring(position, position + maxDigits), 10);
			                        if (maxDigits > 1 && index > regexMatch.groups.length) {
			                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);
			                        }
			                        if (!isNaN(index)) {
			                            if (regexMatch.groups.length > 0) {
			                                var submatch = regexMatch.groups[index - 1];
			                                if (typeof submatch !== 'undefined') {
			                                    substitute += submatch;
			                                }
			                            }
			                            position += index.toString().length;
			                        } else {
			                            // not a capture group, treat the $ as literal
			                            substitute += '$';
			                        }
			                    }
			                    index = replacement.indexOf('$', position);
			                }
			                substitute += replacement.substring(position);
			                return substitute;
			            };
			        } else {
			            replacer = replacement;
			        }

			        var result = '';
			        var position = 0;

			        if (typeof limit === 'undefined' || limit > 0) {
			            var count = 0;
			            if (typeof pattern === 'string') {
			                var index = str.indexOf(pattern, position);
			                while (index !== -1 && (typeof limit === 'undefined' || count < limit)) {
			                    result += str.substring(position, index);
			                    result += replacement;
			                    position = index + pattern.length;
			                    count++;
			                    index = str.indexOf(pattern, position);
			                }
			                result += str.substring(position);
			            } else {
			                var matches = yield* evaluateMatcher(pattern, str);
			                if (typeof matches !== 'undefined') {
			                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
			                        result += str.substring(position, matches.start);
			                        var replacedWith = replacer.apply(self, [matches]);
			                        if (isIterable(replacedWith)) {
			                            replacedWith = yield* replacedWith;
			                        }
			                        // check replacedWith is a string
			                        if (typeof replacedWith === 'string') {
			                            result += replacedWith;
			                        } else {
			                            // not a string - throw error
			                            throw {
			                                code: "D3012",
			                                stack: (new Error()).stack,
			                                value: replacedWith
			                            };
			                        }
			                        position = matches.start + matches.match.length;
			                        count++;
			                        matches = yield* evaluateMatcher(matches.next);
			                    }
			                    result += str.substring(position);
			                } else {
			                    result = str;
			                }
			            }
			        } else {
			            result = str;
			        }

			        return result;
			    }

			    /**
			     * Base64 encode a string
			     * @param {String} str - string
			     * @returns {String} Base 64 encoding of the binary data
			     */
			    function base64encode(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }
			        // Use btoa in a browser, or Buffer in Node.js

			        var btoa = typeof window !== 'undefined' ?
			            /* istanbul ignore next */ window.btoa :
			            function (str) {
			                // Simply doing `new Buffer` at this point causes Browserify to pull
			                // in the entire Buffer browser library, which is large and unnecessary.
			                // Using `global.Buffer` defeats this.
			                return new global.Buffer.from(str, 'binary').toString('base64'); // eslint-disable-line new-cap
			            };
			        return btoa(str);
			    }

			    /**
			     * Base64 decode a string
			     * @param {String} str - string
			     * @returns {String} Base 64 encoding of the binary data
			     */
			    function base64decode(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }
			        // Use btoa in a browser, or Buffer in Node.js
			        var atob = typeof window !== 'undefined' ?
			            /* istanbul ignore next */ window.atob :
			            function (str) {
			                // Simply doing `new Buffer` at this point causes Browserify to pull
			                // in the entire Buffer browser library, which is large and unnecessary.
			                // Using `global.Buffer` defeats this.
			                return new global.Buffer.from(str, 'base64').toString('binary'); // eslint-disable-line new-cap
			            };
			        return atob(str);
			    }

			    /**
			     * Encode a string into a component for a url
			     * @param {String} str - String to encode
			     * @returns {string} Encoded string
			     */
			    function encodeUrlComponent(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        // Catch URIErrors when URI sequence is malformed
			        var returnVal;
			        try {
			            returnVal = encodeURIComponent(str);
			        } catch (e) {
			            throw {
			                code: "D3140",
			                stack: (new Error()).stack,
			                value: str,
			                functionName: "encodeUrlComponent"
			            };
			        }
			        return returnVal;
			    }

			    /**
			     * Encode a string into a url
			     * @param {String} str - String to encode
			     * @returns {string} Encoded string
			     */
			    function encodeUrl(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        // Catch URIErrors when URI sequence is malformed
			        var returnVal;
			        try {
			            returnVal = encodeURI(str);
			        } catch (e) {
			            throw {
			                code: "D3140",
			                stack: (new Error()).stack,
			                value: str,
			                functionName: "encodeUrl"
			            };
			        }
			        return returnVal;
			    }

			    /**
			     * Decode a string from a component for a url
			     * @param {String} str - String to decode
			     * @returns {string} Decoded string
			     */
			    function decodeUrlComponent(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        // Catch URIErrors when URI sequence is malformed
			        var returnVal;
			        try {
			            returnVal = decodeURIComponent(str);
			        } catch (e) {
			            throw {
			                code: "D3140",
			                stack: (new Error()).stack,
			                value: str,
			                functionName: "decodeUrlComponent"
			            };
			        }
			        return returnVal;
			    }

			    /**
			     * Decode a string from a url
			     * @param {String} str - String to decode
			     * @returns {string} Decoded string
			     */
			    function decodeUrl(str) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        // Catch URIErrors when URI sequence is malformed
			        var returnVal;
			        try {
			            returnVal = decodeURI(str);
			        } catch (e) {
			            throw {
			                code: "D3140",
			                stack: (new Error()).stack,
			                value: str,
			                functionName: "decodeUrl"
			            };
			        }
			        return returnVal;
			    }

			    /**
			     * Split a string into an array of substrings
			     * @param {String} str - string
			     * @param {String} separator - the token or regex that splits the string
			     * @param {Integer} [limit] - max number of substrings
			     * @returns {Array} The array of string
			     */
			    function* split(str, separator, limit) {
			        // undefined inputs always return undefined
			        if (typeof str === 'undefined') {
			            return undefined;
			        }

			        // limit, if specified, must be a non-negative number
			        if (limit < 0) {
			            throw {
			                code: "D3020",
			                stack: (new Error()).stack,
			                value: limit,
			                index: 3
			            };
			        }

			        var result = [];

			        if (typeof limit === 'undefined' || limit > 0) {
			            if (typeof separator === 'string') {
			                result = str.split(separator, limit);
			            } else {
			                var count = 0;
			                var matches = yield* evaluateMatcher(separator, str);
			                if (typeof matches !== 'undefined') {
			                    var start = 0;
			                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
			                        result.push(str.substring(start, matches.start));
			                        start = matches.end;
			                        matches = yield* evaluateMatcher(matches.next);
			                        count++;
			                    }
			                    if (typeof limit === 'undefined' || count < limit) {
			                        result.push(str.substring(start));
			                    }
			                } else {
			                    result.push(str);
			                }
			            }
			        }

			        return result;
			    }

			    /**
			     * Join an array of strings
			     * @param {Array} strs - array of string
			     * @param {String} [separator] - the token that splits the string
			     * @returns {String} The concatenated string
			     */
			    function join(strs, separator) {
			        // undefined inputs always return undefined
			        if (typeof strs === 'undefined') {
			            return undefined;
			        }

			        // if separator is not specified, default to empty string
			        if (typeof separator === 'undefined') {
			            separator = "";
			        }

			        return strs.join(separator);
			    }

			    /**
			     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec
			     * @param {number} value - number to format
			     * @param {String} picture - picture string definition
			     * @param {Object} [options] - override locale defaults
			     * @returns {String} The formatted string
			     */
			    function formatNumber(value, picture, options) {
			        // undefined inputs always return undefined
			        if (typeof value === 'undefined') {
			            return undefined;
			        }

			        var defaults = {
			            "decimal-separator": ".",
			            "grouping-separator": ",",
			            "exponent-separator": "e",
			            "infinity": "Infinity",
			            "minus-sign": "-",
			            "NaN": "NaN",
			            "percent": "%",
			            "per-mille": "\u2030",
			            "zero-digit": "0",
			            "digit": "#",
			            "pattern-separator": ";"
			        };

			        // if `options` is specified, then its entries override defaults
			        var properties = defaults;
			        if (typeof options !== 'undefined') {
			            Object.keys(options).forEach(function (key) {
			                properties[key] = options[key];
			            });
			        }

			        var decimalDigitFamily = [];
			        var zeroCharCode = properties['zero-digit'].charCodeAt(0);
			        for (var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {
			            decimalDigitFamily.push(String.fromCharCode(ii));
			        }

			        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);

			        var subPictures = picture.split(properties['pattern-separator']);

			        if (subPictures.length > 2) {
			            throw {
			                code: 'D3080',
			                stack: (new Error()).stack
			            };
			        }

			        var splitParts = function (subpicture) {
			            var prefix = (function () {
			                var ch;
			                for (var ii = 0; ii < subpicture.length; ii++) {
			                    ch = subpicture.charAt(ii);
			                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
			                        return subpicture.substring(0, ii);
			                    }
			                }
			            })();
			            var suffix = (function () {
			                var ch;
			                for (var ii = subpicture.length - 1; ii >= 0; ii--) {
			                    ch = subpicture.charAt(ii);
			                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
			                        return subpicture.substring(ii + 1);
			                    }
			                }
			            })();
			            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);
			            var mantissaPart, exponentPart, integerPart, fractionalPart;
			            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);
			            if (exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
			                mantissaPart = activePart;
			                exponentPart = undefined;
			            } else {
			                mantissaPart = activePart.substring(0, exponentPosition);
			                exponentPart = activePart.substring(exponentPosition + 1);
			            }
			            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);
			            if (decimalPosition === -1) {
			                integerPart = mantissaPart;
			                fractionalPart = suffix;
			            } else {
			                integerPart = mantissaPart.substring(0, decimalPosition);
			                fractionalPart = mantissaPart.substring(decimalPosition + 1);
			            }
			            return {
			                prefix: prefix,
			                suffix: suffix,
			                activePart: activePart,
			                mantissaPart: mantissaPart,
			                exponentPart: exponentPart,
			                integerPart: integerPart,
			                fractionalPart: fractionalPart,
			                subpicture: subpicture
			            };
			        };

			        // validate the picture string, F&O 4.7.3
			        var validate = function (parts) {
			            var error;
			            var ii;
			            var subpicture = parts.subpicture;
			            var decimalPos = subpicture.indexOf(properties['decimal-separator']);
			            if (decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {
			                error = 'D3081';
			            }
			            if (subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
			                error = 'D3082';
			            }
			            if (subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {
			                error = 'D3083';
			            }
			            if (subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {
			                error = 'D3084';
			            }
			            var valid = false;
			            for (ii = 0; ii < parts.mantissaPart.length; ii++) {
			                var ch = parts.mantissaPart.charAt(ii);
			                if (decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {
			                    valid = true;
			                    break;
			                }
			            }
			            if (!valid) {
			                error = 'D3085';
			            }
			            var charTypes = parts.activePart.split('').map(function (char) {
			                return activeChars.indexOf(char) === -1 ? 'p' : 'a';
			            }).join('');
			            if (charTypes.indexOf('p') !== -1) {
			                error = 'D3086';
			            }
			            if (decimalPos !== -1) {
			                if (subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {
			                    error = 'D3087';
			                }
			            } else if (parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {
			                error = 'D3088';
			            }
			            if (subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {
			                error = 'D3089';
			            }
			            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);
			            if (optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function (char) {
			                return decimalDigitFamily.indexOf(char) > -1;
			            }).length > 0) {
			                error = 'D3090';
			            }
			            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);
			            if (optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function (char) {
			                return decimalDigitFamily.indexOf(char) > -1;
			            }).length > 0) {
			                error = 'D3091';
			            }
			            var exponentExists = (typeof parts.exponentPart === 'string');
			            if (exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {
			                error = 'D3092';
			            }
			            if (exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function (char) {
			                return decimalDigitFamily.indexOf(char) === -1;
			            }).length > 0)) {
			                error = 'D3093';
			            }
			            if (error) {
			                throw {
			                    code: error,
			                    stack: (new Error()).stack
			                };
			            }
			        };

			        // analyse the picture string, F&O 4.7.4
			        var analyse = function (parts) {
			            var getGroupingPositions = function (part, toLeft) {
			                var positions = [];
			                var groupingPosition = part.indexOf(properties['grouping-separator']);
			                while (groupingPosition !== -1) {
			                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function (char) {
			                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
			                    }).length;
			                    positions.push(charsToTheRight);
			                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);
			                }
			                return positions;
			            };
			            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);
			            var regular = function (indexes) {
			                // are the grouping positions regular? i.e. same interval between each of them
			                if (indexes.length === 0) {
			                    return 0;
			                }
			                var gcd = function (a, b) {
			                    return b === 0 ? a : gcd(b, a % b);
			                };
			                // find the greatest common divisor of all the positions
			                var factor = indexes.reduce(gcd);
			                // is every position separated by this divisor? If so, it's regular
			                for (var index = 1; index <= indexes.length; index++) {
			                    if (indexes.indexOf(index * factor) === -1) {
			                        return 0;
			                    }
			                }
			                return factor;
			            };

			            var regularGrouping = regular(integerPartGroupingPositions);
			            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);

			            var minimumIntegerPartSize = parts.integerPart.split('').filter(function (char) {
			                return decimalDigitFamily.indexOf(char) !== -1;
			            }).length;
			            var scalingFactor = minimumIntegerPartSize;

			            var fractionalPartArray = parts.fractionalPart.split('');
			            var minimumFactionalPartSize = fractionalPartArray.filter(function (char) {
			                return decimalDigitFamily.indexOf(char) !== -1;
			            }).length;
			            var maximumFactionalPartSize = fractionalPartArray.filter(function (char) {
			                return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
			            }).length;
			            var exponentPresent = typeof parts.exponentPart === 'string';
			            if (minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
			                if (exponentPresent) {
			                    minimumFactionalPartSize = 1;
			                    maximumFactionalPartSize = 1;
			                } else {
			                    minimumIntegerPartSize = 1;
			                }
			            }
			            if (exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {
			                minimumIntegerPartSize = 1;
			            }
			            if (minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
			                minimumFactionalPartSize = 1;
			            }
			            var minimumExponentSize = 0;
			            if (exponentPresent) {
			                minimumExponentSize = parts.exponentPart.split('').filter(function (char) {
			                    return decimalDigitFamily.indexOf(char) !== -1;
			                }).length;
			            }

			            return {
			                integerPartGroupingPositions: integerPartGroupingPositions,
			                regularGrouping: regularGrouping,
			                minimumIntegerPartSize: minimumIntegerPartSize,
			                scalingFactor: scalingFactor,
			                prefix: parts.prefix,
			                fractionalPartGroupingPositions: fractionalPartGroupingPositions,
			                minimumFactionalPartSize: minimumFactionalPartSize,
			                maximumFactionalPartSize: maximumFactionalPartSize,
			                minimumExponentSize: minimumExponentSize,
			                suffix: parts.suffix,
			                picture: parts.subpicture
			            };
			        };

			        var parts = subPictures.map(splitParts);
			        parts.forEach(validate);

			        var variables = parts.map(analyse);

			        var minus_sign = properties['minus-sign'];
			        var zero_digit = properties['zero-digit'];
			        var decimal_separator = properties['decimal-separator'];
			        var grouping_separator = properties['grouping-separator'];

			        if (variables.length === 1) {
			            variables.push(JSON.parse(JSON.stringify(variables[0])));
			            variables[1].prefix = minus_sign + variables[1].prefix;
			        }

			        // TODO cache the result of the analysis

			        // format the number
			        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON
			        var pic;
			        // bullet 2:
			        if (value >= 0) {
			            pic = variables[0];
			        } else {
			            pic = variables[1];
			        }
			        var adjustedNumber;
			        // bullet 3:
			        if (pic.picture.indexOf(properties.percent) !== -1) {
			            adjustedNumber = value * 100;
			        } else if (pic.picture.indexOf(properties['per-mille']) !== -1) {
			            adjustedNumber = value * 1000;
			        } else {
			            adjustedNumber = value;
			        }
			        // bullet 4:
			        // TODO: infinity - not sure we'd ever get this in JSON
			        // bullet 5:
			        var mantissa, exponent;
			        if (pic.minimumExponentSize === 0) {
			            mantissa = adjustedNumber;
			        } else {
			            // mantissa * 10^exponent = adjustedNumber
			            var maxMantissa = Math.pow(10, pic.scalingFactor);
			            var minMantissa = Math.pow(10, pic.scalingFactor - 1);
			            mantissa = adjustedNumber;
			            exponent = 0;
			            while (mantissa < minMantissa) {
			                mantissa *= 10;
			                exponent -= 1;
			            }
			            while (mantissa > maxMantissa) {
			                mantissa /= 10;
			                exponent += 1;
			            }
			        }
			        // bullet 6:
			        var roundedNumber = round(mantissa, pic.maximumFactionalPartSize);
			        // bullet 7:
			        var makeString = function (value, dp) {
			            var str = Math.abs(value).toFixed(dp);
			            if (zero_digit !== '0') {
			                str = str.split('').map(function (digit) {
			                    if (digit >= '0' && digit <= '9') {
			                        return decimalDigitFamily[digit.charCodeAt(0) - 48];
			                    } else {
			                        return digit;
			                    }
			                }).join('');
			            }
			            return str;
			        };
			        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
			        var decimalPos = stringValue.indexOf('.');
			        if (decimalPos === -1) {
			            stringValue = stringValue + decimal_separator;
			        } else {
			            stringValue = stringValue.replace('.', decimal_separator);
			        }
			        while (stringValue.charAt(0) === zero_digit) {
			            stringValue = stringValue.substring(1);
			        }
			        while (stringValue.charAt(stringValue.length - 1) === zero_digit) {
			            stringValue = stringValue.substring(0, stringValue.length - 1);
			        }
			        // bullets 8 & 9:
			        decimalPos = stringValue.indexOf(decimal_separator);
			        var padLeft = pic.minimumIntegerPartSize - decimalPos;
			        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
			        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join(zero_digit) : '') + stringValue;
			        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join(zero_digit) : '');
			        decimalPos = stringValue.indexOf(decimal_separator);
			        // bullet 10:
			        if (pic.regularGrouping > 0) {
			            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
			            for (var group = 1; group <= groupCount; group++) {
			                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), grouping_separator, stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');
			            }
			        } else {
			            pic.integerPartGroupingPositions.forEach(function (pos) {
			                stringValue = [stringValue.slice(0, decimalPos - pos), grouping_separator, stringValue.slice(decimalPos - pos)].join('');
			                decimalPos++;
			            });
			        }
			        // bullet 11:
			        decimalPos = stringValue.indexOf(decimal_separator);
			        pic.fractionalPartGroupingPositions.forEach(function (pos) {
			            stringValue = [stringValue.slice(0, pos + decimalPos + 1), grouping_separator, stringValue.slice(pos + decimalPos + 1)].join('');
			        });
			        // bullet 12:
			        decimalPos = stringValue.indexOf(decimal_separator);
			        if (pic.picture.indexOf(decimal_separator) === -1 || decimalPos === stringValue.length - 1) {
			            stringValue = stringValue.substring(0, stringValue.length - 1);
			        }
			        // bullet 13:
			        if (typeof exponent !== 'undefined') {
			            var stringExponent = makeString(exponent, 0);
			            padLeft = pic.minimumExponentSize - stringExponent.length;
			            if (padLeft > 0) {
			                stringExponent = new Array(padLeft + 1).join(zero_digit) + stringExponent;
			            }
			            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? minus_sign : '') + stringExponent;
			        }
			        // bullet 14:
			        stringValue = pic.prefix + stringValue + pic.suffix;
			        return stringValue;
			    }

			    /**
			     * Converts a number to a string using a specified number base
			     * @param {number} value - the number to convert
			     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10
			     * @returns {string} - the converted string
			     */
			    function formatBase(value, radix) {
			        // undefined inputs always return undefined
			        if (typeof value === 'undefined') {
			            return undefined;
			        }

			        value = round(value);

			        if (typeof radix === 'undefined') {
			            radix = 10;
			        } else {
			            radix = round(radix);
			        }

			        if (radix < 2 || radix > 36) {
			            throw {
			                code: 'D3100',
			                stack: (new Error()).stack,
			                value: radix
			            };

			        }

			        var result = value.toString(radix);

			        return result;
			    }

			    /**
			     * Cast argument to number
			     * @param {Object} arg - Argument
			     * @returns {Number} numeric value of argument
			     */
			    function number(arg) {
			        var result;

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        if (typeof arg === 'number') {
			            // already a number
			            result = arg;
			        } else if (typeof arg === 'string' && /^-?[0-9]+(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
			            result = parseFloat(arg);
			        } else if (arg === true) {
			            // boolean true casts to 1
			            result = 1;
			        } else if (arg === false) {
			            // boolean false casts to 0
			            result = 0;
			        } else {
			            throw {
			                code: "D3030",
			                value: arg,
			                stack: (new Error()).stack,
			                index: 1
			            };
			        }
			        return result;
			    }

			    /**
			     * Absolute value of a number
			     * @param {Number} arg - Argument
			     * @returns {Number} absolute value of argument
			     */
			    function abs(arg) {
			        var result;

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        result = Math.abs(arg);
			        return result;
			    }

			    /**
			     * Rounds a number down to integer
			     * @param {Number} arg - Argument
			     * @returns {Number} rounded integer
			     */
			    function floor(arg) {
			        var result;

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        result = Math.floor(arg);
			        return result;
			    }

			    /**
			     * Rounds a number up to integer
			     * @param {Number} arg - Argument
			     * @returns {Number} rounded integer
			     */
			    function ceil(arg) {
			        var result;

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        result = Math.ceil(arg);
			        return result;
			    }

			    /**
			     * Round to half even
			     * @param {Number} arg - Argument
			     * @param {Number} [precision] - number of decimal places
			     * @returns {Number} rounded integer
			     */
			    function round(arg, precision) {
			        var result;

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        if (precision) {
			            // shift the decimal place - this needs to be done in a string since multiplying
			            // by a power of ten can introduce floating point precision errors which mess up
			            // this rounding algorithm - See 'Decimal rounding' in
			            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
			            // Shift
			            var value = arg.toString().split('e');
			            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));

			        }

			        // round up to nearest int
			        result = Math.round(arg);
			        var diff = result - arg;
			        if (Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
			            // rounded the wrong way - adjust to nearest even number
			            result = result - 1;
			        }
			        if (precision) {
			            // Shift back
			            value = result.toString().split('e');
			            /* istanbul ignore next */
			            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));
			        }
			        if (Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way
			            // JSON doesn't do -0
			            result = 0;
			        }
			        return result;
			    }

			    /**
			     * Square root of number
			     * @param {Number} arg - Argument
			     * @returns {Number} square root
			     */
			    function sqrt(arg) {
			        var result;

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        if (arg < 0) {
			            throw {
			                stack: (new Error()).stack,
			                code: "D3060",
			                index: 1,
			                value: arg
			            };
			        }

			        result = Math.sqrt(arg);

			        return result;
			    }

			    /**
			     * Raises number to the power of the second number
			     * @param {Number} arg - the base
			     * @param {Number} exp - the exponent
			     * @returns {Number} rounded integer
			     */
			    function power(arg, exp) {
			        var result;

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        result = Math.pow(arg, exp);

			        if (!isFinite(result)) {
			            throw {
			                stack: (new Error()).stack,
			                code: "D3061",
			                index: 1,
			                value: arg,
			                exp: exp
			            };
			        }

			        return result;
			    }

			    /**
			     * Returns a random number 0 <= n < 1
			     * @returns {number} random number
			     */
			    function random() {
			        return Math.random();
			    }

			    /**
			     * Evaluate an input and return a boolean
			     * @param {*} arg - Arguments
			     * @returns {boolean} Boolean
			     */
			    function boolean(arg) {
			        // cast arg to its effective boolean value
			        // boolean: unchanged
			        // string: zero-length -> false; otherwise -> true
			        // number: 0 -> false; otherwise -> true
			        // null -> false
			        // array: empty -> false; length > 1 -> true
			        // object: empty -> false; non-empty -> true
			        // function -> false

			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        var result = false;
			        if (Array.isArray(arg)) {
			            if (arg.length === 1) {
			                result = boolean(arg[0]);
			            } else if (arg.length > 1) {
			                var trues = arg.filter(function (val) {
			                    return boolean(val);
			                });
			                result = trues.length > 0;
			            }
			        } else if (typeof arg === 'string') {
			            if (arg.length > 0) {
			                result = true;
			            }
			        } else if (isNumeric(arg)) {
			            if (arg !== 0) {
			                result = true;
			            }
			        } else if (arg !== null && typeof arg === 'object') {
			            if (Object.keys(arg).length > 0) {
			                result = true;
			            }
			        } else if (typeof arg === 'boolean' && arg === true) {
			            result = true;
			        }
			        return result;
			    }

			    /**
			     * returns the Boolean NOT of the arg
			     * @param {*} arg - argument
			     * @returns {boolean} - NOT arg
			     */
			    function not(arg) {
			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        return !boolean(arg);
			    }

			    /**
			     * Helper function to build the arguments to be supplied to the function arg of the
			     * HOFs map, filter, each, sift and single
			     * @param {function} func - the function to be invoked
			     * @param {*} arg1 - the first (required) arg - the value
			     * @param {*} arg2 - the second (optional) arg - the position (index or key)
			     * @param {*} arg3 - the third (optional) arg - the whole structure (array or object)
			     * @returns {*[]} the argument list
			     */
			    function hofFuncArgs(func, arg1, arg2, arg3) {
			        var func_args = [arg1]; // the first arg (the value) is required
			        // the other two are optional - only supply it if the function can take it
			        var length = getFunctionArity(func);
			        if (length >= 2) {
			            func_args.push(arg2);
			        }
			        if (length >= 3) {
			            func_args.push(arg3);
			        }
			        return func_args;
			    }

			    /**
			     * Create a map from an array of arguments
			     * @param {Array} [arr] - array to map over
			     * @param {Function} func - function to apply
			     * @returns {Array} Map array
			     */
			    function* map(arr, func) {
			        // undefined inputs always return undefined
			        if (typeof arr === 'undefined') {
			            return undefined;
			        }

			        var result = createSequence();
			        // do the map - iterate over the arrays, and invoke func
			        for (var i = 0; i < arr.length; i++) {
			            var func_args = hofFuncArgs(func, arr[i], i, arr);
			            // invoke func
			            var res = yield* func.apply(this, func_args);
			            if (typeof res !== 'undefined') {
			                result.push(res);
			            }
			        }

			        return result;
			    }

			    /**
			     * Create a map from an array of arguments
			     * @param {Array} [arr] - array to filter
			     * @param {Function} func - predicate function
			     * @returns {Array} Map array
			     */
			    function* filter(arr, func) { // eslint-disable-line require-yield
			        // undefined inputs always return undefined
			        if (typeof arr === 'undefined') {
			            return undefined;
			        }

			        var result = createSequence();

			        for (var i = 0; i < arr.length; i++) {
			            var entry = arr[i];
			            var func_args = hofFuncArgs(func, entry, i, arr);
			            // invoke func
			            var res = yield* func.apply(this, func_args);
			            if (boolean(res)) {
			                result.push(entry);
			            }
			        }

			        return result;
			    }

			    /**
			     * Given an array, find the single element matching a specified condition
			     * Throws an exception if the number of matching elements is not exactly one
			     * @param {Array} [arr] - array to filter
			     * @param {Function} [func] - predicate function
			     * @returns {*} Matching element
			     */
			    function* single(arr, func) { // eslint-disable-line require-yield
			        // undefined inputs always return undefined
			        if (typeof arr === 'undefined') {
			            return undefined;
			        }

			        var hasFoundMatch = false;
			        var result;

			        for (var i = 0; i < arr.length; i++) {
			            var entry = arr[i];
			            var positiveResult = true;
			            if (typeof func !== 'undefined') {
			                var func_args = hofFuncArgs(func, entry, i, arr);
			                // invoke func
			                var res = yield* func.apply(this, func_args);
			                positiveResult = boolean(res);
			            }
			            if (positiveResult) {
			                if(!hasFoundMatch) {
			                    result = entry;
			                    hasFoundMatch = true;
			                } else {
			                    throw {
			                        stack: (new Error()).stack,
			                        code: "D3138",
			                        index: i
			                    };
			                }
			            }
			        }

			        if(!hasFoundMatch) {
			            throw {
			                stack: (new Error()).stack,
			                code: "D3139"
			            };
			        }

			        return result;
			    }

			    /**
			     * Convolves (zips) each value from a set of arrays
			     * @param {Array} [args] - arrays to zip
			     * @returns {Array} Zipped array
			     */
			    function zip() {
			        // this can take a variable number of arguments
			        var result = [];
			        var args = Array.prototype.slice.call(arguments);
			        // length of the shortest array
			        var length = Math.min.apply(Math, args.map(function (arg) {
			            if (Array.isArray(arg)) {
			                return arg.length;
			            }
			            return 0;
			        }));
			        for (var i = 0; i < length; i++) {
			            var tuple = args.map((arg) => {
			                return arg[i];
			            });
			            result.push(tuple);
			        }
			        return result;
			    }

			    /**
			     * Fold left function
			     * @param {Array} sequence - Sequence
			     * @param {Function} func - Function
			     * @param {Object} init - Initial value
			     * @returns {*} Result
			     */
			    function* foldLeft(sequence, func, init) {
			        // undefined inputs always return undefined
			        if (typeof sequence === 'undefined') {
			            return undefined;
			        }

			        var result;

			        var arity = getFunctionArity(func);
			        if (arity < 2) {
			            throw {
			                stack: (new Error()).stack,
			                code: "D3050",
			                index: 1
			            };
			        }

			        var index;
			        if (typeof init === 'undefined' && sequence.length > 0) {
			            result = sequence[0];
			            index = 1;
			        } else {
			            result = init;
			            index = 0;
			        }

			        while (index < sequence.length) {
			            var args = [result, sequence[index]];
			            if (arity >= 3) {
			                args.push(index);
			            }
			            if (arity >= 4) {
			                args.push(sequence);
			            }
			            result = yield* func.apply(this, args);
			            index++;
			        }

			        return result;
			    }

			    /**
			     * Return keys for an object
			     * @param {Object} arg - Object
			     * @returns {Array} Array of keys
			     */
			    function keys(arg) {
			        var result = createSequence();

			        if (Array.isArray(arg)) {
			            // merge the keys of all of the items in the array
			            var merge = {};
			            arg.forEach(function (item) {
			                var allkeys = keys(item);
			                allkeys.forEach(function (key) {
			                    merge[key] = true;
			                });
			            });
			            result = keys(merge);
			        } else if (arg !== null && typeof arg === 'object' && !(isLambda(arg))) {
			            Object.keys(arg).forEach(key => result.push(key));
			        }
			        return result;
			    }

			    /**
			     * Return value from an object for a given key
			     * @param {Object} input - Object/Array
			     * @param {String} key - Key in object
			     * @returns {*} Value of key in object
			     */
			    function lookup(input, key) {
			        // lookup the 'name' item in the input
			        var result;
			        if (Array.isArray(input)) {
			            result = createSequence();
			            for(var ii = 0; ii < input.length; ii++) {
			                var res =  lookup(input[ii], key);
			                if (typeof res !== 'undefined') {
			                    if (Array.isArray(res)) {
			                        res.forEach(val => result.push(val));
			                    } else {
			                        result.push(res);
			                    }
			                }
			            }
			        } else if (input !== null && typeof input === 'object') {
			            result = input[key];
			        }
			        return result;
			    }

			    /**
			     * Append second argument to first
			     * @param {Array|Object} arg1 - First argument
			     * @param {Array|Object} arg2 - Second argument
			     * @returns {*} Appended arguments
			     */
			    function append(arg1, arg2) {
			        // disregard undefined args
			        if (typeof arg1 === 'undefined') {
			            return arg2;
			        }
			        if (typeof arg2 === 'undefined') {
			            return arg1;
			        }
			        // if either argument is not an array, make it so
			        if (!Array.isArray(arg1)) {
			            arg1 = createSequence(arg1);
			        }
			        if (!Array.isArray(arg2)) {
			            arg2 = [arg2];
			        }
			        return arg1.concat(arg2);
			    }

			    /**
			     * Determines if the argument is undefined
			     * @param {*} arg - argument
			     * @returns {boolean} False if argument undefined, otherwise true
			     */
			    function exists(arg) {
			        if (typeof arg === 'undefined') {
			            return false;
			        } else {
			            return true;
			        }
			    }

			    /**
			     * Splits an object into an array of object with one property each
			     * @param {*} arg - the object to split
			     * @returns {*} - the array
			     */
			    function spread(arg) {
			        var result = createSequence();

			        if (Array.isArray(arg)) {
			            // spread all of the items in the array
			            arg.forEach(function (item) {
			                result = append(result, spread(item));
			            });
			        } else if (arg !== null && typeof arg === 'object' && !isLambda(arg)) {
			            for (var key in arg) {
			                var obj = {};
			                obj[key] = arg[key];
			                result.push(obj);
			            }
			        } else {
			            result = arg;
			        }
			        return result;
			    }

			    /**
			     * Merges an array of objects into a single object.  Duplicate properties are
			     * overridden by entries later in the array
			     * @param {*} arg - the objects to merge
			     * @returns {*} - the object
			     */
			    function merge(arg) {
			        // undefined inputs always return undefined
			        if (typeof arg === 'undefined') {
			            return undefined;
			        }

			        var result = {};

			        arg.forEach(function (obj) {
			            for (var prop in obj) {
			                result[prop] = obj[prop];
			            }
			        });
			        return result;
			    }

			    /**
			     * Reverses the order of items in an array
			     * @param {Array} arr - the array to reverse
			     * @returns {Array} - the reversed array
			     */
			    function reverse(arr) {
			        // undefined inputs always return undefined
			        if (typeof arr === 'undefined') {
			            return undefined;
			        }

			        if (arr.length <= 1) {
			            return arr;
			        }

			        var length = arr.length;
			        var result = new Array(length);
			        for (var i = 0; i < length; i++) {
			            result[length - i - 1] = arr[i];
			        }

			        return result;
			    }

			    /**
			     *
			     * @param {*} obj - the input object to iterate over
			     * @param {*} func - the function to apply to each key/value pair
			     * @returns {Array} - the resultant array
			     */
			    function* each(obj, func) {
			        var result = createSequence();

			        for (var key in obj) {
			            var func_args = hofFuncArgs(func, obj[key], key, obj);
			            // invoke func
			            var val = yield* func.apply(this, func_args);
			            if(typeof val !== 'undefined') {
			                result.push(val);
			            }
			        }

			        return result;
			    }

			    /**
			     *
			     * @param {string} [message] - the message to attach to the error
			     * @throws custom error with code 'D3137'
			     */
			    function error(message) {
			        throw {
			            code: "D3137",
			            stack: (new Error()).stack,
			            message: message || "$error() function evaluated"
			        };
			    }

			    /**
			     *
			     * @param {boolean} condition - the condition to evaluate
			     * @param {string} [message] - the message to attach to the error
			     * @throws custom error with code 'D3137'
			     * @returns {undefined}
			     */
			    function assert(condition, message) {
			        if(!condition) {
			            throw {
			                code: "D3141",
			                stack: (new Error()).stack,
			                message: message || "$assert() statement failed"
			            };
			        }

			        return undefined;
			    }

			    /**
			     *
			     * @param {*} [value] - the input to which the type will be checked
			     * @returns {string} - the type of the input
			     */
			    function type(value) {
			        if (value === undefined) {
			            return undefined;
			        }

			        if (value === null) {
			            return 'null';
			        }

			        if (isNumeric(value)) {
			            return 'number';
			        }

			        if (typeof value === 'string') {
			            return 'string';
			        }

			        if (typeof value === 'boolean') {
			            return 'boolean';
			        }

			        if(Array.isArray(value)) {
			            return 'array';
			        }

			        if(isFunction(value)) {
			            return 'function';
			        }

			        return 'object';
			    }

			    /**
			     * Implements the merge sort (stable) with optional comparator function
			     *
			     * @param {Array} arr - the array to sort
			     * @param {*} comparator - comparator function
			     * @returns {Array} - sorted array
			     */
			    function* sort(arr, comparator) {
			        // undefined inputs always return undefined
			        if (typeof arr === 'undefined') {
			            return undefined;
			        }

			        if (arr.length <= 1) {
			            return arr;
			        }

			        var comp;
			        if (typeof comparator === 'undefined') {
			            // inject a default comparator - only works for numeric or string arrays
			            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
			                throw {
			                    stack: (new Error()).stack,
			                    code: "D3070",
			                    index: 1
			                };
			            }

			            comp = function* (a, b) {  // eslint-disable-line require-yield
			                return a > b;
			            };
			        } else {
			            // for internal usage of functionSort (i.e. order-by syntax)
			            comp = comparator;
			        }

			        var merge = function* (l, r) {
			            var merge_iter = function* (result, left, right) {
			                if (left.length === 0) {
			                    Array.prototype.push.apply(result, right);
			                } else if (right.length === 0) {
			                    Array.prototype.push.apply(result, left);
			                } else if (yield* comp(left[0], right[0])) { // invoke the comparator function
			                    // if it returns true - swap left and right
			                    result.push(right[0]);
			                    yield* merge_iter(result, left, right.slice(1));
			                } else {
			                    // otherwise keep the same order
			                    result.push(left[0]);
			                    yield* merge_iter(result, left.slice(1), right);
			                }
			            };
			            var merged = [];
			            yield* merge_iter(merged, l, r);
			            return merged;
			        };

			        var msort = function* (array) {
			            if (!Array.isArray(array) || array.length <= 1) {
			                return array;
			            } else {
			                var middle = Math.floor(array.length / 2);
			                var left = array.slice(0, middle);
			                var right = array.slice(middle);
			                left = yield* msort(left);
			                right = yield* msort(right);
			                return yield* merge(left, right);
			            }
			        };

			        var result = yield* msort(arr);

			        return result;
			    }

			    /**
			     * Randomly shuffles the contents of an array
			     * @param {Array} arr - the input array
			     * @returns {Array} the shuffled array
			     */
			    function shuffle(arr) {
			        // undefined inputs always return undefined
			        if (typeof arr === 'undefined') {
			            return undefined;
			        }

			        if (arr.length <= 1) {
			            return arr;
			        }

			        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm
			        var result = new Array(arr.length);
			        for (var i = 0; i < arr.length; i++) {
			            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 ≤ j ≤ i
			            if (i !== j) {
			                result[i] = result[j];
			            }
			            result[j] = arr[i];
			        }

			        return result;
			    }

			    /**
			     * Returns the values that appear in a sequence, with duplicates eliminated.
			     * @param {Array} arr - An array or sequence of values
			     * @returns {Array} - sequence of distinct values
			     */
			    function distinct(arr) {
			        // undefined inputs always return undefined
			        if (typeof arr === 'undefined') {
			            return undefined;
			        }

			        if(!Array.isArray(arr) || arr.length <= 1) {
			            return arr;
			        }

			        var results = isSequence(arr) ? createSequence() : [];

			        for(var ii = 0; ii < arr.length; ii++) {
			            var value = arr[ii];
			            // is this value already in the result sequence?
			            var includes = false;
			            for(var jj = 0; jj < results.length; jj++) {
			                if (deepEquals(value, results[jj])) {
			                    includes = true;
			                    break;
			                }
			            }
			            if(!includes) {
			                results.push(value);
			            }
			        }
			        return results;
			    }

			    /**
			     * Applies a predicate function to each key/value pair in an object, and returns an object containing
			     * only the key/value pairs that passed the predicate
			     *
			     * @param {object} arg - the object to be sifted
			     * @param {object} func - the predicate function (lambda or native)
			     * @returns {object} - sifted object
			     */
			    function* sift(arg, func) {
			        var result = {};

			        for (var item in arg) {
			            var entry = arg[item];
			            var func_args = hofFuncArgs(func, entry, item, arg);
			            // invoke func
			            var res = yield* func.apply(this, func_args);
			            if (boolean(res)) {
			                result[item] = entry;
			            }
			        }

			        // empty objects should be changed to undefined
			        if (Object.keys(result).length === 0) {
			            result = undefined;
			        }

			        return result;
			    }

			    return {
			        sum, count, max, min, average,
			        string, substring, substringBefore, substringAfter, lowercase, uppercase, length, trim, pad,
			        match, contains, replace, split, join,
			        formatNumber, formatBase, number, floor, ceil, round, abs, sqrt, power, random,
			        boolean, not,
			        map, zip, filter, single, foldLeft, sift,
			        keys, lookup, append, exists, spread, merge, reverse, each, error, assert, type, sort, shuffle, distinct,
			        base64encode, base64decode,  encodeUrlComponent, encodeUrl, decodeUrlComponent, decodeUrl
			    };
			})();

			module.exports = functions;

			}).call(this);}).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
			},{"./utils":6}],3:[function(require,module,exports){
			/**
			 * © Copyright IBM Corp. 2016, 2017 All Rights Reserved
			 *   Project name: JSONata
			 *   This project is licensed under the MIT License, see LICENSE
			 */

			/**
			 * @module JSONata
			 * @description JSON query and transformation language
			 */

			var datetime = require('./datetime');
			var fn = require('./functions');
			var utils = require('./utils');
			var parser = require('./parser');
			var parseSignature = require('./signature');

			/**
			 * jsonata
			 * @function
			 * @param {Object} expr - JSONata expression
			 * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
			 */
			var jsonata = (function() {

			    var isNumeric = utils.isNumeric;
			    var isArrayOfStrings = utils.isArrayOfStrings;
			    var isArrayOfNumbers = utils.isArrayOfNumbers;
			    var createSequence = utils.createSequence;
			    var isSequence = utils.isSequence;
			    var isFunction = utils.isFunction;
			    var isLambda = utils.isLambda;
			    var isIterable = utils.isIterable;
			    var getFunctionArity = utils.getFunctionArity;
			    var isDeepEqual = utils.isDeepEqual;

			    // Start of Evaluator code

			    var staticFrame = createFrame(null);

			    /**
			     * Evaluate expression against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluate(expr, input, environment) {
			        var result;

			        var entryCallback = environment.lookup('__evaluate_entry');
			        if(entryCallback) {
			            entryCallback(expr, input, environment);
			        }

			        switch (expr.type) {
			            case 'path':
			                result = yield * evaluatePath(expr, input, environment);
			                break;
			            case 'binary':
			                result = yield * evaluateBinary(expr, input, environment);
			                break;
			            case 'unary':
			                result = yield * evaluateUnary(expr, input, environment);
			                break;
			            case 'name':
			                result = evaluateName(expr, input);
			                break;
			            case 'string':
			            case 'number':
			            case 'value':
			                result = evaluateLiteral(expr);
			                break;
			            case 'wildcard':
			                result = evaluateWildcard(expr, input);
			                break;
			            case 'descendant':
			                result = evaluateDescendants(expr, input);
			                break;
			            case 'parent':
			                result = environment.lookup(expr.slot.label);
			                break;
			            case 'condition':
			                result = yield * evaluateCondition(expr, input, environment);
			                break;
			            case 'block':
			                result = yield * evaluateBlock(expr, input, environment);
			                break;
			            case 'bind':
			                result = yield * evaluateBindExpression(expr, input, environment);
			                break;
			            case 'regex':
			                result = evaluateRegex(expr);
			                break;
			            case 'function':
			                result = yield * evaluateFunction(expr, input, environment);
			                break;
			            case 'variable':
			                result = evaluateVariable(expr, input, environment);
			                break;
			            case 'lambda':
			                result = evaluateLambda(expr, input, environment);
			                break;
			            case 'partial':
			                result = yield * evaluatePartialApplication(expr, input, environment);
			                break;
			            case 'apply':
			                result = yield * evaluateApplyExpression(expr, input, environment);
			                break;
			            case 'transform':
			                result = evaluateTransformExpression(expr, input, environment);
			                break;
			        }

			        if(environment.async &&
			            (typeof result === 'undefined' || result === null || typeof result.then !== 'function')) {
			            result = Promise.resolve(result);
			        }
			        if(environment.async && typeof result.then === 'function' && expr.nextFunction && typeof result[expr.nextFunction] === 'function') ; else {
			            result = yield result;
			        }

			        if (Object.prototype.hasOwnProperty.call(expr, 'predicate')) {
			            for(var ii = 0; ii < expr.predicate.length; ii++) {
			                result = yield * evaluateFilter(expr.predicate[ii].expr, result, environment);
			            }
			        }

			        if (expr.type !== 'path' && Object.prototype.hasOwnProperty.call(expr, 'group')) {
			            result = yield * evaluateGroupExpression(expr.group, result, environment);
			        }

			        var exitCallback = environment.lookup('__evaluate_exit');
			        if(exitCallback) {
			            exitCallback(expr, input, environment, result);
			        }

			        if(result && isSequence(result) && !result.tupleStream) {
			            if(expr.keepArray) {
			                result.keepSingleton = true;
			            }
			            if(result.length === 0) {
			                result = undefined;
			            } else if(result.length === 1) {
			                result =  result.keepSingleton ? result : result[0];
			            }

			        }

			        return result;
			    }

			    /**
			     * Evaluate path expression against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluatePath(expr, input, environment) {
			        var inputSequence;
			        // expr is an array of steps
			        // if the first step is a variable reference ($...), including root reference ($$),
			        //   then the path is absolute rather than relative
			        if (Array.isArray(input) && expr.steps[0].type !== 'variable') {
			            inputSequence = input;
			        } else {
			            // if input is not an array, make it so
			            inputSequence = createSequence(input);
			        }

			        var resultSequence;
			        var isTupleStream = false;
			        var tupleBindings = undefined;

			        // evaluate each step in turn
			        for(var ii = 0; ii < expr.steps.length; ii++) {
			            var step = expr.steps[ii];

			            if(step.tuple) {
			                isTupleStream = true;
			            }

			            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)
			            if(ii === 0 && step.consarray) {
			                resultSequence = yield * evaluate(step, inputSequence, environment);
			            } else {
			                if(isTupleStream) {
			                    tupleBindings = yield * evaluateTupleStep(step, inputSequence, tupleBindings, environment);
			                } else {
			                    resultSequence = yield * evaluateStep(step, inputSequence, environment, ii === expr.steps.length - 1);
			                }
			            }

			            if (!isTupleStream && (typeof resultSequence === 'undefined' || resultSequence.length === 0)) {
			                break;
			            }

			            if(typeof step.focus === 'undefined') {
			                inputSequence = resultSequence;
			            }

			        }

			        if(isTupleStream) {
			            if(expr.tuple) {
			                // tuple stream is carrying ancestry information - keep this
			                resultSequence = tupleBindings;
			            } else {
			                resultSequence = createSequence();
			                for (ii = 0; ii < tupleBindings.length; ii++) {
			                    resultSequence.push(tupleBindings[ii]['@']);
			                }
			            }
			        }

			        if(expr.keepSingletonArray) {
			            // if the array is explicitly constructed in the expression and marked to promote singleton sequences to array
			            if(Array.isArray(resultSequence) && resultSequence.cons && !resultSequence.sequence) {
			                resultSequence = createSequence(resultSequence);
			            }
			            resultSequence.keepSingleton = true;
			        }

			        if (expr.hasOwnProperty('group')) {
			            resultSequence = yield* evaluateGroupExpression(expr.group, isTupleStream ? tupleBindings : resultSequence, environment);
			        }

			        return resultSequence;
			    }

			    function createFrameFromTuple(environment, tuple) {
			        var frame = createFrame(environment);
			        for(const prop in tuple) {
			            frame.bind(prop, tuple[prop]);
			        }
			        return frame;
			    }

			    /**
			     * Evaluate a step within a path
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @param {boolean} lastStep - flag the last step in a path
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateStep(expr, input, environment, lastStep) {
			        var result;
			        if(expr.type === 'sort') {
			             result = yield* evaluateSortExpression(expr, input, environment);
			             if(expr.stages) {
			                 result = yield* evaluateStages(expr.stages, result, environment);
			             }
			             return result;
			        }

			        result = createSequence();

			        for(var ii = 0; ii < input.length; ii++) {
			            var res = yield * evaluate(expr, input[ii], environment);
			            if(expr.stages) {
			                for(var ss = 0; ss < expr.stages.length; ss++) {
			                    res = yield* evaluateFilter(expr.stages[ss].expr, res, environment);
			                }
			            }
			            if(typeof res !== 'undefined') {
			                result.push(res);
			            }
			        }

			        var resultSequence = createSequence();
			        if(lastStep && result.length === 1 && Array.isArray(result[0]) && !isSequence(result[0])) {
			            resultSequence = result[0];
			        } else {
			            // flatten the sequence
			            result.forEach(function(res) {
			                if (!Array.isArray(res) || res.cons) {
			                    // it's not an array - just push into the result sequence
			                    resultSequence.push(res);
			                } else {
			                    // res is a sequence - flatten it into the parent sequence
			                    res.forEach(val => resultSequence.push(val));
			                }
			            });
			        }

			        return resultSequence;
			    }

			    function* evaluateStages(stages, input, environment) {
			        var result = input;
			        for(var ss = 0; ss < stages.length; ss++) {
			            var stage = stages[ss];
			            switch(stage.type) {
			                case 'filter':
			                    result = yield * evaluateFilter(stage.expr, result, environment);
			                    break;
			                case 'index':
			                    for(var ee = 0; ee < result.length; ee++) {
			                        var tuple = result[ee];
			                        tuple[stage.value] = ee;
			                    }
			                    break;
			            }
			        }
			        return result;
			    }

			    /**
			     * Evaluate a step within a path
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} tupleBindings - The tuple stream
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateTupleStep(expr, input, tupleBindings, environment) {
			        var result;
			        if(expr.type === 'sort') {
			            if(tupleBindings) {
			                result = yield* evaluateSortExpression(expr, tupleBindings, environment);
			            } else {
			                var sorted = yield* evaluateSortExpression(expr, input, environment);
			                result = createSequence();
			                result.tupleStream = true;
			                for(var ss = 0; ss < sorted.length; ss++) {
			                    var tuple = {'@': sorted[ss]};
			                    tuple[expr.index] = ss;
			                    result.push(tuple);
			                }
			            }
			            if(expr.stages) {
			                result = yield* evaluateStages(expr.stages, result, environment);
			            }
			            return result;
			        }

			        result = createSequence();
			        result.tupleStream = true;
			        var stepEnv = environment;
			        if(tupleBindings === undefined) {
			            tupleBindings = input.map(item => { return {'@': item} });
			        }

			        for(var ee = 0; ee < tupleBindings.length; ee++) {
			            stepEnv = createFrameFromTuple(environment, tupleBindings[ee]);
			            var res = yield* evaluate(expr, tupleBindings[ee]['@'], stepEnv);
			            // res is the binding sequence for the output tuple stream
			            if(typeof res !== 'undefined') {
			                if (!Array.isArray(res)) {
			                    res = [res];
			                }
			                for (var bb = 0; bb < res.length; bb++) {
			                    tuple = {};
			                    Object.assign(tuple, tupleBindings[ee]);
			                    if(res.tupleStream) {
			                        Object.assign(tuple, res[bb]);
			                    } else {
			                        if (expr.focus) {
			                            tuple[expr.focus] = res[bb];
			                            tuple['@'] = tupleBindings[ee]['@'];
			                        } else {
			                            tuple['@'] = res[bb];
			                        }
			                        if (expr.index) {
			                            tuple[expr.index] = bb;
			                        }
			                        if (expr.ancestor) {
			                            tuple[expr.ancestor.label] = tupleBindings[ee]['@'];
			                        }
			                    }
			                    result.push(tuple);
			                }
			            }
			        }

			        if(expr.stages) {
			            result = yield * evaluateStages(expr.stages, result, environment);
			        }

			        return result;
			    }

			    /**
			     * Apply filter predicate to input data
			     * @param {Object} predicate - filter expression
			     * @param {Object} input - Input data to apply predicates against
			     * @param {Object} environment - Environment
			     * @returns {*} Result after applying predicates
			     */
			    function* evaluateFilter(predicate, input, environment) {
			        var results = createSequence();
			        if( input && input.tupleStream) {
			            results.tupleStream = true;
			        }
			        if (!Array.isArray(input)) {
			            input = createSequence(input);
			        }
			        if (predicate.type === 'number') {
			            var index = Math.floor(predicate.value);  // round it down
			            if (index < 0) {
			                // count in from end of array
			                index = input.length + index;
			            }
			            var item = input[index];
			            if(typeof item !== 'undefined') {
			                if(Array.isArray(item)) {
			                    results = item;
			                } else {
			                    results.push(item);
			                }
			            }
			        } else {
			            for (index = 0; index < input.length; index++) {
			                var item = input[index];
			                var context = item;
			                var env = environment;
			                if(input.tupleStream) {
			                    context = item['@'];
			                    env = createFrameFromTuple(environment, item);
			                }
			                var res = yield* evaluate(predicate, context, env);
			                if (isNumeric(res)) {
			                    res = [res];
			                }
			                if (isArrayOfNumbers(res)) {
			                    res.forEach(function (ires) {
			                        // round it down
			                        var ii = Math.floor(ires);
			                        if (ii < 0) {
			                            // count in from end of array
			                            ii = input.length + ii;
			                        }
			                        if (ii === index) {
			                            results.push(item);
			                        }
			                    });
			                } else if (fn.boolean(res)) { // truthy
			                    results.push(item);
			                }
			            }
			        }
			        return results;
			    }

			    /**
			     * Evaluate binary expression against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function * evaluateBinary(expr, input, environment) {
			        var result;
			        var lhs = yield * evaluate(expr.lhs, input, environment);
			        var op = expr.value;

			        //defer evaluation of RHS to allow short-circuiting
			        var evalrhs = function*(){return yield * evaluate(expr.rhs, input, environment);};
			        if (op === "and" || op === "or") {
			            try {
			                return yield * evaluateBooleanExpression(lhs, evalrhs, op);
			            } catch(err) {
			                err.position = expr.position;
			                err.token = op;
			                throw err;
			            }
			        }

			        var rhs = yield * evalrhs();
			        try {
			            switch (op) {
			                case '+':
			                case '-':
			                case '*':
			                case '/':
			                case '%':
			                    result = evaluateNumericExpression(lhs, rhs, op);
			                    break;
			                case '=':
			                case '!=':
			                    result = evaluateEqualityExpression(lhs, rhs, op);
			                    break;
			                case '<':
			                case '<=':
			                case '>':
			                case '>=':
			                    result = evaluateComparisonExpression(lhs, rhs, op);
			                    break;
			                case '&':
			                    result = evaluateStringConcat(lhs, rhs);
			                    break;
			                case '..':
			                    result = evaluateRangeExpression(lhs, rhs);
			                    break;
			                case 'in':
			                    result = evaluateIncludesExpression(lhs, rhs);
			                    break;
			            }
			        } catch(err) {
			            err.position = expr.position;
			            err.token = op;
			            throw err;
			        }
			        return result;
			    }

			    /**
			     * Evaluate unary expression against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateUnary(expr, input, environment) {
			        var result;

			        switch (expr.value) {
			            case '-':
			                result = yield * evaluate(expr.expression, input, environment);
			                if(typeof result === 'undefined') {
			                    result = undefined;
			                } else if (isNumeric(result)) {
			                    result = -result;
			                } else {
			                    throw {
			                        code: "D1002",
			                        stack: (new Error()).stack,
			                        position: expr.position,
			                        token: expr.value,
			                        value: result
			                    };
			                }
			                break;
			            case '[':
			                // array constructor - evaluate each item
			                result = [];
			                for(var ii = 0; ii < expr.expressions.length; ii++) {
			                    var item = expr.expressions[ii];
			                    var value = yield * evaluate(item, input, environment);
			                    if (typeof value !== 'undefined') {
			                        if(item.value === '[') {
			                            result.push(value);
			                        } else {
			                            result = fn.append(result, value);
			                        }
			                    }
			                }
			                if(expr.consarray) {
			                    Object.defineProperty(result, 'cons', {
			                        enumerable: false,
			                        configurable: false,
			                        value: true
			                    });
			                }
			                break;
			            case '{':
			                // object constructor - apply grouping
			                result = yield * evaluateGroupExpression(expr, input, environment);
			                break;

			        }
			        return result;
			    }

			    /**
			     * Evaluate name object against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function evaluateName(expr, input, environment) {
			        // lookup the 'name' item in the input
			        return fn.lookup(input, expr.value);
			    }

			    /**
			     * Evaluate literal against input data
			     * @param {Object} expr - JSONata expression
			     * @returns {*} Evaluated input data
			     */
			    function evaluateLiteral(expr) {
			        return expr.value;
			    }

			    /**
			     * Evaluate wildcard against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @returns {*} Evaluated input data
			     */
			    function evaluateWildcard(expr, input) {
			        var results = createSequence();
			        if (Array.isArray(input) && input.outerWrapper && input.length > 0) {
			            input = input[0];
			        }
			        if (input !== null && typeof input === 'object') {
			            Object.keys(input).forEach(function (key) {
			                var value = input[key];
			                if(Array.isArray(value)) {
			                    value = flatten(value);
			                    results = fn.append(results, value);
			                } else {
			                    results.push(value);
			                }
			            });
			        }

			        //        result = normalizeSequence(results);
			        return results;
			    }

			    /**
			     * Returns a flattened array
			     * @param {Array} arg - the array to be flatten
			     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []
			     * @returns {Array} - the flattened array
			     */
			    function flatten(arg, flattened) {
			        if(typeof flattened === 'undefined') {
			            flattened = [];
			        }
			        if(Array.isArray(arg)) {
			            arg.forEach(function (item) {
			                flatten(item, flattened);
			            });
			        } else {
			            flattened.push(arg);
			        }
			        return flattened;
			    }

			    /**
			     * Evaluate descendants against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @returns {*} Evaluated input data
			     */
			    function evaluateDescendants(expr, input) {
			        var result;
			        var resultSequence = createSequence();
			        if (typeof input !== 'undefined') {
			            // traverse all descendants of this object/array
			            recurseDescendants(input, resultSequence);
			            if (resultSequence.length === 1) {
			                result = resultSequence[0];
			            } else {
			                result = resultSequence;
			            }
			        }
			        return result;
			    }

			    /**
			     * Recurse through descendants
			     * @param {Object} input - Input data
			     * @param {Object} results - Results
			     */
			    function recurseDescendants(input, results) {
			        // this is the equivalent of //* in XPath
			        if (!Array.isArray(input)) {
			            results.push(input);
			        }
			        if (Array.isArray(input)) {
			            input.forEach(function (member) {
			                recurseDescendants(member, results);
			            });
			        } else if (input !== null && typeof input === 'object') {
			            Object.keys(input).forEach(function (key) {
			                recurseDescendants(input[key], results);
			            });
			        }
			    }

			    /**
			     * Evaluate numeric expression against input data
			     * @param {Object} lhs - LHS value
			     * @param {Object} rhs - RHS value
			     * @param {Object} op - opcode
			     * @returns {*} Result
			     */
			    function evaluateNumericExpression(lhs, rhs, op) {
			        var result;

			        if (typeof lhs !== 'undefined' && !isNumeric(lhs)) {
			            throw {
			                code: "T2001",
			                stack: (new Error()).stack,
			                value: lhs
			            };
			        }
			        if (typeof rhs !== 'undefined' && !isNumeric(rhs)) {
			            throw {
			                code: "T2002",
			                stack: (new Error()).stack,
			                value: rhs
			            };
			        }

			        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
			            // if either side is undefined, the result is undefined
			            return result;
			        }

			        switch (op) {
			            case '+':
			                result = lhs + rhs;
			                break;
			            case '-':
			                result = lhs - rhs;
			                break;
			            case '*':
			                result = lhs * rhs;
			                break;
			            case '/':
			                result = lhs / rhs;
			                break;
			            case '%':
			                result = lhs % rhs;
			                break;
			        }
			        return result;
			    }

			    /**
			     * Evaluate equality expression against input data
			     * @param {Object} lhs - LHS value
			     * @param {Object} rhs - RHS value
			     * @param {Object} op - opcode
			     * @returns {*} Result
			     */
			    function evaluateEqualityExpression(lhs, rhs, op) {
			        var result;

			        // type checks
			        var ltype = typeof lhs;
			        var rtype = typeof rhs;

			        if (ltype === 'undefined' || rtype === 'undefined') {
			            // if either side is undefined, the result is false
			            return false;
			        }

			        switch (op) {
			            case '=':
			                result = isDeepEqual(lhs, rhs);
			                break;
			            case '!=':
			                result = !isDeepEqual(lhs, rhs);
			                break;
			        }
			        return result;
			    }

			    /**
			     * Evaluate comparison expression against input data
			     * @param {Object} lhs - LHS value
			     * @param {Object} rhs - RHS value
			     * @param {Object} op - opcode
			     * @returns {*} Result
			     */
			    function evaluateComparisonExpression(lhs, rhs, op) {
			        var result;

			        // type checks
			        var ltype = typeof lhs;
			        var rtype = typeof rhs;

			        var lcomparable = (ltype === 'undefined' || ltype === 'string' || ltype === 'number');
			        var rcomparable = (rtype === 'undefined' || rtype === 'string' || rtype === 'number');

			        // if either aa or bb are not comparable (string or numeric) values, then throw an error
			        if (!lcomparable || !rcomparable) {
			            throw {
			                code: "T2010",
			                stack: (new Error()).stack,
			                value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs
			            };
			        }

			        // if either side is undefined, the result is undefined
			        if (ltype === 'undefined' || rtype === 'undefined') {
			            return undefined;
			        }

			        //if aa and bb are not of the same type
			        if (ltype !== rtype) {
			            throw {
			                code: "T2009",
			                stack: (new Error()).stack,
			                value: lhs,
			                value2: rhs
			            };
			        }

			        switch (op) {
			            case '<':
			                result = lhs < rhs;
			                break;
			            case '<=':
			                result = lhs <= rhs;
			                break;
			            case '>':
			                result = lhs > rhs;
			                break;
			            case '>=':
			                result = lhs >= rhs;
			                break;
			        }
			        return result;
			    }

			    /**
			     * Inclusion operator - in
			     *
			     * @param {Object} lhs - LHS value
			     * @param {Object} rhs - RHS value
			     * @returns {boolean} - true if lhs is a member of rhs
			     */
			    function evaluateIncludesExpression(lhs, rhs) {
			        var result = false;

			        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
			            // if either side is undefined, the result is false
			            return false;
			        }

			        if(!Array.isArray(rhs)) {
			            rhs = [rhs];
			        }

			        for(var i = 0; i < rhs.length; i++) {
			            if(rhs[i] === lhs) {
			                result = true;
			                break;
			            }
			        }

			        return result;
			    }

			    /**
			     * Evaluate boolean expression against input data
			     * @param {Object} lhs - LHS value
			     * @param {Function} evalrhs - function to evaluate RHS value
			     * @param {Object} op - opcode
			     * @returns {*} Result
			     */
			    function * evaluateBooleanExpression(lhs, evalrhs, op) {
			        var result;

			        var lBool = boolize(lhs);

			        switch (op) {
			            case 'and':
			                result = lBool && boolize(yield * evalrhs());
			                break;
			            case 'or':
			                result = lBool || boolize(yield * evalrhs());
			                break;
			        }
			        return result;
			    }

			    function boolize(value) {
			        var booledValue = fn.boolean(value);
			        return typeof booledValue === 'undefined' ? false : booledValue;
			    }

			    /**
			     * Evaluate string concatenation against input data
			     * @param {Object} lhs - LHS value
			     * @param {Object} rhs - RHS value
			     * @returns {string|*} Concatenated string
			     */
			    function evaluateStringConcat(lhs, rhs) {
			        var result;

			        var lstr = '';
			        var rstr = '';
			        if (typeof lhs !== 'undefined') {
			            lstr = fn.string(lhs);
			        }
			        if (typeof rhs !== 'undefined') {
			            rstr = fn.string(rhs);
			        }

			        result = lstr.concat(rstr);
			        return result;
			    }

			    /**
			     * Evaluate group expression against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {{}} Evaluated input data
			     */
			    function* evaluateGroupExpression(expr, input, environment) {
			        var result = {};
			        var groups = {};
			        var reduce = input && input.tupleStream ? true : false;
			        // group the input sequence by 'key' expression
			        if (!Array.isArray(input)) {
			            input = createSequence(input);
			        }
			        // if the array is empty, add an undefined entry to enable literal JSON object to be generated
			        if (input.length === 0) {
			            input.push(undefined);
			        }

			        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {
			            var item = input[itemIndex];
			            var env = reduce ? createFrameFromTuple(environment, item) : environment;
			            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
			                var pair = expr.lhs[pairIndex];
			                var key = yield * evaluate(pair[0], reduce ? item['@'] : item, env);
			                // key has to be a string
			                if (typeof  key !== 'string' && key !== undefined) {
			                    throw {
			                        code: "T1003",
			                        stack: (new Error()).stack,
			                        position: expr.position,
			                        value: key
			                    };
			                }

			                if (key !== undefined) {
			                    var entry = {data: item, exprIndex: pairIndex};
			                    if (groups.hasOwnProperty(key)) {
			                        // a value already exists in this slot
			                        if(groups[key].exprIndex !== pairIndex) {
			                            // this key has been generated by another expression in this group
			                            // when multiple key expressions evaluate to the same key, then error D1009 must be thrown
			                            throw {
			                                code: "D1009",
			                                stack: (new Error()).stack,
			                                position: expr.position,
			                                value: key
			                            };
			                        }

			                        // append it as an array
			                        groups[key].data = fn.append(groups[key].data, item);
			                    } else {
			                        groups[key] = entry;
			                    }
			                }
			            }
			        }

			        // iterate over the groups to evaluate the 'value' expression
			        for (key in groups) {
			            entry = groups[key];
			            var context = entry.data;
			            var env = environment;
			            if (reduce) {
			                var tuple = reduceTupleStream(entry.data);
			                context = tuple['@'];
			                delete tuple['@'];
			                env = createFrameFromTuple(environment, tuple);
			            }
			            var value = yield * evaluate(expr.lhs[entry.exprIndex][1], context, env);
			            if(typeof value !== 'undefined') {
			                result[key] = value;
			            }
			        }

			        return result;
			    }

			    function reduceTupleStream(tupleStream) {
			        if(!Array.isArray(tupleStream)) {
			            return tupleStream;
			        }
			        var result = {};
			        Object.assign(result, tupleStream[0]);
			        for(var ii = 1; ii < tupleStream.length; ii++) {
			            for(const prop in tupleStream[ii]) {
			                result[prop] = fn.append(result[prop], tupleStream[ii][prop]);
			            }
			        }
			        return result;
			    }

			    /**
			     * Evaluate range expression against input data
			     * @param {Object} lhs - LHS value
			     * @param {Object} rhs - RHS value
			     * @returns {Array} Resultant array
			     */
			    function evaluateRangeExpression(lhs, rhs) {
			        var result;

			        if (typeof lhs !== 'undefined' && !Number.isInteger(lhs)) {
			            throw {
			                code: "T2003",
			                stack: (new Error()).stack,
			                value: lhs
			            };
			        }
			        if (typeof rhs !== 'undefined' && !Number.isInteger(rhs)) {
			            throw {
			                code: "T2004",
			                stack: (new Error()).stack,
			                value: rhs
			            };
			        }

			        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
			            // if either side is undefined, the result is undefined
			            return result;
			        }

			        if (lhs > rhs) {
			            // if the lhs is greater than the rhs, return undefined
			            return result;
			        }

			        // limit the size of the array to ten million entries (1e7)
			        // this is an implementation defined limit to protect against
			        // memory and performance issues.  This value may increase in the future.
			        var size = rhs - lhs + 1;
			        if(size > 1e7) {
			            throw {
			                code: "D2014",
			                stack: (new Error()).stack,
			                value: size
			            };
			        }

			        result = new Array(size);
			        for (var item = lhs, index = 0; item <= rhs; item++, index++) {
			            result[index] = item;
			        }
			        result.sequence = true;
			        return result;
			    }

			    /**
			     * Evaluate bind expression against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateBindExpression(expr, input, environment) {
			        // The RHS is the expression to evaluate
			        // The LHS is the name of the variable to bind to - should be a VARIABLE token (enforced by parser)
			        var value = yield * evaluate(expr.rhs, input, environment);
			        environment.bind(expr.lhs.value, value);
			        return value;
			    }

			    /**
			     * Evaluate condition against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateCondition(expr, input, environment) {
			        var result;
			        var condition = yield * evaluate(expr.condition, input, environment);
			        if (fn.boolean(condition)) {
			            result = yield * evaluate(expr.then, input, environment);
			        } else if (typeof expr.else !== 'undefined') {
			            result = yield * evaluate(expr.else, input, environment);
			        }
			        return result;
			    }

			    /**
			     * Evaluate block against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateBlock(expr, input, environment) {
			        var result;
			        // create a new frame to limit the scope of variable assignments
			        // TODO, only do this if the post-parse stage has flagged this as required
			        var frame = createFrame(environment);
			        // invoke each expression in turn
			        // only return the result of the last one
			        for(var ii = 0; ii < expr.expressions.length; ii++) {
			            result = yield * evaluate(expr.expressions[ii], input, frame);
			        }

			        return result;
			    }

			    /**
			     * Prepare a regex
			     * @param {Object} expr - expression containing regex
			     * @returns {Function} Higher order function representing prepared regex
			     */
			    function evaluateRegex(expr) {
			        var re = new jsonata.RegexEngine(expr.value);
			        var closure = function(str, fromIndex) {
			            var result;
			            re.lastIndex = fromIndex || 0;
			            var match = re.exec(str);
			            if(match !== null) {
			                result = {
			                    match: match[0],
			                    start: match.index,
			                    end: match.index + match[0].length,
			                    groups: []
			                };
			                if(match.length > 1) {
			                    for(var i = 1; i < match.length; i++) {
			                        result.groups.push(match[i]);
			                    }
			                }
			                result.next = function() {
			                    if(re.lastIndex >= str.length) {
			                        return undefined;
			                    } else {
			                        var next = closure(str, re.lastIndex);
			                        if(next && next.match === '') {
			                            // matches zero length string; this will never progress
			                            throw {
			                                code: "D1004",
			                                stack: (new Error()).stack,
			                                position: expr.position,
			                                value: expr.value.source
			                            };
			                        }
			                        return next;
			                    }
			                };
			            }

			            return result;
			        };
			        return closure;
			    }

			    /**
			     * Evaluate variable against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function evaluateVariable(expr, input, environment) {
			        // lookup the variable value in the environment
			        var result;
			        // if the variable name is empty string, then it refers to context value
			        if (expr.value === '') {
			            result = input && input.outerWrapper ? input[0] : input;
			        } else {
			            result = environment.lookup(expr.value);
			        }
			        return result;
			    }

			    /**
			     * sort / order-by operator
			     * @param {Object} expr - AST for operator
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Ordered sequence
			     */
			    function* evaluateSortExpression(expr, input, environment) {
			        var result;

			        // evaluate the lhs, then sort the results in order according to rhs expression
			        //var lhs = yield * evaluate(expr.lhs, input, environment);
			        var lhs = input;
			        var isTupleSort = input.tupleStream ? true : false;

			        // sort the lhs array
			        // use comparator function
			        var comparator = function*(a, b) { // eslint-disable-line require-yield
			            // expr.terms is an array of order-by in priority order
			            var comp = 0;
			            for(var index = 0; comp === 0 && index < expr.terms.length; index++) {
			                var term = expr.terms[index];
			                //evaluate the sort term in the context of a
			                var context = a;
			                var env = environment;
			                if(isTupleSort) {
			                    context = a['@'];
			                    env = createFrameFromTuple(environment, a);
			                }
			                var aa = yield * evaluate(term.expression, context, env);
			                //evaluate the sort term in the context of b
			                context = b;
			                env = environment;
			                if(isTupleSort) {
			                    context = b['@'];
			                    env = createFrameFromTuple(environment, b);
			                }
			                var bb = yield * evaluate(term.expression, context, env);

			                // type checks
			                var atype = typeof aa;
			                var btype = typeof bb;
			                // undefined should be last in sort order
			                if(atype === 'undefined') {
			                    // swap them, unless btype is also undefined
			                    comp = (btype === 'undefined') ? 0 : 1;
			                    continue;
			                }
			                if(btype === 'undefined') {
			                    comp = -1;
			                    continue;
			                }

			                // if aa or bb are not string or numeric values, then throw an error
			                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {
			                    throw {
			                        code: "T2008",
			                        stack: (new Error()).stack,
			                        position: expr.position,
			                        value: !(atype === 'string' || atype === 'number') ? aa : bb
			                    };
			                }

			                //if aa and bb are not of the same type
			                if(atype !== btype) {
			                    throw {
			                        code: "T2007",
			                        stack: (new Error()).stack,
			                        position: expr.position,
			                        value: aa,
			                        value2: bb
			                    };
			                }
			                if(aa === bb) {
			                    // both the same - move on to next term
			                    continue;
			                } else if (aa < bb) {
			                    comp = -1;
			                } else {
			                    comp = 1;
			                }
			                if(term.descending === true) {
			                    comp = -comp;
			                }
			            }
			            // only swap a & b if comp equals 1
			            return comp === 1;
			        };

			        var focus = {
			            environment: environment,
			            input: input
			        };
			        // the `focus` is passed in as the `this` for the invoked function
			        result = yield * fn.sort.apply(focus, [lhs, comparator]);

			        return result;
			    }

			    /**
			     * create a transformer function
			     * @param {Object} expr - AST for operator
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} tranformer function
			     */
			    function evaluateTransformExpression(expr, input, environment) {
			        // create a function to implement the transform definition
			        var transformer = function*(obj) { // signature <(oa):o>
			            // undefined inputs always return undefined
			            if(typeof obj === 'undefined') {
			                return undefined;
			            }

			            // this function returns a copy of obj with changes specified by the pattern/operation
			            var cloneFunction = environment.lookup('clone');
			            if(!isFunction(cloneFunction)) {
			                // throw type error
			                throw {
			                    code: "T2013",
			                    stack: (new Error()).stack,
			                    position: expr.position
			                };
			            }
			            var result = yield * apply(cloneFunction, [obj], null, environment);
			            var matches = yield * evaluate(expr.pattern, result, environment);
			            if(typeof matches !== 'undefined') {
			                if(!Array.isArray(matches)) {
			                    matches = [matches];
			                }
			                for(var ii = 0; ii < matches.length; ii++) {
			                    var match = matches[ii];
			                    if (match && (match.isPrototypeOf(result) || match instanceof Object.constructor)) {
			                        throw {
			                            code: "D1010",
			                            stack: (new Error()).stack,
			                            position: expr.position
			                        };
			                    }
			                    // evaluate the update value for each match
			                    var update = yield * evaluate(expr.update, match, environment);
			                    // update must be an object
			                    var updateType = typeof update;
			                    if(updateType !== 'undefined') {
			                        if(updateType !== 'object' || update === null || Array.isArray(update)) {
			                            // throw type error
			                            throw {
			                                code: "T2011",
			                                stack: (new Error()).stack,
			                                position: expr.update.position,
			                                value: update
			                            };
			                        }
			                        // merge the update
			                        for(var prop in update) {
			                            match[prop] = update[prop];
			                        }
			                    }

			                    // delete, if specified, must be an array of strings (or single string)
			                    if(typeof expr.delete !== 'undefined') {
			                        var deletions = yield * evaluate(expr.delete, match, environment);
			                        if(typeof deletions !== 'undefined') {
			                            var val = deletions;
			                            if (!Array.isArray(deletions)) {
			                                deletions = [deletions];
			                            }
			                            if (!isArrayOfStrings(deletions)) {
			                                // throw type error
			                                throw {
			                                    code: "T2012",
			                                    stack: (new Error()).stack,
			                                    position: expr.delete.position,
			                                    value: val
			                                };
			                            }
			                            for (var jj = 0; jj < deletions.length; jj++) {
			                                if(typeof match === 'object' && match !== null) {
			                                    delete match[deletions[jj]];
			                                }
			                            }
			                        }
			                    }
			                }
			            }

			            return result;
			        };

			        return defineFunction(transformer, '<(oa):o>');
			    }

			    var chainAST = parser('function($f, $g) { function($x){ $g($f($x)) } }');

			    /**
			     * Apply the function on the RHS using the sequence on the LHS as the first argument
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateApplyExpression(expr, input, environment) {
			        var result;


			        var lhs = yield * evaluate(expr.lhs, input, environment);
			        if(expr.rhs.type === 'function') {
			            // this is a function _invocation_; invoke it with lhs expression as the first argument
			            result = yield * evaluateFunction(expr.rhs, input, environment, { context: lhs });
			        } else {
			            var func = yield * evaluate(expr.rhs, input, environment);

			            if(!isFunction(func)) {
			                throw {
			                    code: "T2006",
			                    stack: (new Error()).stack,
			                    position: expr.position,
			                    value: func
			                };
			            }

			            if(isFunction(lhs)) {
			                // this is function chaining (func1 ~> func2)
			                // λ($f, $g) { λ($x){ $g($f($x)) } }
			                var chain = yield * evaluate(chainAST, null, environment);
			                result = yield * apply(chain, [lhs, func], null, environment);
			            } else {
			                result = yield * apply(func, [lhs], null, environment);
			            }

			        }

			        return result;
			    }

			    /**
			     * Evaluate function against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluateFunction(expr, input, environment, applyto) {
			        var result;

			        // create the procedure
			        // can't assume that expr.procedure is a lambda type directly
			        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.
			        // evaluate it generically first, then check that it is a function.  Throw error if not.
			        var proc = yield * evaluate(expr.procedure, input, environment);

			        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
			            // help the user out here if they simply forgot the leading $
			            throw {
			                code: "T1005",
			                stack: (new Error()).stack,
			                position: expr.position,
			                token: expr.procedure.steps[0].value
			            };
			        }

			        var evaluatedArgs = [];
			        if(typeof applyto !== 'undefined') {
			            evaluatedArgs.push(applyto.context);
			        }
			        // eager evaluation - evaluate the arguments
			        for (var jj = 0; jj < expr.arguments.length; jj++) {
			            const arg = yield* evaluate(expr.arguments[jj], input, environment);
			            if(isFunction(arg)) {
			                // wrap this in a closure
			                const closure = function* (...params) {
			                    // invoke func
			                    return yield * apply(arg, params, null, environment);
			                };
			                closure.arity = getFunctionArity(arg);
			                evaluatedArgs.push(closure);
			            } else {
			                evaluatedArgs.push(arg);
			            }
			        }
			        // apply the procedure
			        var procName = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;
			        try {
			            if(typeof proc === 'object') {
			                proc.token = procName;
			                proc.position = expr.position;
			            }
			            result = yield * apply(proc, evaluatedArgs, input, environment);
			        } catch (err) {
			            if(!err.position) {
			                // add the position field to the error
			                err.position = expr.position;
			            }
			            if (!err.token) {
			                // and the function identifier
			                err.token = procName;
			            }
			            throw err;
			        }
			        return result;
			    }

			    /**
			     * Apply procedure or function
			     * @param {Object} proc - Procedure
			     * @param {Array} args - Arguments
			     * @param {Object} input - input
			     * @param {Object} environment - environment
			     * @returns {*} Result of procedure
			     */
			    function* apply(proc, args, input, environment) {
			        var result;
			        result = yield * applyInner(proc, args, input, environment);
			        while(isLambda(result) && result.thunk === true) {
			            // trampoline loop - this gets invoked as a result of tail-call optimization
			            // the function returned a tail-call thunk
			            // unpack it, evaluate its arguments, and apply the tail call
			            var next = yield * evaluate(result.body.procedure, result.input, result.environment);
			            if(result.body.procedure.type === 'variable') {
			                next.token = result.body.procedure.value;
			            }
			            next.position = result.body.procedure.position;
			            var evaluatedArgs = [];
			            for(var ii = 0; ii < result.body.arguments.length; ii++) {
			                evaluatedArgs.push(yield * evaluate(result.body.arguments[ii], result.input, result.environment));
			            }

			            result = yield * applyInner(next, evaluatedArgs, input, environment);
			        }
			        return result;
			    }

			    /**
			     * Apply procedure or function
			     * @param {Object} proc - Procedure
			     * @param {Array} args - Arguments
			     * @param {Object} input - input
			     * @param {Object} environment - environment
			     * @returns {*} Result of procedure
			     */
			    function* applyInner(proc, args, input, environment) {
			        var result;
			        try {
			            var validatedArgs = args;
			            if (proc) {
			                validatedArgs = validateArguments(proc.signature, args, input);
			            }

			            if (isLambda(proc)) {
			                result = yield* applyProcedure(proc, validatedArgs);
			            } else if (proc && proc._jsonata_function === true) {
			                var focus = {
			                    environment: environment,
			                    input: input
			                };
			                // the `focus` is passed in as the `this` for the invoked function
			                result = proc.implementation.apply(focus, validatedArgs);
			                // `proc.implementation` might be a generator function
			                // and `result` might be a generator - if so, yield
			                if (isIterable(result)) {
			                    result = yield* result;
			                }
			            } else if (typeof proc === 'function') {
			                // typically these are functions that are returned by the invocation of plugin functions
			                // the `input` is being passed in as the `this` for the invoked function
			                // this is so that functions that return objects containing functions can chain
			                // e.g. $func().next().next()
			                result = proc.apply(input, validatedArgs);
			                /* istanbul ignore next */
			                if (isIterable(result)) {
			                    result = yield* result;
			                }
			            } else {
			                throw {
			                    code: "T1006",
			                    stack: (new Error()).stack
			                };
			            }
			        } catch(err) {
			            if(proc) {
			                if (typeof err.token == 'undefined' && typeof proc.token !== 'undefined') {
			                    err.token = proc.token;
			                }
			                err.position = proc.position || err.position;
			            }
			            throw err;
			        }
			        return result;
			    }

			    /**
			     * Evaluate lambda against input data
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data
			     */
			    function evaluateLambda(expr, input, environment) {
			        // make a function (closure)
			        var procedure = {
			            _jsonata_lambda: true,
			            input: input,
			            environment: environment,
			            arguments: expr.arguments,
			            signature: expr.signature,
			            body: expr.body
			        };
			        if(expr.thunk === true) {
			            procedure.thunk = true;
			        }
			        procedure.apply = function*(self, args) {
			            return yield * apply(procedure, args, input, self.environment);
			        };
			        return procedure;
			    }

			    /**
			     * Evaluate partial application
			     * @param {Object} expr - JSONata expression
			     * @param {Object} input - Input data to evaluate against
			     * @param {Object} environment - Environment
			     * @returns {*} Evaluated input data
			     */
			    function* evaluatePartialApplication(expr, input, environment) {
			        // partially apply a function
			        var result;
			        // evaluate the arguments
			        var evaluatedArgs = [];
			        for(var ii = 0; ii < expr.arguments.length; ii++) {
			            var arg = expr.arguments[ii];
			            if (arg.type === 'operator' && arg.value === '?') {
			                evaluatedArgs.push(arg);
			            } else {
			                evaluatedArgs.push(yield * evaluate(arg, input, environment));
			            }
			        }
			        // lookup the procedure
			        var proc = yield * evaluate(expr.procedure, input, environment);
			        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
			            // help the user out here if they simply forgot the leading $
			            throw {
			                code: "T1007",
			                stack: (new Error()).stack,
			                position: expr.position,
			                token: expr.procedure.steps[0].value
			            };
			        }
			        if (isLambda(proc)) {
			            result = partialApplyProcedure(proc, evaluatedArgs);
			        } else if (proc && proc._jsonata_function === true) {
			            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);
			        } else if (typeof proc === 'function') {
			            result = partialApplyNativeFunction(proc, evaluatedArgs);
			        } else {
			            throw {
			                code: "T1008",
			                stack: (new Error()).stack,
			                position: expr.position,
			                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value
			            };
			        }
			        return result;
			    }

			    /**
			     * Validate the arguments against the signature validator (if it exists)
			     * @param {Function} signature - validator function
			     * @param {Array} args - function arguments
			     * @param {*} context - context value
			     * @returns {Array} - validated arguments
			     */
			    function validateArguments(signature, args, context) {
			        if(typeof signature === 'undefined') {
			            // nothing to validate
			            return args;
			        }
			        var validatedArgs = signature.validate(args, context);
			        return validatedArgs;
			    }

			    /**
			     * Apply procedure
			     * @param {Object} proc - Procedure
			     * @param {Array} args - Arguments
			     * @returns {*} Result of procedure
			     */
			    function* applyProcedure(proc, args) {
			        var result;
			        var env = createFrame(proc.environment);
			        proc.arguments.forEach(function (param, index) {
			            env.bind(param.value, args[index]);
			        });
			        if (typeof proc.body === 'function') {
			            // this is a lambda that wraps a native function - generated by partially evaluating a native
			            result = yield * applyNativeFunction(proc.body, env);
			        } else {
			            result = yield * evaluate(proc.body, proc.input, env);
			        }
			        return result;
			    }

			    /**
			     * Partially apply procedure
			     * @param {Object} proc - Procedure
			     * @param {Array} args - Arguments
			     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure
			     */
			    function partialApplyProcedure(proc, args) {
			        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters
			        var env = createFrame(proc.environment);
			        var unboundArgs = [];
			        proc.arguments.forEach(function (param, index) {
			            var arg = args[index];
			            if (arg && arg.type === 'operator' && arg.value === '?') {
			                unboundArgs.push(param);
			            } else {
			                env.bind(param.value, arg);
			            }
			        });
			        var procedure = {
			            _jsonata_lambda: true,
			            input: proc.input,
			            environment: env,
			            arguments: unboundArgs,
			            body: proc.body
			        };
			        return procedure;
			    }

			    /**
			     * Partially apply native function
			     * @param {Function} native - Native function
			     * @param {Array} args - Arguments
			     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function
			     */
			    function partialApplyNativeFunction(native, args) {
			        // create a lambda function that wraps and invokes the native function
			        // get the list of declared arguments from the native function
			        // this has to be picked out from the toString() value
			        var sigArgs = getNativeFunctionArguments(native);
			        sigArgs = sigArgs.map(function (sigArg) {
			            return '$' + sigArg.trim();
			        });
			        var body = 'function(' + sigArgs.join(', ') + '){ _ }';

			        var bodyAST = parser(body);
			        bodyAST.body = native;

			        var partial = partialApplyProcedure(bodyAST, args);
			        return partial;
			    }

			    /**
			     * Apply native function
			     * @param {Object} proc - Procedure
			     * @param {Object} env - Environment
			     * @returns {*} Result of applying native function
			     */
			    function* applyNativeFunction(proc, env) {
			        var sigArgs = getNativeFunctionArguments(proc);
			        // generate the array of arguments for invoking the function - look them up in the environment
			        var args = sigArgs.map(function (sigArg) {
			            return env.lookup(sigArg.trim());
			        });

			        var focus = {
			            environment: env
			        };
			        var result = proc.apply(focus, args);
			        if(isIterable(result)) {
			            result = yield * result;
			        }
			        return result;
			    }

			    /**
			     * Get native function arguments
			     * @param {Function} func - Function
			     * @returns {*|Array} Native function arguments
			     */
			    function getNativeFunctionArguments(func) {
			        var signature = func.toString();
			        var sigParens = /\(([^)]*)\)/.exec(signature)[1]; // the contents of the parens
			        var sigArgs = sigParens.split(',');
			        return sigArgs;
			    }

			    /**
			     * Creates a function definition
			     * @param {Function} func - function implementation in Javascript
			     * @param {string} signature - JSONata function signature definition
			     * @returns {{implementation: *, signature: *}} function definition
			     */
			    function defineFunction(func, signature) {
			        var definition = {
			            _jsonata_function: true,
			            implementation: func
			        };
			        if(typeof signature !== 'undefined') {
			            definition.signature = parseSignature(signature);
			        }
			        return definition;
			    }


			    /**
			     * parses and evaluates the supplied expression
			     * @param {string} expr - expression to evaluate
			     * @returns {*} - result of evaluating the expression
			     */
			    function* functionEval(expr, focus) {
			        // undefined inputs always return undefined
			        if(typeof expr === 'undefined') {
			            return undefined;
			        }
			        var input = this.input;
			        if(typeof focus !== 'undefined') {
			            input = focus;
			            // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input
			            if(Array.isArray(input) && !isSequence(input)) {
			                input = createSequence(input);
			                input.outerWrapper = true;
			            }
			        }

			        try {
			            var ast = parser(expr, false);
			        } catch(err) {
			            // error parsing the expression passed to $eval
			            populateMessage(err);
			            throw {
			                stack: (new Error()).stack,
			                code: "D3120",
			                value: err.message,
			                error: err
			            };
			        }
			        try {
			            var result = yield* evaluate(ast, input, this.environment);
			        } catch(err) {
			            // error evaluating the expression passed to $eval
			            populateMessage(err);
			            throw {
			                stack: (new Error()).stack,
			                code: "D3121",
			                value:err.message,
			                error: err
			            };
			        }

			        return result;
			    }

			    /**
			     * Clones an object
			     * @param {Object} arg - object to clone (deep copy)
			     * @returns {*} - the cloned object
			     */
			    function functionClone(arg) {
			        // undefined inputs always return undefined
			        if(typeof arg === 'undefined') {
			            return undefined;
			        }

			        return JSON.parse(fn.string(arg));
			    }

			    /**
			     * Create frame
			     * @param {Object} enclosingEnvironment - Enclosing environment
			     * @returns {{bind: bind, lookup: lookup}} Created frame
			     */
			    function createFrame(enclosingEnvironment) {
			        var bindings = {};
			        return {
			            bind: function (name, value) {
			                bindings[name] = value;
			            },
			            lookup: function (name) {
			                var value;
			                if(bindings.hasOwnProperty(name)) {
			                    value = bindings[name];
			                } else if (enclosingEnvironment) {
			                    value = enclosingEnvironment.lookup(name);
			                }
			                return value;
			            },
			            timestamp: enclosingEnvironment ? enclosingEnvironment.timestamp : null,
			            async: enclosingEnvironment ? enclosingEnvironment.async : false,
			            global: enclosingEnvironment ? enclosingEnvironment.global : {
			                ancestry: [ null ]
			            }
			        };
			    }

			    // Function registration
			    staticFrame.bind('sum', defineFunction(fn.sum, '<a<n>:n>'));
			    staticFrame.bind('count', defineFunction(fn.count, '<a:n>'));
			    staticFrame.bind('max', defineFunction(fn.max, '<a<n>:n>'));
			    staticFrame.bind('min', defineFunction(fn.min, '<a<n>:n>'));
			    staticFrame.bind('average', defineFunction(fn.average, '<a<n>:n>'));
			    staticFrame.bind('string', defineFunction(fn.string, '<x-b?:s>'));
			    staticFrame.bind('substring', defineFunction(fn.substring, '<s-nn?:s>'));
			    staticFrame.bind('substringBefore', defineFunction(fn.substringBefore, '<s-s:s>'));
			    staticFrame.bind('substringAfter', defineFunction(fn.substringAfter, '<s-s:s>'));
			    staticFrame.bind('lowercase', defineFunction(fn.lowercase, '<s-:s>'));
			    staticFrame.bind('uppercase', defineFunction(fn.uppercase, '<s-:s>'));
			    staticFrame.bind('length', defineFunction(fn.length, '<s-:n>'));
			    staticFrame.bind('trim', defineFunction(fn.trim, '<s-:s>'));
			    staticFrame.bind('pad', defineFunction(fn.pad, '<s-ns?:s>'));
			    staticFrame.bind('match', defineFunction(fn.match, '<s-f<s:o>n?:a<o>>'));
			    staticFrame.bind('contains', defineFunction(fn.contains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>
			    staticFrame.bind('replace', defineFunction(fn.replace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>
			    staticFrame.bind('split', defineFunction(fn.split, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>
			    staticFrame.bind('join', defineFunction(fn.join, '<a<s>s?:s>'));
			    staticFrame.bind('formatNumber', defineFunction(fn.formatNumber, '<n-so?:s>'));
			    staticFrame.bind('formatBase', defineFunction(fn.formatBase, '<n-n?:s>'));
			    staticFrame.bind('formatInteger', defineFunction(datetime.formatInteger, '<n-s:s>'));
			    staticFrame.bind('parseInteger', defineFunction(datetime.parseInteger, '<s-s:n>'));
			    staticFrame.bind('number', defineFunction(fn.number, '<(nsb)-:n>'));
			    staticFrame.bind('floor', defineFunction(fn.floor, '<n-:n>'));
			    staticFrame.bind('ceil', defineFunction(fn.ceil, '<n-:n>'));
			    staticFrame.bind('round', defineFunction(fn.round, '<n-n?:n>'));
			    staticFrame.bind('abs', defineFunction(fn.abs, '<n-:n>'));
			    staticFrame.bind('sqrt', defineFunction(fn.sqrt, '<n-:n>'));
			    staticFrame.bind('power', defineFunction(fn.power, '<n-n:n>'));
			    staticFrame.bind('random', defineFunction(fn.random, '<:n>'));
			    staticFrame.bind('boolean', defineFunction(fn.boolean, '<x-:b>'));
			    staticFrame.bind('not', defineFunction(fn.not, '<x-:b>'));
			    staticFrame.bind('map', defineFunction(fn.map, '<af>'));
			    staticFrame.bind('zip', defineFunction(fn.zip, '<a+>'));
			    staticFrame.bind('filter', defineFunction(fn.filter, '<af>'));
			    staticFrame.bind('single', defineFunction(fn.single, '<af?>'));
			    staticFrame.bind('reduce', defineFunction(fn.foldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>
			    staticFrame.bind('sift', defineFunction(fn.sift, '<o-f?:o>'));
			    staticFrame.bind('keys', defineFunction(fn.keys, '<x-:a<s>>'));
			    staticFrame.bind('lookup', defineFunction(fn.lookup, '<x-s:x>'));
			    staticFrame.bind('append', defineFunction(fn.append, '<xx:a>'));
			    staticFrame.bind('exists', defineFunction(fn.exists, '<x:b>'));
			    staticFrame.bind('spread', defineFunction(fn.spread, '<x-:a<o>>'));
			    staticFrame.bind('merge', defineFunction(fn.merge, '<a<o>:o>'));
			    staticFrame.bind('reverse', defineFunction(fn.reverse, '<a:a>'));
			    staticFrame.bind('each', defineFunction(fn.each, '<o-f:a>'));
			    staticFrame.bind('error', defineFunction(fn.error, '<s?:x>'));
			    staticFrame.bind('assert', defineFunction(fn.assert, '<bs?:x>'));
			    staticFrame.bind('type', defineFunction(fn.type, '<x:s>'));
			    staticFrame.bind('sort', defineFunction(fn.sort, '<af?:a>'));
			    staticFrame.bind('shuffle', defineFunction(fn.shuffle, '<a:a>'));
			    staticFrame.bind('distinct', defineFunction(fn.distinct, '<x:x>'));
			    staticFrame.bind('base64encode', defineFunction(fn.base64encode, '<s-:s>'));
			    staticFrame.bind('base64decode', defineFunction(fn.base64decode, '<s-:s>'));
			    staticFrame.bind('encodeUrlComponent', defineFunction(fn.encodeUrlComponent, '<s-:s>'));
			    staticFrame.bind('encodeUrl', defineFunction(fn.encodeUrl, '<s-:s>'));
			    staticFrame.bind('decodeUrlComponent', defineFunction(fn.decodeUrlComponent, '<s-:s>'));
			    staticFrame.bind('decodeUrl', defineFunction(fn.decodeUrl, '<s-:s>'));
			    staticFrame.bind('eval', defineFunction(functionEval, '<sx?:x>'));
			    staticFrame.bind('toMillis', defineFunction(datetime.toMillis, '<s-s?:n>'));
			    staticFrame.bind('fromMillis', defineFunction(datetime.fromMillis, '<n-s?s?:s>'));
			    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));

			    /**
			     * Error codes
			     *
			     * Sxxxx    - Static errors (compile time)
			     * Txxxx    - Type errors
			     * Dxxxx    - Dynamic errors (evaluate time)
			     *  01xx    - tokenizer
			     *  02xx    - parser
			     *  03xx    - regex parser
			     *  04xx    - function signature parser/evaluator
			     *  10xx    - evaluator
			     *  20xx    - operators
			     *  3xxx    - functions (blocks of 10 for each function)
			     */
			    var errorCodes = {
			        "S0101": "String literal must be terminated by a matching quote",
			        "S0102": "Number out of range: {{token}}",
			        "S0103": "Unsupported escape sequence: \\{{token}}",
			        "S0104": "The escape sequence \\u must be followed by 4 hex digits",
			        "S0105": "Quoted property name must be terminated with a backquote (`)",
			        "S0106": "Comment has no closing tag",
			        "S0201": "Syntax error: {{token}}",
			        "S0202": "Expected {{value}}, got {{token}}",
			        "S0203": "Expected {{value}} before end of expression",
			        "S0204": "Unknown operator: {{token}}",
			        "S0205": "Unexpected token: {{token}}",
			        "S0206": "Unknown expression type: {{token}}",
			        "S0207": "Unexpected end of expression",
			        "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
			        "S0209": "A predicate cannot follow a grouping expression in a step",
			        "S0210": "Each step can only have one grouping expression",
			        "S0211": "The symbol {{token}} cannot be used as a unary operator",
			        "S0212": "The left side of := must be a variable name (start with $)",
			        "S0213": "The literal value {{value}} cannot be used as a step within a path expression",
			        "S0214": "The right side of {{token}} must be a variable name (start with $)",
			        "S0215": "A context variable binding must precede any predicates on a step",
			        "S0216": "A context variable binding must precede the 'order-by' clause on a step",
			        "S0217": "The object representing the 'parent' cannot be derived from this expression",
			        "S0301": "Empty regular expressions are not allowed",
			        "S0302": "No terminating / in regular expression",
			        "S0402": "Choice groups containing parameterized types are not supported",
			        "S0401": "Type parameters can only be applied to functions and arrays",
			        "S0500": "Attempted to evaluate an expression containing syntax error(s)",
			        "T0410": "Argument {{index}} of function {{token}} does not match function signature",
			        "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
			        "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
			        "D1001": "Number out of range: {{value}}",
			        "D1002": "Cannot negate a non-numeric value: {{value}}",
			        "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
			        "D1004": "Regular expression matches zero length string",
			        "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
			        "T1006": "Attempted to invoke a non-function",
			        "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
			        "T1008": "Attempted to partially apply a non-function",
			        "D1009": "Multiple key definitions evaluate to same key: {{value}}",
			        "D1010": "Attempted to access the Javascript object prototype", // Javascript specific 
			        "T1010": "The matcher function argument passed to function {{token}} does not return the correct object structure",
			        "T2001": "The left side of the {{token}} operator must evaluate to a number",
			        "T2002": "The right side of the {{token}} operator must evaluate to a number",
			        "T2003": "The left side of the range operator (..) must evaluate to an integer",
			        "T2004": "The right side of the range operator (..) must evaluate to an integer",
			        "D2005": "The left side of := must be a variable name (start with $)",  // defunct - replaced by S0212 parser error
			        "T2006": "The right side of the function application operator ~> must be a function",
			        "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
			        "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
			        "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
			        "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
			        "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
			        "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
			        "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
			        "D2014": "The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.",
			        "D3001": "Attempting to invoke string function on Infinity or NaN",
			        "D3010": "Second argument of replace function cannot be an empty string",
			        "D3011": "Fourth argument of replace function must evaluate to a positive number",
			        "D3012": "Attempted to replace a matched string with a non-string value",
			        "D3020": "Third argument of split function must evaluate to a positive number",
			        "D3030": "Unable to cast value to a number: {{value}}",
			        "D3040": "Third argument of match function must evaluate to a positive number",
			        "D3050": "The second argument of reduce function must be a function with at least two arguments",
			        "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
			        "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
			        "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
			        "D3080": "The picture string must only contain a maximum of two sub-pictures",
			        "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
			        "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
			        "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
			        "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
			        "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
			        "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
			        "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
			        "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
			        "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
			        "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
			        "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
			        "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
			        "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
			        "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
			        "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}",
			        "D3120": "Syntax error in expression passed to function eval: {{value}}",
			        "D3121": "Dynamic error evaluating the expression passed to function eval: {{value}}",
			        "D3130": "Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation",
			        "D3131": "In a decimal digit pattern, all digits must be from the same decimal group",
			        "D3132": "Unknown component specifier {{value}} in date/time picture string",
			        "D3133": "The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}",
			        "D3134": "The timezone integer format specifier cannot have more than four digits",
			        "D3135": "No matching closing bracket ']' in date/time picture string",
			        "D3136": "The date/time picture string is missing specifiers required to parse the timestamp",
			        "D3137": "{{{message}}}",
			        "D3138": "The $single() function expected exactly 1 matching result.  Instead it matched more.",
			        "D3139": "The $single() function expected exactly 1 matching result.  Instead it matched 0.",
			        "D3140": "Malformed URL passed to ${{{functionName}}}(): {{value}}",
			        "D3141": "{{{message}}}"
			    };

			    /**
			     * lookup a message template from the catalog and substitute the inserts.
			     * Populates `err.message` with the substituted message. Leaves `err.message`
			     * untouched if code lookup fails.
			     * @param {string} err - error code to lookup
			     * @returns {undefined} - `err` is modified in place
			     */
			    function populateMessage(err) {
			        var template = errorCodes[err.code];
			        if(typeof template !== 'undefined') {
			            // if there are any handlebars, replace them with the field references
			            // triple braces - replace with value
			            // double braces - replace with json stringified value
			            var message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
			                return err[arguments[1]];
			            });
			            message = message.replace(/\{\{([^}]+)}}/g, function() {
			                return JSON.stringify(err[arguments[1]]);
			            });
			            err.message = message;
			        }
			        // Otherwise retain the original `err.message`
			    }

			    /**
			     * JSONata
			     * @param {Object} expr - JSONata expression
			     * @param {Object} options
			     * @param {boolean} options.recover: attempt to recover on parse error
			     * @param {Function} options.RegexEngine: RegEx class constructor to use
			     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
			     */
			    function jsonata(expr, options) {
			        var ast;
			        var errors;
			        try {
			            ast = parser(expr, options && options.recover);
			            errors = ast.errors;
			            delete ast.errors;
			        } catch(err) {
			            // insert error message into structure
			            populateMessage(err); // possible side-effects on `err`
			            throw err;
			        }
			        var environment = createFrame(staticFrame);

			        var timestamp = new Date(); // will be overridden on each call to evalute()
			        environment.bind('now', defineFunction(function(picture, timezone) {
			            return datetime.fromMillis(timestamp.getTime(), picture, timezone);
			        }, '<s?s?:s>'));
			        environment.bind('millis', defineFunction(function() {
			            return timestamp.getTime();
			        }, '<:n>'));

			        if(options && options.RegexEngine) {
			            jsonata.RegexEngine = options.RegexEngine;
			        } else {
			            jsonata.RegexEngine = RegExp;
			        }

			        return {
			            evaluate: function (input, bindings, callback) {
			                // throw if the expression compiled with syntax errors
			                if(typeof errors !== 'undefined') {
			                    var err = {
			                        code: 'S0500',
			                        position: 0
			                    };
			                    populateMessage(err); // possible side-effects on `err`
			                    throw err;
			                }

			                if (typeof bindings !== 'undefined') {
			                    var exec_env;
			                    // the variable bindings have been passed in - create a frame to hold these
			                    exec_env = createFrame(environment);
			                    for (var v in bindings) {
			                        exec_env.bind(v, bindings[v]);
			                    }
			                } else {
			                    exec_env = environment;
			                }
			                // put the input document into the environment as the root object
			                exec_env.bind('$', input);

			                // capture the timestamp and put it in the execution environment
			                // the $now() and $millis() functions will return this value - whenever it is called
			                timestamp = new Date();
			                exec_env.timestamp = timestamp;

			                // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input
			                if(Array.isArray(input) && !isSequence(input)) {
			                    input = createSequence(input);
			                    input.outerWrapper = true;
			                }

			                var result, it;
			                // if a callback function is supplied, then drive the generator in a promise chain
			                if(typeof callback === 'function') {
			                    exec_env.async = true;
			                    var catchHandler = function (err) {
			                        populateMessage(err); // possible side-effects on `err`
			                        callback(err, null);
			                    };
			                    var thenHandler = function (response) {
			                        result = it.next(response);
			                        if (result.done) {
			                            callback(null, result.value);
			                        } else {
			                            result.value.then(thenHandler).catch(catchHandler);
			                        }
			                    };
			                    it = evaluate(ast, input, exec_env);
			                    result = it.next();
			                    result.value.then(thenHandler).catch(catchHandler);
			                } else {
			                    // no callback function - drive the generator to completion synchronously
			                    try {
			                        it = evaluate(ast, input, exec_env);
			                        result = it.next();
			                        while (!result.done) {
			                            result = it.next(result.value);
			                        }
			                        return result.value;
			                    } catch (err) {
			                        // insert error message into structure
			                        populateMessage(err); // possible side-effects on `err`
			                        throw err;
			                    }
			                }
			            },
			            assign: function (name, value) {
			                environment.bind(name, value);
			            },
			            registerFunction: function(name, implementation, signature) {
			                var func = defineFunction(implementation, signature);
			                environment.bind(name, func);
			            },
			            ast: function() {
			                return ast;
			            },
			            errors: function() {
			                return errors;
			            }
			        };
			    }

			    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead

			    return jsonata;

			})();

			module.exports = jsonata;

			},{"./datetime":1,"./functions":2,"./parser":4,"./signature":5,"./utils":6}],4:[function(require,module,exports){
			/**
			 * © Copyright IBM Corp. 2016, 2018 All Rights Reserved
			 *   Project name: JSONata
			 *   This project is licensed under the MIT License, see LICENSE
			 */

			var parseSignature = require('./signature');

			const parser = (() => {

			    var operators = {
			        '.': 75,
			        '[': 80,
			        ']': 0,
			        '{': 70,
			        '}': 0,
			        '(': 80,
			        ')': 0,
			        ',': 0,
			        '@': 80,
			        '#': 80,
			        ';': 80,
			        ':': 80,
			        '?': 20,
			        '+': 50,
			        '-': 50,
			        '*': 60,
			        '/': 60,
			        '%': 60,
			        '|': 20,
			        '=': 40,
			        '<': 40,
			        '>': 40,
			        '^': 40,
			        '**': 60,
			        '..': 20,
			        ':=': 10,
			        '!=': 40,
			        '<=': 40,
			        '>=': 40,
			        '~>': 40,
			        'and': 30,
			        'or': 25,
			        'in': 40,
			        '&': 50,
			        '!': 0,   // not an operator, but needed as a stop character for name tokens
			        '~': 0   // not an operator, but needed as a stop character for name tokens
			    };

			    var escapes = {  // JSON string escape sequences - see json.org
			        '"': '"',
			        '\\': '\\',
			        '/': '/',
			        'b': '\b',
			        'f': '\f',
			        'n': '\n',
			        'r': '\r',
			        't': '\t'
			    };

			    // Tokenizer (lexer) - invoked by the parser to return one token at a time
			    var tokenizer = function (path) {
			        var position = 0;
			        var length = path.length;

			        var create = function (type, value) {
			            var obj = {type: type, value: value, position: position};
			            return obj;
			        };

			        var scanRegex = function () {
			            // the prefix '/' will have been previously scanned. Find the end of the regex.
			            // search for closing '/' ignoring any that are escaped, or within brackets
			            var start = position;
			            var depth = 0;
			            var pattern;
			            var flags;
			            while (position < length) {
			                var currentChar = path.charAt(position);
			                if (currentChar === '/' && path.charAt(position - 1) !== '\\' && depth === 0) {
			                    // end of regex found
			                    pattern = path.substring(start, position);
			                    if (pattern === '') {
			                        throw {
			                            code: "S0301",
			                            stack: (new Error()).stack,
			                            position: position
			                        };
			                    }
			                    position++;
			                    currentChar = path.charAt(position);
			                    // flags
			                    start = position;
			                    while (currentChar === 'i' || currentChar === 'm') {
			                        position++;
			                        currentChar = path.charAt(position);
			                    }
			                    flags = path.substring(start, position) + 'g';
			                    return new RegExp(pattern, flags);
			                }
			                if ((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\') {
			                    depth++;
			                }
			                if ((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\') {
			                    depth--;
			                }

			                position++;
			            }
			            throw {
			                code: "S0302",
			                stack: (new Error()).stack,
			                position: position
			            };
			        };

			        var next = function (prefix) {
			            if (position >= length) return null;
			            var currentChar = path.charAt(position);
			            // skip whitespace
			            while (position < length && ' \t\n\r\v'.indexOf(currentChar) > -1) {
			                position++;
			                currentChar = path.charAt(position);
			            }
			            // skip comments
			            if (currentChar === '/' && path.charAt(position + 1) === '*') {
			                var commentStart = position;
			                position += 2;
			                currentChar = path.charAt(position);
			                while (!(currentChar === '*' && path.charAt(position + 1) === '/')) {
			                    currentChar = path.charAt(++position);
			                    if (position >= length) {
			                        // no closing tag
			                        throw {
			                            code: "S0106",
			                            stack: (new Error()).stack,
			                            position: commentStart
			                        };
			                    }
			                }
			                position += 2;
			                currentChar = path.charAt(position);
			                return next(prefix); // need this to swallow any following whitespace
			            }
			            // test for regex
			            if (prefix !== true && currentChar === '/') {
			                position++;
			                return create('regex', scanRegex());
			            }
			            // handle double-char operators
			            if (currentChar === '.' && path.charAt(position + 1) === '.') {
			                // double-dot .. range operator
			                position += 2;
			                return create('operator', '..');
			            }
			            if (currentChar === ':' && path.charAt(position + 1) === '=') {
			                // := assignment
			                position += 2;
			                return create('operator', ':=');
			            }
			            if (currentChar === '!' && path.charAt(position + 1) === '=') {
			                // !=
			                position += 2;
			                return create('operator', '!=');
			            }
			            if (currentChar === '>' && path.charAt(position + 1) === '=') {
			                // >=
			                position += 2;
			                return create('operator', '>=');
			            }
			            if (currentChar === '<' && path.charAt(position + 1) === '=') {
			                // <=
			                position += 2;
			                return create('operator', '<=');
			            }
			            if (currentChar === '*' && path.charAt(position + 1) === '*') {
			                // **  descendant wildcard
			                position += 2;
			                return create('operator', '**');
			            }
			            if (currentChar === '~' && path.charAt(position + 1) === '>') {
			                // ~>  chain function
			                position += 2;
			                return create('operator', '~>');
			            }
			            // test for single char operators
			            if (Object.prototype.hasOwnProperty.call(operators, currentChar)) {
			                position++;
			                return create('operator', currentChar);
			            }
			            // test for string literals
			            if (currentChar === '"' || currentChar === "'") {
			                var quoteType = currentChar;
			                // double quoted string literal - find end of string
			                position++;
			                var qstr = "";
			                while (position < length) {
			                    currentChar = path.charAt(position);
			                    if (currentChar === '\\') { // escape sequence
			                        position++;
			                        currentChar = path.charAt(position);
			                        if (Object.prototype.hasOwnProperty.call(escapes, currentChar)) {
			                            qstr += escapes[currentChar];
			                        } else if (currentChar === 'u') {
			                            // \u should be followed by 4 hex digits
			                            var octets = path.substr(position + 1, 4);
			                            if (/^[0-9a-fA-F]+$/.test(octets)) {
			                                var codepoint = parseInt(octets, 16);
			                                qstr += String.fromCharCode(codepoint);
			                                position += 4;
			                            } else {
			                                throw {
			                                    code: "S0104",
			                                    stack: (new Error()).stack,
			                                    position: position
			                                };
			                            }
			                        } else {
			                            // illegal escape sequence
			                            throw {
			                                code: "S0103",
			                                stack: (new Error()).stack,
			                                position: position,
			                                token: currentChar
			                            };

			                        }
			                    } else if (currentChar === quoteType) {
			                        position++;
			                        return create('string', qstr);
			                    } else {
			                        qstr += currentChar;
			                    }
			                    position++;
			                }
			                throw {
			                    code: "S0101",
			                    stack: (new Error()).stack,
			                    position: position
			                };
			            }
			            // test for numbers
			            var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
			            var match = numregex.exec(path.substring(position));
			            if (match !== null) {
			                var num = parseFloat(match[0]);
			                if (!isNaN(num) && isFinite(num)) {
			                    position += match[0].length;
			                    return create('number', num);
			                } else {
			                    throw {
			                        code: "S0102",
			                        stack: (new Error()).stack,
			                        position: position,
			                        token: match[0]
			                    };
			                }
			            }
			            // test for quoted names (backticks)
			            var name;
			            if (currentChar === '`') {
			                // scan for closing quote
			                position++;
			                var end = path.indexOf('`', position);
			                if (end !== -1) {
			                    name = path.substring(position, end);
			                    position = end + 1;
			                    return create('name', name);
			                }
			                position = length;
			                throw {
			                    code: "S0105",
			                    stack: (new Error()).stack,
			                    position: position
			                };
			            }
			            // test for names
			            var i = position;
			            var ch;
			            for (; ;) {
			                ch = path.charAt(i);
			                if (i === length || ' \t\n\r\v'.indexOf(ch) > -1 || Object.prototype.hasOwnProperty.call(operators, ch)) {
			                    if (path.charAt(position) === '$') {
			                        // variable reference
			                        name = path.substring(position + 1, i);
			                        position = i;
			                        return create('variable', name);
			                    } else {
			                        name = path.substring(position, i);
			                        position = i;
			                        switch (name) {
			                            case 'or':
			                            case 'in':
			                            case 'and':
			                                return create('operator', name);
			                            case 'true':
			                                return create('value', true);
			                            case 'false':
			                                return create('value', false);
			                            case 'null':
			                                return create('value', null);
			                            default:
			                                if (position === length && name === '') {
			                                    // whitespace at end of input
			                                    return null;
			                                }
			                                return create('name', name);
			                        }
			                    }
			                } else {
			                    i++;
			                }
			            }
			        };

			        return next;
			    };

			    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.
			    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html
			    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6

			    var parser = function (source, recover) {
			        var node;
			        var lexer;

			        var symbol_table = {};
			        var errors = [];

			        var remainingTokens = function () {
			            var remaining = [];
			            if (node.id !== '(end)') {
			                remaining.push({type: node.type, value: node.value, position: node.position});
			            }
			            var nxt = lexer();
			            while (nxt !== null) {
			                remaining.push(nxt);
			                nxt = lexer();
			            }
			            return remaining;
			        };

			        var base_symbol = {
			            nud: function () {
			                // error - symbol has been invoked as a unary operator
			                var err = {
			                    code: 'S0211',
			                    token: this.value,
			                    position: this.position
			                };

			                if (recover) {
			                    err.remaining = remainingTokens();
			                    err.type = 'error';
			                    errors.push(err);
			                    return err;
			                } else {
			                    err.stack = (new Error()).stack;
			                    throw err;
			                }
			            }
			        };

			        var symbol = function (id, bp) {
			            var s = symbol_table[id];
			            bp = bp || 0;
			            if (s) {
			                if (bp >= s.lbp) {
			                    s.lbp = bp;
			                }
			            } else {
			                s = Object.create(base_symbol);
			                s.id = s.value = id;
			                s.lbp = bp;
			                symbol_table[id] = s;
			            }
			            return s;
			        };

			        var handleError = function (err) {
			            if (recover) {
			                // tokenize the rest of the buffer and add it to an error token
			                err.remaining = remainingTokens();
			                errors.push(err);
			                var symbol = symbol_table["(error)"];
			                node = Object.create(symbol);
			                node.error = err;
			                node.type = "(error)";
			                return node;
			            } else {
			                err.stack = (new Error()).stack;
			                throw err;
			            }
			        };

			        var advance = function (id, infix) {
			            if (id && node.id !== id) {
			                var code;
			                if (node.id === '(end)') {
			                    // unexpected end of buffer
			                    code = "S0203";
			                } else {
			                    code = "S0202";
			                }
			                var err = {
			                    code: code,
			                    position: node.position,
			                    token: node.value,
			                    value: id
			                };
			                return handleError(err);
			            }
			            var next_token = lexer(infix);
			            if (next_token === null) {
			                node = symbol_table["(end)"];
			                node.position = source.length;
			                return node;
			            }
			            var value = next_token.value;
			            var type = next_token.type;
			            var symbol;
			            switch (type) {
			                case 'name':
			                case 'variable':
			                    symbol = symbol_table["(name)"];
			                    break;
			                case 'operator':
			                    symbol = symbol_table[value];
			                    if (!symbol) {
			                        return handleError({
			                            code: "S0204",
			                            stack: (new Error()).stack,
			                            position: next_token.position,
			                            token: value
			                        });
			                    }
			                    break;
			                case 'string':
			                case 'number':
			                case 'value':
			                    symbol = symbol_table["(literal)"];
			                    break;
			                case 'regex':
			                    type = "regex";
			                    symbol = symbol_table["(regex)"];
			                    break;
			                /* istanbul ignore next */
			                default:
			                    return handleError({
			                        code: "S0205",
			                        stack: (new Error()).stack,
			                        position: next_token.position,
			                        token: value
			                    });
			            }

			            node = Object.create(symbol);
			            node.value = value;
			            node.type = type;
			            node.position = next_token.position;
			            return node;
			        };

			        // Pratt's algorithm
			        var expression = function (rbp) {
			            var left;
			            var t = node;
			            advance(null, true);
			            left = t.nud();
			            while (rbp < node.lbp) {
			                t = node;
			                advance();
			                left = t.led(left);
			            }
			            return left;
			        };

			        var terminal = function (id) {
			            var s = symbol(id, 0);
			            s.nud = function () {
			                return this;
			            };
			        };

			        // match infix operators
			        // <expression> <operator> <expression>
			        // left associative
			        var infix = function (id, bp, led) {
			            var bindingPower = bp || operators[id];
			            var s = symbol(id, bindingPower);
			            s.led = led || function (left) {
			                this.lhs = left;
			                this.rhs = expression(bindingPower);
			                this.type = "binary";
			                return this;
			            };
			            return s;
			        };

			        // match infix operators
			        // <expression> <operator> <expression>
			        // right associative
			        var infixr = function (id, bp, led) {
			            var s = symbol(id, bp);
			            s.led = led;
			            return s;
			        };

			        // match prefix operators
			        // <operator> <expression>
			        var prefix = function (id, nud) {
			            var s = symbol(id);
			            s.nud = nud || function () {
			                this.expression = expression(70);
			                this.type = "unary";
			                return this;
			            };
			            return s;
			        };

			        terminal("(end)");
			        terminal("(name)");
			        terminal("(literal)");
			        terminal("(regex)");
			        symbol(":");
			        symbol(";");
			        symbol(",");
			        symbol(")");
			        symbol("]");
			        symbol("}");
			        symbol(".."); // range operator
			        infix("."); // map operator
			        infix("+"); // numeric addition
			        infix("-"); // numeric subtraction
			        infix("*"); // numeric multiplication
			        infix("/"); // numeric division
			        infix("%"); // numeric modulus
			        infix("="); // equality
			        infix("<"); // less than
			        infix(">"); // greater than
			        infix("!="); // not equal to
			        infix("<="); // less than or equal
			        infix(">="); // greater than or equal
			        infix("&"); // string concatenation
			        infix("and"); // Boolean AND
			        infix("or"); // Boolean OR
			        infix("in"); // is member of array
			        terminal("and"); // the 'keywords' can also be used as terminals (field names)
			        terminal("or"); //
			        terminal("in"); //
			        prefix("-"); // unary numeric negation
			        infix("~>"); // function application

			        infixr("(error)", 10, function (left) {
			            this.lhs = left;

			            this.error = node.error;
			            this.remaining = remainingTokens();
			            this.type = 'error';
			            return this;
			        });

			        // field wildcard (single level)
			        prefix('*', function () {
			            this.type = "wildcard";
			            return this;
			        });

			        // descendant wildcard (multi-level)
			        prefix('**', function () {
			            this.type = "descendant";
			            return this;
			        });

			        // parent operator
			        prefix('%', function () {
			            this.type = "parent";
			            return this;
			        });

			        // function invocation
			        infix("(", operators['('], function (left) {
			            // left is is what we are trying to invoke
			            this.procedure = left;
			            this.type = 'function';
			            this.arguments = [];
			            if (node.id !== ')') {
			                for (; ;) {
			                    if (node.type === 'operator' && node.id === '?') {
			                        // partial function application
			                        this.type = 'partial';
			                        this.arguments.push(node);
			                        advance('?');
			                    } else {
			                        this.arguments.push(expression(0));
			                    }
			                    if (node.id !== ',') break;
			                    advance(',');
			                }
			            }
			            advance(")", true);
			            // if the name of the function is 'function' or λ, then this is function definition (lambda function)
			            if (left.type === 'name' && (left.value === 'function' || left.value === '\u03BB')) {
			                // all of the args must be VARIABLE tokens
			                this.arguments.forEach(function (arg, index) {
			                    if (arg.type !== 'variable') {
			                        return handleError({
			                            code: "S0208",
			                            stack: (new Error()).stack,
			                            position: arg.position,
			                            token: arg.value,
			                            value: index + 1
			                        });
			                    }
			                });
			                this.type = 'lambda';
			                // is the next token a '<' - if so, parse the function signature
			                if (node.id === '<') {
			                    var sigPos = node.position;
			                    var depth = 1;
			                    var sig = '<';
			                    while (depth > 0 && node.id !== '{' && node.id !== '(end)') {
			                        var tok = advance();
			                        if (tok.id === '>') {
			                            depth--;
			                        } else if (tok.id === '<') {
			                            depth++;
			                        }
			                        sig += tok.value;
			                    }
			                    advance('>');
			                    try {
			                        this.signature = parseSignature(sig);
			                    } catch (err) {
			                        // insert the position into this error
			                        err.position = sigPos + err.offset;
			                        return handleError(err);
			                    }
			                }
			                // parse the function body
			                advance('{');
			                this.body = expression(0);
			                advance('}');
			            }
			            return this;
			        });

			        // parenthesis - block expression
			        prefix("(", function () {
			            var expressions = [];
			            while (node.id !== ")") {
			                expressions.push(expression(0));
			                if (node.id !== ";") {
			                    break;
			                }
			                advance(";");
			            }
			            advance(")", true);
			            this.type = 'block';
			            this.expressions = expressions;
			            return this;
			        });

			        // array constructor
			        prefix("[", function () {
			            var a = [];
			            if (node.id !== "]") {
			                for (; ;) {
			                    var item = expression(0);
			                    if (node.id === "..") {
			                        // range operator
			                        var range = {type: "binary", value: "..", position: node.position, lhs: item};
			                        advance("..");
			                        range.rhs = expression(0);
			                        item = range;
			                    }
			                    a.push(item);
			                    if (node.id !== ",") {
			                        break;
			                    }
			                    advance(",");
			                }
			            }
			            advance("]", true);
			            this.expressions = a;
			            this.type = "unary";
			            return this;
			        });

			        // filter - predicate or array index
			        infix("[", operators['['], function (left) {
			            if (node.id === "]") {
			                // empty predicate means maintain singleton arrays in the output
			                var step = left;
			                while (step && step.type === 'binary' && step.value === '[') {
			                    step = step.lhs;
			                }
			                step.keepArray = true;
			                advance("]");
			                return left;
			            } else {
			                this.lhs = left;
			                this.rhs = expression(operators[']']);
			                this.type = 'binary';
			                advance("]", true);
			                return this;
			            }
			        });

			        // order-by
			        infix("^", operators['^'], function (left) {
			            advance("(");
			            var terms = [];
			            for (; ;) {
			                var term = {
			                    descending: false
			                };
			                if (node.id === "<") {
			                    // ascending sort
			                    advance("<");
			                } else if (node.id === ">") {
			                    // descending sort
			                    term.descending = true;
			                    advance(">");
			                } else ;
			                term.expression = expression(0);
			                terms.push(term);
			                if (node.id !== ",") {
			                    break;
			                }
			                advance(",");
			            }
			            advance(")");
			            this.lhs = left;
			            this.rhs = terms;
			            this.type = 'binary';
			            return this;
			        });

			        var objectParser = function (left) {
			            var a = [];
			            if (node.id !== "}") {
			                for (; ;) {
			                    var n = expression(0);
			                    advance(":");
			                    var v = expression(0);
			                    a.push([n, v]); // holds an array of name/value expression pairs
			                    if (node.id !== ",") {
			                        break;
			                    }
			                    advance(",");
			                }
			            }
			            advance("}", true);
			            if (typeof left === 'undefined') {
			                // NUD - unary prefix form
			                this.lhs = a;
			                this.type = "unary";
			            } else {
			                // LED - binary infix form
			                this.lhs = left;
			                this.rhs = a;
			                this.type = 'binary';
			            }
			            return this;
			        };

			        // object constructor
			        prefix("{", objectParser);

			        // object grouping
			        infix("{", operators['{'], objectParser);

			        // bind variable
			        infixr(":=", operators[':='], function (left) {
			            if (left.type !== 'variable') {
			                return handleError({
			                    code: "S0212",
			                    stack: (new Error()).stack,
			                    position: left.position,
			                    token: left.value
			                });
			            }
			            this.lhs = left;
			            this.rhs = expression(operators[':='] - 1); // subtract 1 from bindingPower for right associative operators
			            this.type = "binary";
			            return this;
			        });

			        // focus variable bind
			        infix("@", operators['@'], function (left) {
			            this.lhs = left;
			            this.rhs = expression(operators['@']);
			            if(this.rhs.type !== 'variable') {
			                return handleError({
			                    code: "S0214",
			                    stack: (new Error()).stack,
			                    position: this.rhs.position,
			                    token: "@"
			                });
			            }
			            this.type = "binary";
			            return this;
			        });

			        // index (position) variable bind
			        infix("#", operators['#'], function (left) {
			            this.lhs = left;
			            this.rhs = expression(operators['#']);
			            if(this.rhs.type !== 'variable') {
			                return handleError({
			                    code: "S0214",
			                    stack: (new Error()).stack,
			                    position: this.rhs.position,
			                    token: "#"
			                });
			            }
			            this.type = "binary";
			            return this;
			        });

			        // if/then/else ternary operator ?:
			        infix("?", operators['?'], function (left) {
			            this.type = 'condition';
			            this.condition = left;
			            this.then = expression(0);
			            if (node.id === ':') {
			                // else condition
			                advance(":");
			                this.else = expression(0);
			            }
			            return this;
			        });

			        // object transformer
			        prefix("|", function () {
			            this.type = 'transform';
			            this.pattern = expression(0);
			            advance('|');
			            this.update = expression(0);
			            if (node.id === ',') {
			                advance(',');
			                this.delete = expression(0);
			            }
			            advance('|');
			            return this;
			        });

			        // tail call optimization
			        // this is invoked by the post parser to analyse lambda functions to see
			        // if they make a tail call.  If so, it is replaced by a thunk which will
			        // be invoked by the trampoline loop during function application.
			        // This enables tail-recursive functions to be written without growing the stack
			        var tailCallOptimize = function (expr) {
			            var result;
			            if (expr.type === 'function' && !expr.predicate) {
			                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};
			                thunk.body = expr;
			                result = thunk;
			            } else if (expr.type === 'condition') {
			                // analyse both branches
			                expr.then = tailCallOptimize(expr.then);
			                if (typeof expr.else !== 'undefined') {
			                    expr.else = tailCallOptimize(expr.else);
			                }
			                result = expr;
			            } else if (expr.type === 'block') {
			                // only the last expression in the block
			                var length = expr.expressions.length;
			                if (length > 0) {
			                    expr.expressions[length - 1] = tailCallOptimize(expr.expressions[length - 1]);
			                }
			                result = expr;
			            } else {
			                result = expr;
			            }
			            return result;
			        };

			        var ancestorLabel = 0;
			        var ancestorIndex = 0;
			        var ancestry = [];

			        var seekParent = function (node, slot) {
			            switch (node.type) {
			                case 'name':
			                case 'wildcard':
			                    slot.level--;
			                    if(slot.level === 0) {
			                        if (typeof node.ancestor === 'undefined') {
			                            node.ancestor = slot;
			                        } else {
			                            // reuse the existing label
			                            ancestry[slot.index].slot.label = node.ancestor.label;
			                            node.ancestor = slot;
			                        }
			                        node.tuple = true;
			                    }
			                    break;
			                case 'parent':
			                    slot.level++;
			                    break;
			                case 'block':
			                    // look in last expression in the block
			                    if(node.expressions.length > 0) {
			                        node.tuple = true;
			                        slot = seekParent(node.expressions[node.expressions.length - 1], slot);
			                    }
			                    break;
			                case 'path':
			                    // last step in path
			                    node.tuple = true;
			                    var index = node.steps.length - 1;
			                    slot = seekParent(node.steps[index--], slot);
			                    while (slot.level > 0 && index >= 0) {
			                        // check previous steps
			                        slot = seekParent(node.steps[index--], slot);
			                    }
			                    break;
			                default:
			                    // error - can't derive ancestor
			                    throw {
			                        code: "S0217",
			                        token: node.type,
			                        position: node.position
			                    };
			            }
			            return slot;
			        };

			        var pushAncestry = function(result, value) {
			            if(typeof value.seekingParent !== 'undefined' || value.type === 'parent') {
			                var slots = (typeof value.seekingParent !== 'undefined') ? value.seekingParent : [];
			                if (value.type === 'parent') {
			                    slots.push(value.slot);
			                }
			                if(typeof result.seekingParent === 'undefined') {
			                    result.seekingParent = slots;
			                } else {
			                    Array.prototype.push.apply(result.seekingParent, slots);
			                }
			            }
			        };

			        var resolveAncestry = function(path) {
			            var index = path.steps.length - 1;
			            var laststep = path.steps[index];
			            var slots = (typeof laststep.seekingParent !== 'undefined') ? laststep.seekingParent : [];
			            if (laststep.type === 'parent') {
			                slots.push(laststep.slot);
			            }
			            for(var is = 0; is < slots.length; is++) {
			                var slot = slots[is];
			                index = path.steps.length - 2;
			                while (slot.level > 0) {
			                    if (index < 0) {
			                        if(typeof path.seekingParent === 'undefined') {
			                            path.seekingParent = [slot];
			                        } else {
			                            path.seekingParent.push(slot);
			                        }
			                        break;
			                    }
			                    // try previous step
			                    var step = path.steps[index--];
			                    // multiple contiguous steps that bind the focus should be skipped
			                    while(index >= 0 && step.focus && path.steps[index].focus) {
			                        step = path.steps[index--];
			                    }
			                    slot = seekParent(step, slot);
			                }
			            }
			        };

			        // post-parse stage
			        // the purpose of this is to add as much semantic value to the parse tree as possible
			        // in order to simplify the work of the evaluator.
			        // This includes flattening the parts of the AST representing location paths,
			        // converting them to arrays of steps which in turn may contain arrays of predicates.
			        // following this, nodes containing '.' and '[' should be eliminated from the AST.
			        var processAST = function (expr) {
			            var result;
			            switch (expr.type) {
			                case 'binary':
			                    switch (expr.value) {
			                        case '.':
			                            var lstep = processAST(expr.lhs);

			                            if (lstep.type === 'path') {
			                                result = lstep;
			                            } else {
			                                result = {type: 'path', steps: [lstep]};
			                            }
			                            if(lstep.type === 'parent') {
			                                result.seekingParent = [lstep.slot];
			                            }
			                            var rest = processAST(expr.rhs);
			                            if (rest.type === 'function' &&
			                                rest.procedure.type === 'path' &&
			                                rest.procedure.steps.length === 1 &&
			                                rest.procedure.steps[0].type === 'name' &&
			                                result.steps[result.steps.length - 1].type === 'function') {
			                                // next function in chain of functions - will override a thenable
			                                result.steps[result.steps.length - 1].nextFunction = rest.procedure.steps[0].value;
			                            }
			                            if (rest.type === 'path') {
			                                Array.prototype.push.apply(result.steps, rest.steps);
			                            } else {
			                                if(typeof rest.predicate !== 'undefined') {
			                                    rest.stages = rest.predicate;
			                                    delete rest.predicate;
			                                }
			                                result.steps.push(rest);
			                            }
			                            // any steps within a path that are string literals, should be changed to 'name'
			                            result.steps.filter(function (step) {
			                                if (step.type === 'number' || step.type === 'value') {
			                                    // don't allow steps to be numbers or the values true/false/null
			                                    throw {
			                                        code: "S0213",
			                                        stack: (new Error()).stack,
			                                        position: step.position,
			                                        value: step.value
			                                    };
			                                }
			                                return step.type === 'string';
			                            }).forEach(function (lit) {
			                                lit.type = 'name';
			                            });
			                            // any step that signals keeping a singleton array, should be flagged on the path
			                            if (result.steps.filter(function (step) {
			                                return step.keepArray === true;
			                            }).length > 0) {
			                                result.keepSingletonArray = true;
			                            }
			                            // if first step is a path constructor, flag it for special handling
			                            var firststep = result.steps[0];
			                            if (firststep.type === 'unary' && firststep.value === '[') {
			                                firststep.consarray = true;
			                            }
			                            // if the last step is an array constructor, flag it so it doesn't flatten
			                            var laststep = result.steps[result.steps.length - 1];
			                            if (laststep.type === 'unary' && laststep.value === '[') {
			                                laststep.consarray = true;
			                            }
			                            resolveAncestry(result);
			                            break;
			                        case '[':
			                            // predicated step
			                            // LHS is a step or a predicated step
			                            // RHS is the predicate expr
			                            result = processAST(expr.lhs);
			                            var step = result;
			                            var type = 'predicate';
			                            if (result.type === 'path') {
			                                step = result.steps[result.steps.length - 1];
			                                type = 'stages';
			                            }
			                            if (typeof step.group !== 'undefined') {
			                                throw {
			                                    code: "S0209",
			                                    stack: (new Error()).stack,
			                                    position: expr.position
			                                };
			                            }
			                            if (typeof step[type] === 'undefined') {
			                                step[type] = [];
			                            }
			                            var predicate = processAST(expr.rhs);
			                            if(typeof predicate.seekingParent !== 'undefined') {
			                                predicate.seekingParent.forEach(slot => {
			                                    if(slot.level === 1) {
			                                        seekParent(step, slot);
			                                    } else {
			                                        slot.level--;
			                                    }
			                                });
			                                pushAncestry(step, predicate);
			                            }
			                            step[type].push({type: 'filter', expr: predicate, position: expr.position});
			                            break;
			                        case '{':
			                            // group-by
			                            // LHS is a step or a predicated step
			                            // RHS is the object constructor expr
			                            result = processAST(expr.lhs);
			                            if (typeof result.group !== 'undefined') {
			                                throw {
			                                    code: "S0210",
			                                    stack: (new Error()).stack,
			                                    position: expr.position
			                                };
			                            }
			                            // object constructor - process each pair
			                            result.group = {
			                                lhs: expr.rhs.map(function (pair) {
			                                    return [processAST(pair[0]), processAST(pair[1])];
			                                }),
			                                position: expr.position
			                            };
			                            break;
			                        case '^':
			                            // order-by
			                            // LHS is the array to be ordered
			                            // RHS defines the terms
			                            result = processAST(expr.lhs);
			                            if (result.type !== 'path') {
			                                result = {type: 'path', steps: [result]};
			                            }
			                            var sortStep = {type: 'sort', position: expr.position};
			                            sortStep.terms = expr.rhs.map(function (terms) {
			                                var expression = processAST(terms.expression);
			                                pushAncestry(sortStep, expression);
			                                return {
			                                    descending: terms.descending,
			                                    expression: expression
			                                };
			                            });
			                            result.steps.push(sortStep);
			                            resolveAncestry(result);
			                            break;
			                        case ':=':
			                            result = {type: 'bind', value: expr.value, position: expr.position};
			                            result.lhs = processAST(expr.lhs);
			                            result.rhs = processAST(expr.rhs);
			                            pushAncestry(result, result.rhs);
			                            break;
			                        case '@':
			                            result = processAST(expr.lhs);
			                            step = result;
			                            if (result.type === 'path') {
			                                step = result.steps[result.steps.length - 1];
			                            }
			                            // throw error if there are any predicates defined at this point
			                            // at this point the only type of stages can be predicates
			                            if(typeof step.stages !== 'undefined' || typeof step.predicate !== 'undefined') {
			                                throw {
			                                    code: "S0215",
			                                    stack: (new Error()).stack,
			                                    position: expr.position
			                                };
			                            }
			                            // also throw if this is applied after an 'order-by' clause
			                            if(step.type === 'sort') {
			                                throw {
			                                    code: "S0216",
			                                    stack: (new Error()).stack,
			                                    position: expr.position
			                                };
			                            }
			                            if(expr.keepArray) {
			                                step.keepArray = true;
			                            }
			                            step.focus = expr.rhs.value;
			                            step.tuple = true;
			                            break;
			                        case '#':
			                            result = processAST(expr.lhs);
			                            step = result;
			                            if (result.type === 'path') {
			                                step = result.steps[result.steps.length - 1];
			                            } else {
			                                result = {type: 'path', steps: [result]};
			                                if (typeof step.predicate !== 'undefined') {
			                                    step.stages = step.predicate;
			                                    delete step.predicate;
			                                }
			                            }
			                            if (typeof step.stages === 'undefined') {
			                                step.index = expr.rhs.value;
			                            } else {
			                                step.stages.push({type: 'index', value: expr.rhs.value, position: expr.position});
			                            }
			                            step.tuple = true;
			                            break;
			                        case '~>':
			                            result = {type: 'apply', value: expr.value, position: expr.position};
			                            result.lhs = processAST(expr.lhs);
			                            result.rhs = processAST(expr.rhs);
			                            break;
			                        default:
			                            result = {type: expr.type, value: expr.value, position: expr.position};
			                            result.lhs = processAST(expr.lhs);
			                            result.rhs = processAST(expr.rhs);
			                            pushAncestry(result, result.lhs);
			                            pushAncestry(result, result.rhs);
			                    }
			                    break;
			                case 'unary':
			                    result = {type: expr.type, value: expr.value, position: expr.position};
			                    if (expr.value === '[') {
			                        // array constructor - process each item
			                        result.expressions = expr.expressions.map(function (item) {
			                            var value = processAST(item);
			                            pushAncestry(result, value);
			                            return value;
			                        });
			                    } else if (expr.value === '{') {
			                        // object constructor - process each pair
			                        result.lhs = expr.lhs.map(function (pair) {
			                            var key = processAST(pair[0]);
			                            pushAncestry(result, key);
			                            var value = processAST(pair[1]);
			                            pushAncestry(result, value);
			                            return [key, value];
			                        });
			                    } else {
			                        // all other unary expressions - just process the expression
			                        result.expression = processAST(expr.expression);
			                        // if unary minus on a number, then pre-process
			                        if (expr.value === '-' && result.expression.type === 'number') {
			                            result = result.expression;
			                            result.value = -result.value;
			                        } else {
			                            pushAncestry(result, result.expression);
			                        }
			                    }
			                    break;
			                case 'function':
			                case 'partial':
			                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};
			                    result.arguments = expr.arguments.map(function (arg) {
			                        var argAST = processAST(arg);
			                        pushAncestry(result, argAST);
			                        return argAST;
			                    });
			                    result.procedure = processAST(expr.procedure);
			                    break;
			                case 'lambda':
			                    result = {
			                        type: expr.type,
			                        arguments: expr.arguments,
			                        signature: expr.signature,
			                        position: expr.position
			                    };
			                    var body = processAST(expr.body);
			                    result.body = tailCallOptimize(body);
			                    break;
			                case 'condition':
			                    result = {type: expr.type, position: expr.position};
			                    result.condition = processAST(expr.condition);
			                    pushAncestry(result, result.condition);
			                    result.then = processAST(expr.then);
			                    pushAncestry(result, result.then);
			                    if (typeof expr.else !== 'undefined') {
			                        result.else = processAST(expr.else);
			                        pushAncestry(result, result.else);
			                    }
			                    break;
			                case 'transform':
			                    result = {type: expr.type, position: expr.position};
			                    result.pattern = processAST(expr.pattern);
			                    result.update = processAST(expr.update);
			                    if (typeof expr.delete !== 'undefined') {
			                        result.delete = processAST(expr.delete);
			                    }
			                    break;
			                case 'block':
			                    result = {type: expr.type, position: expr.position};
			                    // array of expressions - process each one
			                    result.expressions = expr.expressions.map(function (item) {
			                        var part = processAST(item);
			                        pushAncestry(result, part);
			                        if (part.consarray || (part.type === 'path' && part.steps[0].consarray)) {
			                            result.consarray = true;
			                        }
			                        return part;
			                    });
			                    // TODO scan the array of expressions to see if any of them assign variables
			                    // if so, need to mark the block as one that needs to create a new frame
			                    break;
			                case 'name':
			                    result = {type: 'path', steps: [expr]};
			                    if (expr.keepArray) {
			                        result.keepSingletonArray = true;
			                    }
			                    break;
			                case 'parent':
			                    result = {type: 'parent', slot: { label: '!' + ancestorLabel++, level: 1, index: ancestorIndex++ } };
			                    ancestry.push(result);
			                    break;
			                case 'string':
			                case 'number':
			                case 'value':
			                case 'wildcard':
			                case 'descendant':
			                case 'variable':
			                case 'regex':
			                    result = expr;
			                    break;
			                case 'operator':
			                    // the tokens 'and' and 'or' might have been used as a name rather than an operator
			                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {
			                        expr.type = 'name';
			                        result = processAST(expr);
			                    } else /* istanbul ignore else */ if (expr.value === '?') {
			                        // partial application
			                        result = expr;
			                    } else {
			                        throw {
			                            code: "S0201",
			                            stack: (new Error()).stack,
			                            position: expr.position,
			                            token: expr.value
			                        };
			                    }
			                    break;
			                case 'error':
			                    result = expr;
			                    if (expr.lhs) {
			                        result = processAST(expr.lhs);
			                    }
			                    break;
			                default:
			                    var code = "S0206";
			                    /* istanbul ignore else */
			                    if (expr.id === '(end)') {
			                        code = "S0207";
			                    }
			                    var err = {
			                        code: code,
			                        position: expr.position,
			                        token: expr.value
			                    };
			                    if (recover) {
			                        errors.push(err);
			                        return {type: 'error', error: err};
			                    } else {
			                        err.stack = (new Error()).stack;
			                        throw err;
			                    }
			            }
			            if (expr.keepArray) {
			                result.keepArray = true;
			            }
			            return result;
			        };

			        // now invoke the tokenizer and the parser and return the syntax tree
			        lexer = tokenizer(source);
			        advance();
			        // parse the tokens
			        var expr = expression(0);
			        if (node.id !== '(end)') {
			            var err = {
			                code: "S0201",
			                position: node.position,
			                token: node.value
			            };
			            handleError(err);
			        }
			        expr = processAST(expr);

			        if(expr.type === 'parent' || typeof expr.seekingParent !== 'undefined') {
			            // error - trying to derive ancestor at top level
			            throw {
			                code: "S0217",
			                token: expr.type,
			                position: expr.position
			            };
			        }

			        if (errors.length > 0) {
			            expr.errors = errors;
			        }

			        return expr;
			    };

			    return parser;
			})();

			module.exports = parser;

			},{"./signature":5}],5:[function(require,module,exports){
			/**
			 * © Copyright IBM Corp. 2016, 2018 All Rights Reserved
			 *   Project name: JSONata
			 *   This project is licensed under the MIT License, see LICENSE
			 */

			var utils = require('./utils');

			const signature = (() => {

			    // A mapping between the function signature symbols and the full plural of the type
			    // Expected to be used in error messages
			    var arraySignatureMapping = {
			        "a": "arrays",
			        "b": "booleans",
			        "f": "functions",
			        "n": "numbers",
			        "o": "objects",
			        "s": "strings"
			    };

			    /**
			     * Parses a function signature definition and returns a validation function
			     * @param {string} signature - the signature between the <angle brackets>
			     * @returns {Function} validation function
			     */
			    function parseSignature(signature) {
			        // create a Regex that represents this signature and return a function that when invoked,
			        // returns the validated (possibly fixed-up) arguments, or throws a validation error
			        // step through the signature, one symbol at a time
			        var position = 1;
			        var params = [];
			        var param = {};
			        var prevParam = param;
			        while (position < signature.length) {
			            var symbol = signature.charAt(position);
			            if (symbol === ':') {
			                // TODO figure out what to do with the return type
			                // ignore it for now
			                break;
			            }

			            var next = function () {
			                params.push(param);
			                prevParam = param;
			                param = {};
			            };

			            var findClosingBracket = function (str, start, openSymbol, closeSymbol) {
			                // returns the position of the closing symbol (e.g. bracket) in a string
			                // that balances the opening symbol at position start
			                var depth = 1;
			                var position = start;
			                while (position < str.length) {
			                    position++;
			                    symbol = str.charAt(position);
			                    if (symbol === closeSymbol) {
			                        depth--;
			                        if (depth === 0) {
			                            // we're done
			                            break; // out of while loop
			                        }
			                    } else if (symbol === openSymbol) {
			                        depth++;
			                    }
			                }
			                return position;
			            };

			            switch (symbol) {
			                case 's': // string
			                case 'n': // number
			                case 'b': // boolean
			                case 'l': // not so sure about expecting null?
			                case 'o': // object
			                    param.regex = '[' + symbol + 'm]';
			                    param.type = symbol;
			                    next();
			                    break;
			                case 'a': // array
			                    //  normally treat any value as singleton array
			                    param.regex = '[asnblfom]';
			                    param.type = symbol;
			                    param.array = true;
			                    next();
			                    break;
			                case 'f': // function
			                    param.regex = 'f';
			                    param.type = symbol;
			                    next();
			                    break;
			                case 'j': // any JSON type
			                    param.regex = '[asnblom]';
			                    param.type = symbol;
			                    next();
			                    break;
			                case 'x': // any type
			                    param.regex = '[asnblfom]';
			                    param.type = symbol;
			                    next();
			                    break;
			                case '-': // use context if param not supplied
			                    prevParam.context = true;
			                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime
			                    prevParam.regex += '?';
			                    break;
			                case '?': // optional param
			                case '+': // one or more
			                    prevParam.regex += symbol;
			                    break;
			                case '(': // choice of types
			                    // search forward for matching ')'
			                    var endParen = findClosingBracket(signature, position, '(', ')');
			                    var choice = signature.substring(position + 1, endParen);
			                    if (choice.indexOf('<') === -1) {
			                        // no parameterized types, simple regex
			                        param.regex = '[' + choice + 'm]';
			                    } else {
			                        // TODO harder
			                        throw {
			                            code: "S0402",
			                            stack: (new Error()).stack,
			                            value: choice,
			                            offset: position
			                        };
			                    }
			                    param.type = '(' + choice + ')';
			                    position = endParen;
			                    next();
			                    break;
			                case '<': // type parameter - can only be applied to 'a' and 'f'
			                    if (prevParam.type === 'a' || prevParam.type === 'f') {
			                        // search forward for matching '>'
			                        var endPos = findClosingBracket(signature, position, '<', '>');
			                        prevParam.subtype = signature.substring(position + 1, endPos);
			                        position = endPos;
			                    } else {
			                        throw {
			                            code: "S0401",
			                            stack: (new Error()).stack,
			                            value: prevParam.type,
			                            offset: position
			                        };
			                    }
			                    break;
			            }
			            position++;
			        }
			        var regexStr = '^' +
			            params.map(function (param) {
			                return '(' + param.regex + ')';
			            }).join('') +
			            '$';
			        var regex = new RegExp(regexStr);
			        var getSymbol = function (value) {
			            var symbol;
			            if (utils.isFunction(value)) {
			                symbol = 'f';
			            } else {
			                var type = typeof value;
			                switch (type) {
			                    case 'string':
			                        symbol = 's';
			                        break;
			                    case 'number':
			                        symbol = 'n';
			                        break;
			                    case 'boolean':
			                        symbol = 'b';
			                        break;
			                    case 'object':
			                        if (value === null) {
			                            symbol = 'l';
			                        } else if (Array.isArray(value)) {
			                            symbol = 'a';
			                        } else {
			                            symbol = 'o';
			                        }
			                        break;
			                    case 'undefined':
			                    default:
			                        // any value can be undefined, but should be allowed to match
			                        symbol = 'm'; // m for missing
			                }
			            }
			            return symbol;
			        };

			        var throwValidationError = function (badArgs, badSig) {
			            // to figure out where this went wrong we need apply each component of the
			            // regex to each argument until we get to the one that fails to match
			            var partialPattern = '^';
			            var goodTo = 0;
			            for (var index = 0; index < params.length; index++) {
			                partialPattern += params[index].regex;
			                var match = badSig.match(partialPattern);
			                if (match === null) {
			                    // failed here
			                    throw {
			                        code: "T0410",
			                        stack: (new Error()).stack,
			                        value: badArgs[goodTo],
			                        index: goodTo + 1
			                    };
			                }
			                goodTo = match[0].length;
			            }
			            // if it got this far, it's probably because of extraneous arguments (we
			            // haven't added the trailing '$' in the regex yet.
			            throw {
			                code: "T0410",
			                stack: (new Error()).stack,
			                value: badArgs[goodTo],
			                index: goodTo + 1
			            };
			        };

			        return {
			            definition: signature,
			            validate: function (args, context) {
			                var suppliedSig = '';
			                args.forEach(function (arg) {
			                    suppliedSig += getSymbol(arg);
			                });
			                var isValid = regex.exec(suppliedSig);
			                if (isValid) {
			                    var validatedArgs = [];
			                    var argIndex = 0;
			                    params.forEach(function (param, index) {
			                        var arg = args[argIndex];
			                        var match = isValid[index + 1];
			                        if (match === '') {
			                            if (param.context && param.contextRegex) {
			                                // substitute context value for missing arg
			                                // first check that the context value is the right type
			                                var contextType = getSymbol(context);
			                                // test contextType against the regex for this arg (without the trailing ?)
			                                if (param.contextRegex.test(contextType)) {
			                                    validatedArgs.push(context);
			                                } else {
			                                    // context value not compatible with this argument
			                                    throw {
			                                        code: "T0411",
			                                        stack: (new Error()).stack,
			                                        value: context,
			                                        index: argIndex + 1
			                                    };
			                                }
			                            } else {
			                                validatedArgs.push(arg);
			                                argIndex++;
			                            }
			                        } else {
			                            // may have matched multiple args (if the regex ends with a '+'
			                            // split into single tokens
			                            match.split('').forEach(function (single) {
			                                if (param.type === 'a') {
			                                    if (single === 'm') {
			                                        // missing (undefined)
			                                        arg = undefined;
			                                    } else {
			                                        arg = args[argIndex];
			                                        var arrayOK = true;
			                                        // is there type information on the contents of the array?
			                                        if (typeof param.subtype !== 'undefined') {
			                                            if (single !== 'a' && match !== param.subtype) {
			                                                arrayOK = false;
			                                            } else if (single === 'a') {
			                                                if (arg.length > 0) {
			                                                    var itemType = getSymbol(arg[0]);
			                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further
			                                                        arrayOK = false;
			                                                    } else {
			                                                        // make sure every item in the array is this type
			                                                        var differentItems = arg.filter(function (val) {
			                                                            return (getSymbol(val) !== itemType);
			                                                        });
			                                                        arrayOK = (differentItems.length === 0);
			                                                    }
			                                                }
			                                            }
			                                        }
			                                        if (!arrayOK) {
			                                            throw {
			                                                code: "T0412",
			                                                stack: (new Error()).stack,
			                                                value: arg,
			                                                index: argIndex + 1,
			                                                type: arraySignatureMapping[param.subtype]
			                                            };
			                                        }
			                                        // the function expects an array. If it's not one, make it so
			                                        if (single !== 'a') {
			                                            arg = [arg];
			                                        }
			                                    }
			                                    validatedArgs.push(arg);
			                                    argIndex++;
			                                } else {
			                                    validatedArgs.push(arg);
			                                    argIndex++;
			                                }
			                            });
			                        }
			                    });
			                    return validatedArgs;
			                }
			                throwValidationError(args, suppliedSig);
			            }
			        };
			    }

			    return parseSignature;
			})();

			module.exports = signature;

			},{"./utils":6}],6:[function(require,module,exports){
			/**
			 * © Copyright IBM Corp. 2016, 2018 All Rights Reserved
			 *   Project name: JSONata
			 *   This project is licensed under the MIT License, see LICENSE
			 */

			const utils = (() => {

			    /**
			     * Check if value is a finite number
			     * @param {float} n - number to evaluate
			     * @returns {boolean} True if n is a finite number
			     */
			    function isNumeric(n) {
			        var isNum = false;
			        if(typeof n === 'number') {
			            isNum = !isNaN(n);
			            if (isNum && !isFinite(n)) {
			                throw {
			                    code: "D1001",
			                    value: n,
			                    stack: (new Error()).stack
			                };
			            }
			        }
			        return isNum;
			    }

			    /**
			     * Returns true if the arg is an array of strings
			     * @param {*} arg - the item to test
			     * @returns {boolean} True if arg is an array of strings
			     */
			    function isArrayOfStrings(arg) {
			        var result = false;
			        /* istanbul ignore else */
			        if(Array.isArray(arg)) {
			            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);
			        }
			        return result;
			    }

			    /**
			     * Returns true if the arg is an array of numbers
			     * @param {*} arg - the item to test
			     * @returns {boolean} True if arg is an array of numbers
			     */
			    function isArrayOfNumbers(arg) {
			        var result = false;
			        if(Array.isArray(arg)) {
			            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);
			        }
			        return result;
			    }

			    /**
			     * Create an empty sequence to contain query results
			     * @returns {Array} - empty sequence
			     */
			    function createSequence() {
			        var sequence = [];
			        sequence.sequence = true;
			        if (arguments.length === 1) {
			            sequence.push(arguments[0]);
			        }
			        return sequence;
			    }

			    /**
			     * Tests if a value is a sequence
			     * @param {*} value the value to test
			     * @returns {boolean} true if it's a sequence
			     */
			    function isSequence(value) {
			        return value.sequence === true && Array.isArray(value);
			    }

			    /**
			     *
			     * @param {Object} arg - expression to test
			     * @returns {boolean} - true if it is a function (lambda or built-in)
			     */
			    function isFunction(arg) {
			        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');
			    }

			    /**
			     * Returns the arity (number of arguments) of the function
			     * @param {*} func - the function
			     * @returns {*} - the arity
			     */
			    function getFunctionArity(func) {
			        var arity = typeof func.arity === 'number' ? func.arity :
			            typeof func.implementation === 'function' ? func.implementation.length :
			                typeof func.length === 'number' ? func.length : func.arguments.length;
			        return arity;
			    }

			    /**
			     * Tests whether arg is a lambda function
			     * @param {*} arg - the value to test
			     * @returns {boolean} - true if it is a lambda function
			     */
			    function isLambda(arg) {
			        return arg && arg._jsonata_lambda === true;
			    }

			    // istanbul ignore next
			    var $Symbol = typeof Symbol === "function" ? Symbol : {};
			    // istanbul ignore next
			    var iteratorSymbol = $Symbol.iterator || "@@iterator";

			    /**
			     * @param {Object} arg - expression to test
			     * @returns {boolean} - true if it is iterable
			     */
			    function isIterable(arg) {
			        return (
			            typeof arg === 'object' &&
			            arg !== null &&
			            iteratorSymbol in arg &&
			            'next' in arg &&
			            typeof arg.next === 'function'
			        );
			    }

			    /**
			     * Compares two values for equality
			     * @param {*} lhs first value
			     * @param {*} rhs second value
			     * @returns {boolean} true if they are deep equal
			     */
			    function isDeepEqual(lhs, rhs) {
			        if (lhs === rhs) {
			            return true;
			        }
			        if(typeof lhs === 'object' && typeof rhs === 'object' && lhs !== null && rhs !== null) {
			            if(Array.isArray(lhs) && Array.isArray(rhs)) {
			                // both arrays (or sequences)
			                // must be the same length
			                if(lhs.length !== rhs.length) {
			                    return false;
			                }
			                // must contain same values in same order
			                for(var ii = 0; ii < lhs.length; ii++) {
			                    if(!isDeepEqual(lhs[ii], rhs[ii])) {
			                        return false;
			                    }
			                }
			                return true;
			            }
			            // both objects
			            // must have the same set of keys (in any order)
			            var lkeys = Object.getOwnPropertyNames(lhs);
			            var rkeys = Object.getOwnPropertyNames(rhs);
			            if(lkeys.length !== rkeys.length) {
			                return false;
			            }
			            lkeys = lkeys.sort();
			            rkeys = rkeys.sort();
			            for(ii=0; ii < lkeys.length; ii++) {
			                if(lkeys[ii] !== rkeys[ii]) {
			                    return false;
			                }
			            }
			            // must have the same values
			            for(ii=0; ii < lkeys.length; ii++) {
			                var key = lkeys[ii];
			                if(!isDeepEqual(lhs[key], rhs[key])) {
			                    return false;
			                }
			            }
			            return true;
			        }
			        return false;
			    }

			    /**
			     * converts a string to an array of characters
			     * @param {string} str - the input string
			     * @returns {Array} - the array of characters
			     */
			    function stringToArray(str) {
			        var arr = [];
			        for (let char of str) {
			            arr.push(char);
			        }
			        return arr;
			    }

			    return {
			        isNumeric,
			        isArrayOfStrings,
			        isArrayOfNumbers,
			        createSequence,
			        isSequence,
			        isFunction,
			        isLambda,
			        isIterable,
			        getFunctionArity,
			        isDeepEqual,
			        stringToArray
			    };
			})();

			module.exports = utils;

			},{}]},{},[3])(3)
			}); 
		} (jsonata));
		return jsonata.exports;
	}

	requireJsonata();

	var FieldMappingDirection;
	(function (FieldMappingDirection) {
	    FieldMappingDirection["IMPORT"] = "import";
	    FieldMappingDirection["EXPORT"] = "export";
	    FieldMappingDirection["BOTH"] = "both";
	})(FieldMappingDirection || (FieldMappingDirection = {}));

	var ActionType;
	(function (ActionType) {
	    ActionType["ListDataRecords"] = "list-data-records";
	    ActionType["FindDataRecordById"] = "find-data-record-by-id";
	    ActionType["MatchDataRecord"] = "match-data-record";
	    ActionType["CreateDataRecord"] = "create-data-record";
	    ActionType["FindOrCreateDataRecord"] = "find-or-create-data-record";
	    ActionType["UpdateDataRecord"] = "update-data-record";
	    ActionType["DeleteDataRecord"] = "delete-data-record";
	    ActionType["SearchDataRecords"] = "search-data-record";
	    ActionType["ConnectorOperation"] = "connector-operation";
	    ActionType["ApiRequestToExternalApp"] = "api-request-to-external-app";
	    ActionType["ApiRequestToYourApp"] = "api-request-to-your-app";
	    ActionType["HttpRequest"] = "http-request";
	    ActionType["RunJavascript"] = "run-javascript";
	    ActionType["ApiRequest"] = "api-request";
	})(ActionType || (ActionType = {}));
	({
	    [ActionType.ListDataRecords]: {
	        direction: FieldMappingDirection.IMPORT,
	    },
	    [ActionType.FindDataRecordById]: {
	        direction: FieldMappingDirection.IMPORT,
	    },
	    [ActionType.MatchDataRecord]: {
	        direction: FieldMappingDirection.IMPORT,
	    },
	    [ActionType.CreateDataRecord]: {
	        direction: FieldMappingDirection.EXPORT,
	    },
	    [ActionType.FindOrCreateDataRecord]: {
	        direction: FieldMappingDirection.EXPORT,
	    },
	    [ActionType.UpdateDataRecord]: {
	        direction: FieldMappingDirection.EXPORT,
	    },
	    [ActionType.DeleteDataRecord]: {
	        direction: FieldMappingDirection.EXPORT,
	    },
	    [ActionType.SearchDataRecords]: {
	        direction: FieldMappingDirection.IMPORT,
	    },
	    [ActionType.ConnectorOperation]: {
	        },
	    [ActionType.ApiRequestToExternalApp]: {
	        },
	    [ActionType.ApiRequestToYourApp]: {
	        },
	    [ActionType.HttpRequest]: {
	        },
	    [ActionType.RunJavascript]: {
	        },
	    [ActionType.ApiRequest]: {
	        },
	});

	var ActionDependencyType;
	(function (ActionDependencyType) {
	    ActionDependencyType["FieldMapping"] = "FieldMapping";
	    ActionDependencyType["DataSource"] = "DataSource";
	})(ActionDependencyType || (ActionDependencyType = {}));

	/*! Axios v1.8.4 Copyright (c) 2025 Matt Zabriskie and contributors */
	function bind(fn, thisArg) {
	  return function wrap() {
	    return fn.apply(thisArg, arguments);
	  };
	}

	// utils is a library of generic helper functions non-specific to axios

	const {toString} = Object.prototype;
	const {getPrototypeOf} = Object;

	const kindOf = (cache => thing => {
	    const str = toString.call(thing);
	    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	})(Object.create(null));

	const kindOfTest = (type) => {
	  type = type.toLowerCase();
	  return (thing) => kindOf(thing) === type
	};

	const typeOfTest = type => thing => typeof thing === type;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 *
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	const {isArray} = Array;

	/**
	 * Determine if a value is undefined
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	const isUndefined = typeOfTest('undefined');

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	const isArrayBuffer = kindOfTest('ArrayBuffer');


	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  let result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	const isString = typeOfTest('string');

	/**
	 * Determine if a value is a Function
	 *
	 * @param {*} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	const isFunction = typeOfTest('function');

	/**
	 * Determine if a value is a Number
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	const isNumber = typeOfTest('number');

	/**
	 * Determine if a value is an Object
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	const isObject = (thing) => thing !== null && typeof thing === 'object';

	/**
	 * Determine if a value is a Boolean
	 *
	 * @param {*} thing The value to test
	 * @returns {boolean} True if value is a Boolean, otherwise false
	 */
	const isBoolean = thing => thing === true || thing === false;

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a plain Object, otherwise false
	 */
	const isPlainObject = (val) => {
	  if (kindOf(val) !== 'object') {
	    return false;
	  }

	  const prototype = getPrototypeOf(val);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
	};

	/**
	 * Determine if a value is a Date
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	const isDate = kindOfTest('Date');

	/**
	 * Determine if a value is a File
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFile = kindOfTest('File');

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	const isBlob = kindOfTest('Blob');

	/**
	 * Determine if a value is a FileList
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFileList = kindOfTest('FileList');

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	const isStream = (val) => isObject(val) && isFunction(val.pipe);

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	const isFormData = (thing) => {
	  let kind;
	  return thing && (
	    (typeof FormData === 'function' && thing instanceof FormData) || (
	      isFunction(thing.append) && (
	        (kind = kindOf(thing)) === 'formdata' ||
	        // detect form-data instance
	        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
	      )
	    )
	  )
	};

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	const isURLSearchParams = kindOfTest('URLSearchParams');

	const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 *
	 * @returns {String} The String freed of excess whitespace
	 */
	const trim = (str) => str.trim ?
	  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 *
	 * @param {Boolean} [allOwnKeys = false]
	 * @returns {any}
	 */
	function forEach(obj, fn, {allOwnKeys = false} = {}) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  let i;
	  let l;

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
	    const len = keys.length;
	    let key;

	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      fn.call(null, obj[key], key, obj);
	    }
	  }
	}

	function findKey(obj, key) {
	  key = key.toLowerCase();
	  const keys = Object.keys(obj);
	  let i = keys.length;
	  let _key;
	  while (i-- > 0) {
	    _key = keys[i];
	    if (key === _key.toLowerCase()) {
	      return _key;
	    }
	  }
	  return null;
	}

	const _global = (() => {
	  /*eslint no-undef:0*/
	  if (typeof globalThis !== "undefined") return globalThis;
	  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global$1)
	})();

	const isContextDefined = (context) => !isUndefined(context) && context !== _global;

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 *
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  const {caseless} = isContextDefined(this) && this || {};
	  const result = {};
	  const assignValue = (val, key) => {
	    const targetKey = caseless && findKey(result, key) || key;
	    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
	      result[targetKey] = merge(result[targetKey], val);
	    } else if (isPlainObject(val)) {
	      result[targetKey] = merge({}, val);
	    } else if (isArray(val)) {
	      result[targetKey] = val.slice();
	    } else {
	      result[targetKey] = val;
	    }
	  };

	  for (let i = 0, l = arguments.length; i < l; i++) {
	    arguments[i] && forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 *
	 * @param {Boolean} [allOwnKeys]
	 * @returns {Object} The resulting value of object a
	 */
	const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
	  forEach(b, (val, key) => {
	    if (thisArg && isFunction(val)) {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  }, {allOwnKeys});
	  return a;
	};

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 *
	 * @returns {string} content value without BOM
	 */
	const stripBOM = (content) => {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	};

	/**
	 * Inherit the prototype methods from one constructor into another
	 * @param {function} constructor
	 * @param {function} superConstructor
	 * @param {object} [props]
	 * @param {object} [descriptors]
	 *
	 * @returns {void}
	 */
	const inherits = (constructor, superConstructor, props, descriptors) => {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	  constructor.prototype.constructor = constructor;
	  Object.defineProperty(constructor, 'super', {
	    value: superConstructor.prototype
	  });
	  props && Object.assign(constructor.prototype, props);
	};

	/**
	 * Resolve object with deep prototype chain to a flat object
	 * @param {Object} sourceObj source object
	 * @param {Object} [destObj]
	 * @param {Function|Boolean} [filter]
	 * @param {Function} [propFilter]
	 *
	 * @returns {Object}
	 */
	const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	  let props;
	  let i;
	  let prop;
	  const merged = {};

	  destObj = destObj || {};
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  if (sourceObj == null) return destObj;

	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = filter !== false && getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

	  return destObj;
	};

	/**
	 * Determines whether a string ends with the characters of a specified string
	 *
	 * @param {String} str
	 * @param {String} searchString
	 * @param {Number} [position= 0]
	 *
	 * @returns {boolean}
	 */
	const endsWith = (str, searchString, position) => {
	  str = String(str);
	  if (position === undefined || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  const lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	};


	/**
	 * Returns new array from array like object or null if failed
	 *
	 * @param {*} [thing]
	 *
	 * @returns {?Array}
	 */
	const toArray = (thing) => {
	  if (!thing) return null;
	  if (isArray(thing)) return thing;
	  let i = thing.length;
	  if (!isNumber(i)) return null;
	  const arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	};

	/**
	 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
	 * thing passed in is an instance of Uint8Array
	 *
	 * @param {TypedArray}
	 *
	 * @returns {Array}
	 */
	// eslint-disable-next-line func-names
	const isTypedArray = (TypedArray => {
	  // eslint-disable-next-line func-names
	  return thing => {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

	/**
	 * For each entry in the object, call the function with the key and value.
	 *
	 * @param {Object<any, any>} obj - The object to iterate over.
	 * @param {Function} fn - The function to call for each entry.
	 *
	 * @returns {void}
	 */
	const forEachEntry = (obj, fn) => {
	  const generator = obj && obj[Symbol.iterator];

	  const iterator = generator.call(obj);

	  let result;

	  while ((result = iterator.next()) && !result.done) {
	    const pair = result.value;
	    fn.call(obj, pair[0], pair[1]);
	  }
	};

	/**
	 * It takes a regular expression and a string, and returns an array of all the matches
	 *
	 * @param {string} regExp - The regular expression to match against.
	 * @param {string} str - The string to search.
	 *
	 * @returns {Array<boolean>}
	 */
	const matchAll = (regExp, str) => {
	  let matches;
	  const arr = [];

	  while ((matches = regExp.exec(str)) !== null) {
	    arr.push(matches);
	  }

	  return arr;
	};

	/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
	const isHTMLForm = kindOfTest('HTMLFormElement');

	const toCamelCase = str => {
	  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
	    function replacer(m, p1, p2) {
	      return p1.toUpperCase() + p2;
	    }
	  );
	};

	/* Creating a function that will check if an object has a property. */
	const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

	/**
	 * Determine if a value is a RegExp object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a RegExp object, otherwise false
	 */
	const isRegExp = kindOfTest('RegExp');

	const reduceDescriptors = (obj, reducer) => {
	  const descriptors = Object.getOwnPropertyDescriptors(obj);
	  const reducedDescriptors = {};

	  forEach(descriptors, (descriptor, name) => {
	    let ret;
	    if ((ret = reducer(descriptor, name, obj)) !== false) {
	      reducedDescriptors[name] = ret || descriptor;
	    }
	  });

	  Object.defineProperties(obj, reducedDescriptors);
	};

	/**
	 * Makes all methods read-only
	 * @param {Object} obj
	 */

	const freezeMethods = (obj) => {
	  reduceDescriptors(obj, (descriptor, name) => {
	    // skip restricted props in strict mode
	    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
	      return false;
	    }

	    const value = obj[name];

	    if (!isFunction(value)) return;

	    descriptor.enumerable = false;

	    if ('writable' in descriptor) {
	      descriptor.writable = false;
	      return;
	    }

	    if (!descriptor.set) {
	      descriptor.set = () => {
	        throw Error('Can not rewrite read-only method \'' + name + '\'');
	      };
	    }
	  });
	};

	const toObjectSet = (arrayOrString, delimiter) => {
	  const obj = {};

	  const define = (arr) => {
	    arr.forEach(value => {
	      obj[value] = true;
	    });
	  };

	  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

	  return obj;
	};

	const noop = () => {};

	const toFiniteNumber = (value, defaultValue) => {
	  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
	};

	/**
	 * If the thing is a FormData object, return true, otherwise return false.
	 *
	 * @param {unknown} thing - The thing to check.
	 *
	 * @returns {boolean}
	 */
	function isSpecCompliantForm(thing) {
	  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
	}

	const toJSONObject = (obj) => {
	  const stack = new Array(10);

	  const visit = (source, i) => {

	    if (isObject(source)) {
	      if (stack.indexOf(source) >= 0) {
	        return;
	      }

	      if(!('toJSON' in source)) {
	        stack[i] = source;
	        const target = isArray(source) ? [] : {};

	        forEach(source, (value, key) => {
	          const reducedValue = visit(value, i + 1);
	          !isUndefined(reducedValue) && (target[key] = reducedValue);
	        });

	        stack[i] = undefined;

	        return target;
	      }
	    }

	    return source;
	  };

	  return visit(obj, 0);
	};

	const isAsyncFn = kindOfTest('AsyncFunction');

	const isThenable = (thing) =>
	  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

	// original code
	// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

	const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	  if (setImmediateSupported) {
	    return setImmediate;
	  }

	  return postMessageSupported ? ((token, callbacks) => {
	    _global.addEventListener("message", ({source, data}) => {
	      if (source === _global && data === token) {
	        callbacks.length && callbacks.shift()();
	      }
	    }, false);

	    return (cb) => {
	      callbacks.push(cb);
	      _global.postMessage(token, "*");
	    }
	  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
	})(
	  typeof setImmediate === 'function',
	  isFunction(_global.postMessage)
	);

	const asap = typeof queueMicrotask !== 'undefined' ?
	  queueMicrotask.bind(_global) : ( typeof browser$1 !== 'undefined' && browser$1.nextTick || _setImmediate);

	// *********************

	const utils$1 = {
	  isArray,
	  isArrayBuffer,
	  isBuffer,
	  isFormData,
	  isArrayBufferView,
	  isString,
	  isNumber,
	  isBoolean,
	  isObject,
	  isPlainObject,
	  isReadableStream,
	  isRequest,
	  isResponse,
	  isHeaders,
	  isUndefined,
	  isDate,
	  isFile,
	  isBlob,
	  isRegExp,
	  isFunction,
	  isStream,
	  isURLSearchParams,
	  isTypedArray,
	  isFileList,
	  forEach,
	  merge,
	  extend,
	  trim,
	  stripBOM,
	  inherits,
	  toFlatObject,
	  kindOf,
	  kindOfTest,
	  endsWith,
	  toArray,
	  forEachEntry,
	  matchAll,
	  isHTMLForm,
	  hasOwnProperty,
	  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
	  reduceDescriptors,
	  freezeMethods,
	  toObjectSet,
	  toCamelCase,
	  noop,
	  toFiniteNumber,
	  findKey,
	  global: _global,
	  isContextDefined,
	  isSpecCompliantForm,
	  toJSONObject,
	  isAsyncFn,
	  isThenable,
	  setImmediate: _setImmediate,
	  asap
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 *
	 * @returns {Error} The created error.
	 */
	function AxiosError$1(message, code, config, request, response) {
	  Error.call(this);

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = (new Error()).stack;
	  }

	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  if (response) {
	    this.response = response;
	    this.status = response.status ? response.status : null;
	  }
	}

	utils$1.inherits(AxiosError$1, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: utils$1.toJSONObject(this.config),
	      code: this.code,
	      status: this.status
	    };
	  }
	});

	const prototype$1 = AxiosError$1.prototype;
	const descriptors = {};

	[
	  'ERR_BAD_OPTION_VALUE',
	  'ERR_BAD_OPTION',
	  'ECONNABORTED',
	  'ETIMEDOUT',
	  'ERR_NETWORK',
	  'ERR_FR_TOO_MANY_REDIRECTS',
	  'ERR_DEPRECATED',
	  'ERR_BAD_RESPONSE',
	  'ERR_BAD_REQUEST',
	  'ERR_CANCELED',
	  'ERR_NOT_SUPPORT',
	  'ERR_INVALID_URL'
	// eslint-disable-next-line func-names
	].forEach(code => {
	  descriptors[code] = {value: code};
	});

	Object.defineProperties(AxiosError$1, descriptors);
	Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

	// eslint-disable-next-line func-names
	AxiosError$1.from = (error, code, config, request, response, customProps) => {
	  const axiosError = Object.create(prototype$1);

	  utils$1.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  }, prop => {
	    return prop !== 'isAxiosError';
	  });

	  AxiosError$1.call(axiosError, error.message, code, config, request, response);

	  axiosError.cause = error;

	  axiosError.name = error.name;

	  customProps && Object.assign(axiosError, customProps);

	  return axiosError;
	};

	// eslint-disable-next-line strict
	const httpAdapter = null;

	/**
	 * Determines if the given thing is a array or js object.
	 *
	 * @param {string} thing - The object or array to be visited.
	 *
	 * @returns {boolean}
	 */
	function isVisitable(thing) {
	  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
	}

	/**
	 * It removes the brackets from the end of a string
	 *
	 * @param {string} key - The key of the parameter.
	 *
	 * @returns {string} the key without the brackets.
	 */
	function removeBrackets(key) {
	  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
	}

	/**
	 * It takes a path, a key, and a boolean, and returns a string
	 *
	 * @param {string} path - The path to the current key.
	 * @param {string} key - The key of the current object being iterated over.
	 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
	 *
	 * @returns {string} The path to the current key.
	 */
	function renderKey(path, key, dots) {
	  if (!path) return key;
	  return path.concat(key).map(function each(token, i) {
	    // eslint-disable-next-line no-param-reassign
	    token = removeBrackets(token);
	    return !dots && i ? '[' + token + ']' : token;
	  }).join(dots ? '.' : '');
	}

	/**
	 * If the array is an array and none of its elements are visitable, then it's a flat array.
	 *
	 * @param {Array<any>} arr - The array to check
	 *
	 * @returns {boolean}
	 */
	function isFlatArray(arr) {
	  return utils$1.isArray(arr) && !arr.some(isVisitable);
	}

	const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
	  return /^is[A-Z]/.test(prop);
	});

	/**
	 * Convert a data object to FormData
	 *
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @param {?Object} [options]
	 * @param {Function} [options.visitor]
	 * @param {Boolean} [options.metaTokens = true]
	 * @param {Boolean} [options.dots = false]
	 * @param {?Boolean} [options.indexes = false]
	 *
	 * @returns {Object}
	 **/

	/**
	 * It converts an object into a FormData object
	 *
	 * @param {Object<any, any>} obj - The object to convert to form data.
	 * @param {string} formData - The FormData object to append to.
	 * @param {Object<string, any>} options
	 *
	 * @returns
	 */
	function toFormData$1(obj, formData, options) {
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('target must be an object');
	  }

	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new (FormData)();

	  // eslint-disable-next-line no-param-reassign
	  options = utils$1.toFlatObject(options, {
	    metaTokens: true,
	    dots: false,
	    indexes: false
	  }, false, function defined(option, source) {
	    // eslint-disable-next-line no-eq-null,eqeqeq
	    return !utils$1.isUndefined(source[option]);
	  });

	  const metaTokens = options.metaTokens;
	  // eslint-disable-next-line no-use-before-define
	  const visitor = options.visitor || defaultVisitor;
	  const dots = options.dots;
	  const indexes = options.indexes;
	  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
	  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

	  if (!utils$1.isFunction(visitor)) {
	    throw new TypeError('visitor must be a function');
	  }

	  function convertValue(value) {
	    if (value === null) return '';

	    if (utils$1.isDate(value)) {
	      return value.toISOString();
	    }

	    if (!useBlob && utils$1.isBlob(value)) {
	      throw new AxiosError$1('Blob is not supported. Use a Buffer instead.');
	    }

	    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
	      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer$1.from(value);
	    }

	    return value;
	  }

	  /**
	   * Default visitor.
	   *
	   * @param {*} value
	   * @param {String|Number} key
	   * @param {Array<String|Number>} path
	   * @this {FormData}
	   *
	   * @returns {boolean} return true to visit the each prop of the value recursively
	   */
	  function defaultVisitor(value, key, path) {
	    let arr = value;

	    if (value && !path && typeof value === 'object') {
	      if (utils$1.endsWith(key, '{}')) {
	        // eslint-disable-next-line no-param-reassign
	        key = metaTokens ? key : key.slice(0, -2);
	        // eslint-disable-next-line no-param-reassign
	        value = JSON.stringify(value);
	      } else if (
	        (utils$1.isArray(value) && isFlatArray(value)) ||
	        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
	        )) {
	        // eslint-disable-next-line no-param-reassign
	        key = removeBrackets(key);

	        arr.forEach(function each(el, index) {
	          !(utils$1.isUndefined(el) || el === null) && formData.append(
	            // eslint-disable-next-line no-nested-ternary
	            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
	            convertValue(el)
	          );
	        });
	        return false;
	      }
	    }

	    if (isVisitable(value)) {
	      return true;
	    }

	    formData.append(renderKey(path, key, dots), convertValue(value));

	    return false;
	  }

	  const stack = [];

	  const exposedHelpers = Object.assign(predicates, {
	    defaultVisitor,
	    convertValue,
	    isVisitable
	  });

	  function build(value, path) {
	    if (utils$1.isUndefined(value)) return;

	    if (stack.indexOf(value) !== -1) {
	      throw Error('Circular reference detected in ' + path.join('.'));
	    }

	    stack.push(value);

	    utils$1.forEach(value, function each(el, key) {
	      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
	        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
	      );

	      if (result === true) {
	        build(el, path ? path.concat(key) : [key]);
	      }
	    });

	    stack.pop();
	  }

	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('data must be an object');
	  }

	  build(obj);

	  return formData;
	}

	/**
	 * It encodes a string by replacing all characters that are not in the unreserved set with
	 * their percent-encoded equivalents
	 *
	 * @param {string} str - The string to encode.
	 *
	 * @returns {string} The encoded string.
	 */
	function encode$1(str) {
	  const charMap = {
	    '!': '%21',
	    "'": '%27',
	    '(': '%28',
	    ')': '%29',
	    '~': '%7E',
	    '%20': '+',
	    '%00': '\x00'
	  };
	  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
	    return charMap[match];
	  });
	}

	/**
	 * It takes a params object and converts it to a FormData object
	 *
	 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
	 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
	 *
	 * @returns {void}
	 */
	function AxiosURLSearchParams(params, options) {
	  this._pairs = [];

	  params && toFormData$1(params, this, options);
	}

	const prototype = AxiosURLSearchParams.prototype;

	prototype.append = function append(name, value) {
	  this._pairs.push([name, value]);
	};

	prototype.toString = function toString(encoder) {
	  const _encode = encoder ? function(value) {
	    return encoder.call(this, value, encode$1);
	  } : encode$1;

	  return this._pairs.map(function each(pair) {
	    return _encode(pair[0]) + '=' + _encode(pair[1]);
	  }, '').join('&');
	};

	/**
	 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
	 * URI encoded counterparts
	 *
	 * @param {string} val The value to be encoded.
	 *
	 * @returns {string} The encoded value.
	 */
	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @param {?(object|Function)} options
	 *
	 * @returns {string} The formatted url
	 */
	function buildURL(url, params, options) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	  
	  const _encode = options && options.encode || encode;

	  if (utils$1.isFunction(options)) {
	    options = {
	      serialize: options
	    };
	  } 

	  const serializeFn = options && options.serialize;

	  let serializedParams;

	  if (serializeFn) {
	    serializedParams = serializeFn(params, options);
	  } else {
	    serializedParams = utils$1.isURLSearchParams(params) ?
	      params.toString() :
	      new AxiosURLSearchParams(params, options).toString(_encode);
	  }

	  if (serializedParams) {
	    const hashmarkIndex = url.indexOf("#");

	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	}

	class InterceptorManager {
	  constructor() {
	    this.handlers = [];
	  }

	  /**
	   * Add a new interceptor to the stack
	   *
	   * @param {Function} fulfilled The function to handle `then` for a `Promise`
	   * @param {Function} rejected The function to handle `reject` for a `Promise`
	   *
	   * @return {Number} An ID used to remove interceptor later
	   */
	  use(fulfilled, rejected, options) {
	    this.handlers.push({
	      fulfilled,
	      rejected,
	      synchronous: options ? options.synchronous : false,
	      runWhen: options ? options.runWhen : null
	    });
	    return this.handlers.length - 1;
	  }

	  /**
	   * Remove an interceptor from the stack
	   *
	   * @param {Number} id The ID that was returned by `use`
	   *
	   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
	   */
	  eject(id) {
	    if (this.handlers[id]) {
	      this.handlers[id] = null;
	    }
	  }

	  /**
	   * Clear all interceptors from the stack
	   *
	   * @returns {void}
	   */
	  clear() {
	    if (this.handlers) {
	      this.handlers = [];
	    }
	  }

	  /**
	   * Iterate over all the registered interceptors
	   *
	   * This method is particularly useful for skipping over any
	   * interceptors that may have become `null` calling `eject`.
	   *
	   * @param {Function} fn The function to call for each interceptor
	   *
	   * @returns {void}
	   */
	  forEach(fn) {
	    utils$1.forEach(this.handlers, function forEachHandler(h) {
	      if (h !== null) {
	        fn(h);
	      }
	    });
	  }
	}

	const InterceptorManager$1 = InterceptorManager;

	const transitionalDefaults = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};

	const URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

	const FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

	const Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

	const platform$1 = {
	  isBrowser: true,
	  classes: {
	    URLSearchParams: URLSearchParams$1,
	    FormData: FormData$1,
	    Blob: Blob$1
	  },
	  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
	};

	const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

	const _navigator = typeof navigator === 'object' && navigator || undefined;

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 *
	 * @returns {boolean}
	 */
	const hasStandardBrowserEnv = hasBrowserEnv &&
	  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

	/**
	 * Determine if we're running in a standard browser webWorker environment
	 *
	 * Although the `isStandardBrowserEnv` method indicates that
	 * `allows axios to run in a web worker`, the WebWorker will still be
	 * filtered out due to its judgment standard
	 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
	 * This leads to a problem when axios post `FormData` in webWorker
	 */
	const hasStandardBrowserWebWorkerEnv = (() => {
	  return (
	    typeof WorkerGlobalScope !== 'undefined' &&
	    // eslint-disable-next-line no-undef
	    self instanceof WorkerGlobalScope &&
	    typeof self.importScripts === 'function'
	  );
	})();

	const origin = hasBrowserEnv && window.location.href || 'http://localhost';

	const utils = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  hasBrowserEnv: hasBrowserEnv,
	  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
	  hasStandardBrowserEnv: hasStandardBrowserEnv,
	  navigator: _navigator,
	  origin: origin
	});

	const platform = {
	  ...utils,
	  ...platform$1
	};

	function toURLEncodedForm(data, options) {
	  return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
	    visitor: function(value, key, path, helpers) {
	      if (platform.isNode && utils$1.isBuffer(value)) {
	        this.append(key, value.toString('base64'));
	        return false;
	      }

	      return helpers.defaultVisitor.apply(this, arguments);
	    }
	  }, options));
	}

	/**
	 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
	 *
	 * @param {string} name - The name of the property to get.
	 *
	 * @returns An array of strings.
	 */
	function parsePropPath(name) {
	  // foo[x][y][z]
	  // foo.x.y.z
	  // foo-x-y-z
	  // foo x y z
	  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
	    return match[0] === '[]' ? '' : match[1] || match[0];
	  });
	}

	/**
	 * Convert an array to an object.
	 *
	 * @param {Array<any>} arr - The array to convert to an object.
	 *
	 * @returns An object with the same keys and values as the array.
	 */
	function arrayToObject(arr) {
	  const obj = {};
	  const keys = Object.keys(arr);
	  let i;
	  const len = keys.length;
	  let key;
	  for (i = 0; i < len; i++) {
	    key = keys[i];
	    obj[key] = arr[key];
	  }
	  return obj;
	}

	/**
	 * It takes a FormData object and returns a JavaScript object
	 *
	 * @param {string} formData The FormData object to convert to JSON.
	 *
	 * @returns {Object<string, any> | null} The converted object.
	 */
	function formDataToJSON(formData) {
	  function buildPath(path, value, target, index) {
	    let name = path[index++];

	    if (name === '__proto__') return true;

	    const isNumericKey = Number.isFinite(+name);
	    const isLast = index >= path.length;
	    name = !name && utils$1.isArray(target) ? target.length : name;

	    if (isLast) {
	      if (utils$1.hasOwnProp(target, name)) {
	        target[name] = [target[name], value];
	      } else {
	        target[name] = value;
	      }

	      return !isNumericKey;
	    }

	    if (!target[name] || !utils$1.isObject(target[name])) {
	      target[name] = [];
	    }

	    const result = buildPath(path, value, target[name], index);

	    if (result && utils$1.isArray(target[name])) {
	      target[name] = arrayToObject(target[name]);
	    }

	    return !isNumericKey;
	  }

	  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
	    const obj = {};

	    utils$1.forEachEntry(formData, (name, value) => {
	      buildPath(parsePropPath(name), value, obj, 0);
	    });

	    return obj;
	  }

	  return null;
	}

	/**
	 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
	 * of the input
	 *
	 * @param {any} rawValue - The value to be stringified.
	 * @param {Function} parser - A function that parses a string into a JavaScript object.
	 * @param {Function} encoder - A function that takes a value and returns a string.
	 *
	 * @returns {string} A stringified version of the rawValue.
	 */
	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$1.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$1.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }

	  return (encoder || JSON.stringify)(rawValue);
	}

	const defaults = {

	  transitional: transitionalDefaults,

	  adapter: ['xhr', 'http', 'fetch'],

	  transformRequest: [function transformRequest(data, headers) {
	    const contentType = headers.getContentType() || '';
	    const hasJSONContentType = contentType.indexOf('application/json') > -1;
	    const isObjectPayload = utils$1.isObject(data);

	    if (isObjectPayload && utils$1.isHTMLForm(data)) {
	      data = new FormData(data);
	    }

	    const isFormData = utils$1.isFormData(data);

	    if (isFormData) {
	      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
	    }

	    if (utils$1.isArrayBuffer(data) ||
	      utils$1.isBuffer(data) ||
	      utils$1.isStream(data) ||
	      utils$1.isFile(data) ||
	      utils$1.isBlob(data) ||
	      utils$1.isReadableStream(data)
	    ) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
	      return data.toString();
	    }

	    let isFileList;

	    if (isObjectPayload) {
	      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
	        return toURLEncodedForm(data, this.formSerializer).toString();
	      }

	      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
	        const _FormData = this.env && this.env.FormData;

	        return toFormData$1(
	          isFileList ? {'files[]': data} : data,
	          _FormData && new _FormData(),
	          this.formSerializer
	        );
	      }
	    }

	    if (isObjectPayload || hasJSONContentType ) {
	      headers.setContentType('application/json', false);
	      return stringifySafely(data);
	    }

	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    const transitional = this.transitional || defaults.transitional;
	    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    const JSONRequested = this.responseType === 'json';

	    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }

	    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
	      const silentJSONParsing = transitional && transitional.silentJSONParsing;
	      const strictJSONParsing = !silentJSONParsing && JSONRequested;

	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }

	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,
	  maxBodyLength: -1,

	  env: {
	    FormData: platform.classes.FormData,
	    Blob: platform.classes.Blob
	  },

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },

	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*',
	      'Content-Type': undefined
	    }
	  }
	};

	utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
	  defaults.headers[method] = {};
	});

	const defaults$1 = defaults;

	// RawAxiosHeaders whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	const ignoreDuplicateOf = utils$1.toObjectSet([
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	]);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} rawHeaders Headers needing to be parsed
	 *
	 * @returns {Object} Headers parsed into an object
	 */
	const parseHeaders = rawHeaders => {
	  const parsed = {};
	  let key;
	  let val;
	  let i;

	  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
	    i = line.indexOf(':');
	    key = line.substring(0, i).trim().toLowerCase();
	    val = line.substring(i + 1).trim();

	    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
	      return;
	    }

	    if (key === 'set-cookie') {
	      if (parsed[key]) {
	        parsed[key].push(val);
	      } else {
	        parsed[key] = [val];
	      }
	    } else {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });

	  return parsed;
	};

	const $internals = Symbol('internals');

	function normalizeHeader(header) {
	  return header && String(header).trim().toLowerCase();
	}

	function normalizeValue(value) {
	  if (value === false || value == null) {
	    return value;
	  }

	  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
	}

	function parseTokens(str) {
	  const tokens = Object.create(null);
	  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	  let match;

	  while ((match = tokensRE.exec(str))) {
	    tokens[match[1]] = match[2];
	  }

	  return tokens;
	}

	const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

	function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	  if (utils$1.isFunction(filter)) {
	    return filter.call(this, value, header);
	  }

	  if (isHeaderNameFilter) {
	    value = header;
	  }

	  if (!utils$1.isString(value)) return;

	  if (utils$1.isString(filter)) {
	    return value.indexOf(filter) !== -1;
	  }

	  if (utils$1.isRegExp(filter)) {
	    return filter.test(value);
	  }
	}

	function formatHeader(header) {
	  return header.trim()
	    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
	      return char.toUpperCase() + str;
	    });
	}

	function buildAccessors(obj, header) {
	  const accessorName = utils$1.toCamelCase(' ' + header);

	  ['get', 'set', 'has'].forEach(methodName => {
	    Object.defineProperty(obj, methodName + accessorName, {
	      value: function(arg1, arg2, arg3) {
	        return this[methodName].call(this, header, arg1, arg2, arg3);
	      },
	      configurable: true
	    });
	  });
	}

	class AxiosHeaders$1 {
	  constructor(headers) {
	    headers && this.set(headers);
	  }

	  set(header, valueOrRewrite, rewrite) {
	    const self = this;

	    function setHeader(_value, _header, _rewrite) {
	      const lHeader = normalizeHeader(_header);

	      if (!lHeader) {
	        throw new Error('header name must be a non-empty string');
	      }

	      const key = utils$1.findKey(self, lHeader);

	      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
	        self[key || _header] = normalizeValue(_value);
	      }
	    }

	    const setHeaders = (headers, _rewrite) =>
	      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

	    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
	      setHeaders(header, valueOrRewrite);
	    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
	      setHeaders(parseHeaders(header), valueOrRewrite);
	    } else if (utils$1.isHeaders(header)) {
	      for (const [key, value] of header.entries()) {
	        setHeader(value, key, rewrite);
	      }
	    } else {
	      header != null && setHeader(valueOrRewrite, header, rewrite);
	    }

	    return this;
	  }

	  get(header, parser) {
	    header = normalizeHeader(header);

	    if (header) {
	      const key = utils$1.findKey(this, header);

	      if (key) {
	        const value = this[key];

	        if (!parser) {
	          return value;
	        }

	        if (parser === true) {
	          return parseTokens(value);
	        }

	        if (utils$1.isFunction(parser)) {
	          return parser.call(this, value, key);
	        }

	        if (utils$1.isRegExp(parser)) {
	          return parser.exec(value);
	        }

	        throw new TypeError('parser must be boolean|regexp|function');
	      }
	    }
	  }

	  has(header, matcher) {
	    header = normalizeHeader(header);

	    if (header) {
	      const key = utils$1.findKey(this, header);

	      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
	    }

	    return false;
	  }

	  delete(header, matcher) {
	    const self = this;
	    let deleted = false;

	    function deleteHeader(_header) {
	      _header = normalizeHeader(_header);

	      if (_header) {
	        const key = utils$1.findKey(self, _header);

	        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
	          delete self[key];

	          deleted = true;
	        }
	      }
	    }

	    if (utils$1.isArray(header)) {
	      header.forEach(deleteHeader);
	    } else {
	      deleteHeader(header);
	    }

	    return deleted;
	  }

	  clear(matcher) {
	    const keys = Object.keys(this);
	    let i = keys.length;
	    let deleted = false;

	    while (i--) {
	      const key = keys[i];
	      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
	        delete this[key];
	        deleted = true;
	      }
	    }

	    return deleted;
	  }

	  normalize(format) {
	    const self = this;
	    const headers = {};

	    utils$1.forEach(this, (value, header) => {
	      const key = utils$1.findKey(headers, header);

	      if (key) {
	        self[key] = normalizeValue(value);
	        delete self[header];
	        return;
	      }

	      const normalized = format ? formatHeader(header) : String(header).trim();

	      if (normalized !== header) {
	        delete self[header];
	      }

	      self[normalized] = normalizeValue(value);

	      headers[normalized] = true;
	    });

	    return this;
	  }

	  concat(...targets) {
	    return this.constructor.concat(this, ...targets);
	  }

	  toJSON(asStrings) {
	    const obj = Object.create(null);

	    utils$1.forEach(this, (value, header) => {
	      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
	    });

	    return obj;
	  }

	  [Symbol.iterator]() {
	    return Object.entries(this.toJSON())[Symbol.iterator]();
	  }

	  toString() {
	    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
	  }

	  get [Symbol.toStringTag]() {
	    return 'AxiosHeaders';
	  }

	  static from(thing) {
	    return thing instanceof this ? thing : new this(thing);
	  }

	  static concat(first, ...targets) {
	    const computed = new this(first);

	    targets.forEach((target) => computed.set(target));

	    return computed;
	  }

	  static accessor(header) {
	    const internals = this[$internals] = (this[$internals] = {
	      accessors: {}
	    });

	    const accessors = internals.accessors;
	    const prototype = this.prototype;

	    function defineAccessor(_header) {
	      const lHeader = normalizeHeader(_header);

	      if (!accessors[lHeader]) {
	        buildAccessors(prototype, _header);
	        accessors[lHeader] = true;
	      }
	    }

	    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

	    return this;
	  }
	}

	AxiosHeaders$1.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

	// reserved names hotfix
	utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({value}, key) => {
	  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
	  return {
	    get: () => value,
	    set(headerValue) {
	      this[mapped] = headerValue;
	    }
	  }
	});

	utils$1.freezeMethods(AxiosHeaders$1);

	const AxiosHeaders$2 = AxiosHeaders$1;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Array|Function} fns A single function or Array of functions
	 * @param {?Object} response The response object
	 *
	 * @returns {*} The resulting transformed data
	 */
	function transformData(fns, response) {
	  const config = this || defaults$1;
	  const context = response || config;
	  const headers = AxiosHeaders$2.from(context.headers);
	  let data = context.data;

	  utils$1.forEach(fns, function transform(fn) {
	    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
	  });

	  headers.normalize();

	  return data;
	}

	function isCancel$1(value) {
	  return !!(value && value.__CANCEL__);
	}

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @param {string=} message The message.
	 * @param {Object=} config The config.
	 * @param {Object=} request The request.
	 *
	 * @returns {CanceledError} The created error.
	 */
	function CanceledError$1(message, config, request) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError$1.call(this, message == null ? 'canceled' : message, AxiosError$1.ERR_CANCELED, config, request);
	  this.name = 'CanceledError';
	}

	utils$1.inherits(CanceledError$1, AxiosError$1, {
	  __CANCEL__: true
	});

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 *
	 * @returns {object} The response.
	 */
	function settle(resolve, reject, response) {
	  const validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError$1(
	      'Request failed with status code ' + response.status,
	      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
	      response.config,
	      response.request,
	      response
	    ));
	  }
	}

	function parseProtocol(url) {
	  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	}

	/**
	 * Calculate data maxRate
	 * @param {Number} [samplesCount= 10]
	 * @param {Number} [min= 1000]
	 * @returns {Function}
	 */
	function speedometer(samplesCount, min) {
	  samplesCount = samplesCount || 10;
	  const bytes = new Array(samplesCount);
	  const timestamps = new Array(samplesCount);
	  let head = 0;
	  let tail = 0;
	  let firstSampleTS;

	  min = min !== undefined ? min : 1000;

	  return function push(chunkLength) {
	    const now = Date.now();

	    const startedAt = timestamps[tail];

	    if (!firstSampleTS) {
	      firstSampleTS = now;
	    }

	    bytes[head] = chunkLength;
	    timestamps[head] = now;

	    let i = tail;
	    let bytesCount = 0;

	    while (i !== head) {
	      bytesCount += bytes[i++];
	      i = i % samplesCount;
	    }

	    head = (head + 1) % samplesCount;

	    if (head === tail) {
	      tail = (tail + 1) % samplesCount;
	    }

	    if (now - firstSampleTS < min) {
	      return;
	    }

	    const passed = startedAt && now - startedAt;

	    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
	  };
	}

	/**
	 * Throttle decorator
	 * @param {Function} fn
	 * @param {Number} freq
	 * @return {Function}
	 */
	function throttle(fn, freq) {
	  let timestamp = 0;
	  let threshold = 1000 / freq;
	  let lastArgs;
	  let timer;

	  const invoke = (args, now = Date.now()) => {
	    timestamp = now;
	    lastArgs = null;
	    if (timer) {
	      clearTimeout(timer);
	      timer = null;
	    }
	    fn.apply(null, args);
	  };

	  const throttled = (...args) => {
	    const now = Date.now();
	    const passed = now - timestamp;
	    if ( passed >= threshold) {
	      invoke(args, now);
	    } else {
	      lastArgs = args;
	      if (!timer) {
	        timer = setTimeout(() => {
	          timer = null;
	          invoke(lastArgs);
	        }, threshold - passed);
	      }
	    }
	  };

	  const flush = () => lastArgs && invoke(lastArgs);

	  return [throttled, flush];
	}

	const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	  let bytesNotified = 0;
	  const _speedometer = speedometer(50, 250);

	  return throttle(e => {
	    const loaded = e.loaded;
	    const total = e.lengthComputable ? e.total : undefined;
	    const progressBytes = loaded - bytesNotified;
	    const rate = _speedometer(progressBytes);
	    const inRange = loaded <= total;

	    bytesNotified = loaded;

	    const data = {
	      loaded,
	      total,
	      progress: total ? (loaded / total) : undefined,
	      bytes: progressBytes,
	      rate: rate ? rate : undefined,
	      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
	      event: e,
	      lengthComputable: total != null,
	      [isDownloadStream ? 'download' : 'upload']: true
	    };

	    listener(data);
	  }, freq);
	};

	const progressEventDecorator = (total, throttled) => {
	  const lengthComputable = total != null;

	  return [(loaded) => throttled[0]({
	    lengthComputable,
	    total,
	    loaded
	  }), throttled[1]];
	};

	const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

	const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
	  url = new URL(url, platform.origin);

	  return (
	    origin.protocol === url.protocol &&
	    origin.host === url.host &&
	    (isMSIE || origin.port === url.port)
	  );
	})(
	  new URL(platform.origin),
	  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
	) : () => true;

	const cookies = platform.hasStandardBrowserEnv ?

	  // Standard browser envs support document.cookie
	  {
	    write(name, value, expires, path, domain, secure) {
	      const cookie = [name + '=' + encodeURIComponent(value)];

	      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

	      utils$1.isString(path) && cookie.push('path=' + path);

	      utils$1.isString(domain) && cookie.push('domain=' + domain);

	      secure === true && cookie.push('secure');

	      document.cookie = cookie.join('; ');
	    },

	    read(name) {
	      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return (match ? decodeURIComponent(match[3]) : null);
	    },

	    remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  }

	  :

	  // Non-standard browser env (web workers, react-native) lack needed support.
	  {
	    write() {},
	    read() {
	      return null;
	    },
	    remove() {}
	  };

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 *
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	}

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 *
	 * @returns {string} The combined URL
	 */
	function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	}

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 *
	 * @returns {string} The combined full path
	 */
	function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
	  let isRelativeUrl = !isAbsoluteURL(requestedURL);
	  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	}

	const headersToObject = (thing) => thing instanceof AxiosHeaders$2 ? { ...thing } : thing;

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 *
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	function mergeConfig$1(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  const config = {};

	  function getMergedValue(target, source, prop, caseless) {
	    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
	      return utils$1.merge.call({caseless}, target, source);
	    } else if (utils$1.isPlainObject(source)) {
	      return utils$1.merge({}, source);
	    } else if (utils$1.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDeepProperties(a, b, prop , caseless) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(a, b, prop , caseless);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a, prop , caseless);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function valueFromConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function defaultToConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDirectKeys(a, b, prop) {
	    if (prop in config2) {
	      return getMergedValue(a, b);
	    } else if (prop in config1) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  const mergeMap = {
	    url: valueFromConfig2,
	    method: valueFromConfig2,
	    data: valueFromConfig2,
	    baseURL: defaultToConfig2,
	    transformRequest: defaultToConfig2,
	    transformResponse: defaultToConfig2,
	    paramsSerializer: defaultToConfig2,
	    timeout: defaultToConfig2,
	    timeoutMessage: defaultToConfig2,
	    withCredentials: defaultToConfig2,
	    withXSRFToken: defaultToConfig2,
	    adapter: defaultToConfig2,
	    responseType: defaultToConfig2,
	    xsrfCookieName: defaultToConfig2,
	    xsrfHeaderName: defaultToConfig2,
	    onUploadProgress: defaultToConfig2,
	    onDownloadProgress: defaultToConfig2,
	    decompress: defaultToConfig2,
	    maxContentLength: defaultToConfig2,
	    maxBodyLength: defaultToConfig2,
	    beforeRedirect: defaultToConfig2,
	    transport: defaultToConfig2,
	    httpAgent: defaultToConfig2,
	    httpsAgent: defaultToConfig2,
	    cancelToken: defaultToConfig2,
	    socketPath: defaultToConfig2,
	    responseEncoding: defaultToConfig2,
	    validateStatus: mergeDirectKeys,
	    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
	  };

	  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
	    const merge = mergeMap[prop] || mergeDeepProperties;
	    const configValue = merge(config1[prop], config2[prop], prop);
	    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
	  });

	  return config;
	}

	const resolveConfig = (config) => {
	  const newConfig = mergeConfig$1({}, config);

	  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

	  newConfig.headers = headers = AxiosHeaders$2.from(headers);

	  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

	  // HTTP basic authentication
	  if (auth) {
	    headers.set('Authorization', 'Basic ' +
	      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
	    );
	  }

	  let contentType;

	  if (utils$1.isFormData(data)) {
	    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
	      headers.setContentType(undefined); // Let the browser set it
	    } else if ((contentType = headers.getContentType()) !== false) {
	      // fix semicolon duplication issue for ReactNative FormData implementation
	      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
	      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
	    }
	  }

	  // Add xsrf header
	  // This is only done if running in a standard browser environment.
	  // Specifically not if we're in a web worker, or react-native.

	  if (platform.hasStandardBrowserEnv) {
	    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

	    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
	      // Add xsrf header
	      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

	      if (xsrfValue) {
	        headers.set(xsrfHeaderName, xsrfValue);
	      }
	    }
	  }

	  return newConfig;
	};

	const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

	const xhrAdapter = isXHRAdapterSupported && function (config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    const _config = resolveConfig(config);
	    let requestData = _config.data;
	    const requestHeaders = AxiosHeaders$2.from(_config.headers).normalize();
	    let {responseType, onUploadProgress, onDownloadProgress} = _config;
	    let onCanceled;
	    let uploadThrottled, downloadThrottled;
	    let flushUpload, flushDownload;

	    function done() {
	      flushUpload && flushUpload(); // flush events
	      flushDownload && flushDownload(); // flush events

	      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

	      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
	    }

	    let request = new XMLHttpRequest();

	    request.open(_config.method.toUpperCase(), _config.url, true);

	    // Set the request timeout in MS
	    request.timeout = _config.timeout;

	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      const responseHeaders = AxiosHeaders$2.from(
	        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
	      );
	      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
	        request.responseText : request.response;
	      const response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config,
	        request
	      };

	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }

	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(new AxiosError$1('Request aborted', AxiosError$1.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
	      const transitional = _config.transitional || transitionalDefaults;
	      if (_config.timeoutErrorMessage) {
	        timeoutErrorMessage = _config.timeoutErrorMessage;
	      }
	      reject(new AxiosError$1(
	        timeoutErrorMessage,
	        transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
	        config,
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Remove Content-Type if data is undefined
	    requestData === undefined && requestHeaders.setContentType(null);

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
	        request.setRequestHeader(key, val);
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils$1.isUndefined(_config.withCredentials)) {
	      request.withCredentials = !!_config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = _config.responseType;
	    }

	    // Handle progress if needed
	    if (onDownloadProgress) {
	      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
	      request.addEventListener('progress', downloadThrottled);
	    }

	    // Not all browsers support upload events
	    if (onUploadProgress && request.upload) {
	      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

	      request.upload.addEventListener('progress', uploadThrottled);

	      request.upload.addEventListener('loadend', flushUpload);
	    }

	    if (_config.cancelToken || _config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = cancel => {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
	        request.abort();
	        request = null;
	      };

	      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
	      if (_config.signal) {
	        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
	      }
	    }

	    const protocol = parseProtocol(_config.url);

	    if (protocol && platform.protocols.indexOf(protocol) === -1) {
	      reject(new AxiosError$1('Unsupported protocol ' + protocol + ':', AxiosError$1.ERR_BAD_REQUEST, config));
	      return;
	    }


	    // Send the request
	    request.send(requestData || null);
	  });
	};

	const composeSignals = (signals, timeout) => {
	  const {length} = (signals = signals ? signals.filter(Boolean) : []);

	  if (timeout || length) {
	    let controller = new AbortController();

	    let aborted;

	    const onabort = function (reason) {
	      if (!aborted) {
	        aborted = true;
	        unsubscribe();
	        const err = reason instanceof Error ? reason : this.reason;
	        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
	      }
	    };

	    let timer = timeout && setTimeout(() => {
	      timer = null;
	      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
	    }, timeout);

	    const unsubscribe = () => {
	      if (signals) {
	        timer && clearTimeout(timer);
	        timer = null;
	        signals.forEach(signal => {
	          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
	        });
	        signals = null;
	      }
	    };

	    signals.forEach((signal) => signal.addEventListener('abort', onabort));

	    const {signal} = controller;

	    signal.unsubscribe = () => utils$1.asap(unsubscribe);

	    return signal;
	  }
	};

	const composeSignals$1 = composeSignals;

	const streamChunk = function* (chunk, chunkSize) {
	  let len = chunk.byteLength;

	  if (len < chunkSize) {
	    yield chunk;
	    return;
	  }

	  let pos = 0;
	  let end;

	  while (pos < len) {
	    end = pos + chunkSize;
	    yield chunk.slice(pos, end);
	    pos = end;
	  }
	};

	const readBytes = async function* (iterable, chunkSize) {
	  for await (const chunk of readStream(iterable)) {
	    yield* streamChunk(chunk, chunkSize);
	  }
	};

	const readStream = async function* (stream) {
	  if (stream[Symbol.asyncIterator]) {
	    yield* stream;
	    return;
	  }

	  const reader = stream.getReader();
	  try {
	    for (;;) {
	      const {done, value} = await reader.read();
	      if (done) {
	        break;
	      }
	      yield value;
	    }
	  } finally {
	    await reader.cancel();
	  }
	};

	const trackStream = (stream, chunkSize, onProgress, onFinish) => {
	  const iterator = readBytes(stream, chunkSize);

	  let bytes = 0;
	  let done;
	  let _onFinish = (e) => {
	    if (!done) {
	      done = true;
	      onFinish && onFinish(e);
	    }
	  };

	  return new ReadableStream({
	    async pull(controller) {
	      try {
	        const {done, value} = await iterator.next();

	        if (done) {
	         _onFinish();
	          controller.close();
	          return;
	        }

	        let len = value.byteLength;
	        if (onProgress) {
	          let loadedBytes = bytes += len;
	          onProgress(loadedBytes);
	        }
	        controller.enqueue(new Uint8Array(value));
	      } catch (err) {
	        _onFinish(err);
	        throw err;
	      }
	    },
	    cancel(reason) {
	      _onFinish(reason);
	      return iterator.return();
	    }
	  }, {
	    highWaterMark: 2
	  })
	};

	const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
	const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

	// used only inside the fetch adapter
	const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
	    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
	    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
	);

	const test = (fn, ...args) => {
	  try {
	    return !!fn(...args);
	  } catch (e) {
	    return false
	  }
	};

	const supportsRequestStream = isReadableStreamSupported && test(() => {
	  let duplexAccessed = false;

	  const hasContentType = new Request(platform.origin, {
	    body: new ReadableStream(),
	    method: 'POST',
	    get duplex() {
	      duplexAccessed = true;
	      return 'half';
	    },
	  }).headers.has('Content-Type');

	  return duplexAccessed && !hasContentType;
	});

	const DEFAULT_CHUNK_SIZE = 64 * 1024;

	const supportsResponseStream = isReadableStreamSupported &&
	  test(() => utils$1.isReadableStream(new Response('').body));


	const resolvers = {
	  stream: supportsResponseStream && ((res) => res.body)
	};

	isFetchSupported && (((res) => {
	  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
	    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
	      (_, config) => {
	        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
	      });
	  });
	})(new Response));

	const getBodyLength = async (body) => {
	  if (body == null) {
	    return 0;
	  }

	  if(utils$1.isBlob(body)) {
	    return body.size;
	  }

	  if(utils$1.isSpecCompliantForm(body)) {
	    const _request = new Request(platform.origin, {
	      method: 'POST',
	      body,
	    });
	    return (await _request.arrayBuffer()).byteLength;
	  }

	  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
	    return body.byteLength;
	  }

	  if(utils$1.isURLSearchParams(body)) {
	    body = body + '';
	  }

	  if(utils$1.isString(body)) {
	    return (await encodeText(body)).byteLength;
	  }
	};

	const resolveBodyLength = async (headers, body) => {
	  const length = utils$1.toFiniteNumber(headers.getContentLength());

	  return length == null ? getBodyLength(body) : length;
	};

	const fetchAdapter = isFetchSupported && (async (config) => {
	  let {
	    url,
	    method,
	    data,
	    signal,
	    cancelToken,
	    timeout,
	    onDownloadProgress,
	    onUploadProgress,
	    responseType,
	    headers,
	    withCredentials = 'same-origin',
	    fetchOptions
	  } = resolveConfig(config);

	  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

	  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

	  let request;

	  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
	      composedSignal.unsubscribe();
	  });

	  let requestContentLength;

	  try {
	    if (
	      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
	      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
	    ) {
	      let _request = new Request(url, {
	        method: 'POST',
	        body: data,
	        duplex: "half"
	      });

	      let contentTypeHeader;

	      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
	        headers.setContentType(contentTypeHeader);
	      }

	      if (_request.body) {
	        const [onProgress, flush] = progressEventDecorator(
	          requestContentLength,
	          progressEventReducer(asyncDecorator(onUploadProgress))
	        );

	        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
	      }
	    }

	    if (!utils$1.isString(withCredentials)) {
	      withCredentials = withCredentials ? 'include' : 'omit';
	    }

	    // Cloudflare Workers throws when credentials are defined
	    // see https://github.com/cloudflare/workerd/issues/902
	    const isCredentialsSupported = "credentials" in Request.prototype;
	    request = new Request(url, {
	      ...fetchOptions,
	      signal: composedSignal,
	      method: method.toUpperCase(),
	      headers: headers.normalize().toJSON(),
	      body: data,
	      duplex: "half",
	      credentials: isCredentialsSupported ? withCredentials : undefined
	    });

	    let response = await fetch(request);

	    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

	    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
	      const options = {};

	      ['status', 'statusText', 'headers'].forEach(prop => {
	        options[prop] = response[prop];
	      });

	      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

	      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
	        responseContentLength,
	        progressEventReducer(asyncDecorator(onDownloadProgress), true)
	      ) || [];

	      response = new Response(
	        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
	          flush && flush();
	          unsubscribe && unsubscribe();
	        }),
	        options
	      );
	    }

	    responseType = responseType || 'text';

	    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

	    !isStreamResponse && unsubscribe && unsubscribe();

	    return await new Promise((resolve, reject) => {
	      settle(resolve, reject, {
	        data: responseData,
	        headers: AxiosHeaders$2.from(response.headers),
	        status: response.status,
	        statusText: response.statusText,
	        config,
	        request
	      });
	    })
	  } catch (err) {
	    unsubscribe && unsubscribe();

	    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
	      throw Object.assign(
	        new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, config, request),
	        {
	          cause: err.cause || err
	        }
	      )
	    }

	    throw AxiosError$1.from(err, err && err.code, config, request);
	  }
	});

	const knownAdapters = {
	  http: httpAdapter,
	  xhr: xhrAdapter,
	  fetch: fetchAdapter
	};

	utils$1.forEach(knownAdapters, (fn, value) => {
	  if (fn) {
	    try {
	      Object.defineProperty(fn, 'name', {value});
	    } catch (e) {
	      // eslint-disable-next-line no-empty
	    }
	    Object.defineProperty(fn, 'adapterName', {value});
	  }
	});

	const renderReason = (reason) => `- ${reason}`;

	const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

	const adapters = {
	  getAdapter: (adapters) => {
	    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

	    const {length} = adapters;
	    let nameOrAdapter;
	    let adapter;

	    const rejectedReasons = {};

	    for (let i = 0; i < length; i++) {
	      nameOrAdapter = adapters[i];
	      let id;

	      adapter = nameOrAdapter;

	      if (!isResolvedHandle(nameOrAdapter)) {
	        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

	        if (adapter === undefined) {
	          throw new AxiosError$1(`Unknown adapter '${id}'`);
	        }
	      }

	      if (adapter) {
	        break;
	      }

	      rejectedReasons[id || '#' + i] = adapter;
	    }

	    if (!adapter) {

	      const reasons = Object.entries(rejectedReasons)
	        .map(([id, state]) => `adapter ${id} ` +
	          (state === false ? 'is not supported by the environment' : 'is not available in the build')
	        );

	      let s = length ?
	        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
	        'as no adapter specified';

	      throw new AxiosError$1(
	        `There is no suitable adapter to dispatch the request ` + s,
	        'ERR_NOT_SUPPORT'
	      );
	    }

	    return adapter;
	  },
	  adapters: knownAdapters
	};

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 *
	 * @param {Object} config The config that is to be used for the request
	 *
	 * @returns {void}
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }

	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError$1(null, config);
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 *
	 * @returns {Promise} The Promise to be fulfilled
	 */
	function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  config.headers = AxiosHeaders$2.from(config.headers);

	  // Transform request data
	  config.data = transformData.call(
	    config,
	    config.transformRequest
	  );

	  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
	    config.headers.setContentType('application/x-www-form-urlencoded', false);
	  }

	  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(
	      config,
	      config.transformResponse,
	      response
	    );

	    response.headers = AxiosHeaders$2.from(response.headers);

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel$1(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(
	          config,
	          config.transformResponse,
	          reason.response
	        );
	        reason.response.headers = AxiosHeaders$2.from(reason.response.headers);
	      }
	    }

	    return Promise.reject(reason);
	  });
	}

	const VERSION$1 = "1.8.4";

	const validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});

	const deprecatedWarnings = {};

	/**
	 * Transitional option validator
	 *
	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	 * @param {string?} version - deprecated version / removed since version
	 * @param {string?} message - some message with additional info
	 *
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  function formatMessage(opt, desc) {
	    return '[Axios v' + VERSION$1 + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return (value, opt, opts) => {
	    if (validator === false) {
	      throw new AxiosError$1(
	        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
	        AxiosError$1.ERR_DEPRECATED
	      );
	    }

	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        formatMessage(
	          opt,
	          ' has been deprecated since v' + version + ' and will be removed in the near future'
	        )
	      );
	    }

	    return validator ? validator(value, opt, opts) : true;
	  };
	};

	validators$1.spelling = function spelling(correctSpelling) {
	  return (value, opt) => {
	    // eslint-disable-next-line no-console
	    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
	    return true;
	  }
	};

	/**
	 * Assert object's properties type
	 *
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 *
	 * @returns {object}
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new AxiosError$1('options must be an object', AxiosError$1.ERR_BAD_OPTION_VALUE);
	  }
	  const keys = Object.keys(options);
	  let i = keys.length;
	  while (i-- > 0) {
	    const opt = keys[i];
	    const validator = schema[opt];
	    if (validator) {
	      const value = options[opt];
	      const result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError$1('option ' + opt + ' must be ' + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError$1('Unknown option ' + opt, AxiosError$1.ERR_BAD_OPTION);
	    }
	  }
	}

	const validator = {
	  assertOptions,
	  validators: validators$1
	};

	const validators = validator.validators;

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 *
	 * @return {Axios} A new instance of Axios
	 */
	class Axios$1 {
	  constructor(instanceConfig) {
	    this.defaults = instanceConfig;
	    this.interceptors = {
	      request: new InterceptorManager$1(),
	      response: new InterceptorManager$1()
	    };
	  }

	  /**
	   * Dispatch a request
	   *
	   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	   * @param {?Object} config
	   *
	   * @returns {Promise} The Promise to be fulfilled
	   */
	  async request(configOrUrl, config) {
	    try {
	      return await this._request(configOrUrl, config);
	    } catch (err) {
	      if (err instanceof Error) {
	        let dummy = {};

	        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

	        // slice off the Error: ... line
	        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
	        try {
	          if (!err.stack) {
	            err.stack = stack;
	            // match without the 2 top stack lines
	          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
	            err.stack += '\n' + stack;
	          }
	        } catch (e) {
	          // ignore the case where "stack" is an un-writable property
	        }
	      }

	      throw err;
	    }
	  }

	  _request(configOrUrl, config) {
	    /*eslint no-param-reassign:0*/
	    // Allow for axios('example/url'[, config]) a la fetch API
	    if (typeof configOrUrl === 'string') {
	      config = config || {};
	      config.url = configOrUrl;
	    } else {
	      config = configOrUrl || {};
	    }

	    config = mergeConfig$1(this.defaults, config);

	    const {transitional, paramsSerializer, headers} = config;

	    if (transitional !== undefined) {
	      validator.assertOptions(transitional, {
	        silentJSONParsing: validators.transitional(validators.boolean),
	        forcedJSONParsing: validators.transitional(validators.boolean),
	        clarifyTimeoutError: validators.transitional(validators.boolean)
	      }, false);
	    }

	    if (paramsSerializer != null) {
	      if (utils$1.isFunction(paramsSerializer)) {
	        config.paramsSerializer = {
	          serialize: paramsSerializer
	        };
	      } else {
	        validator.assertOptions(paramsSerializer, {
	          encode: validators.function,
	          serialize: validators.function
	        }, true);
	      }
	    }

	    // Set config.allowAbsoluteUrls
	    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
	      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
	    } else {
	      config.allowAbsoluteUrls = true;
	    }

	    validator.assertOptions(config, {
	      baseUrl: validators.spelling('baseURL'),
	      withXsrfToken: validators.spelling('withXSRFToken')
	    }, true);

	    // Set config.method
	    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

	    // Flatten headers
	    let contextHeaders = headers && utils$1.merge(
	      headers.common,
	      headers[config.method]
	    );

	    headers && utils$1.forEach(
	      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	      (method) => {
	        delete headers[method];
	      }
	    );

	    config.headers = AxiosHeaders$2.concat(contextHeaders, headers);

	    // filter out skipped interceptors
	    const requestInterceptorChain = [];
	    let synchronousRequestInterceptors = true;
	    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	        return;
	      }

	      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

	      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    });

	    const responseInterceptorChain = [];
	    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    });

	    let promise;
	    let i = 0;
	    let len;

	    if (!synchronousRequestInterceptors) {
	      const chain = [dispatchRequest.bind(this), undefined];
	      chain.unshift.apply(chain, requestInterceptorChain);
	      chain.push.apply(chain, responseInterceptorChain);
	      len = chain.length;

	      promise = Promise.resolve(config);

	      while (i < len) {
	        promise = promise.then(chain[i++], chain[i++]);
	      }

	      return promise;
	    }

	    len = requestInterceptorChain.length;

	    let newConfig = config;

	    i = 0;

	    while (i < len) {
	      const onFulfilled = requestInterceptorChain[i++];
	      const onRejected = requestInterceptorChain[i++];
	      try {
	        newConfig = onFulfilled(newConfig);
	      } catch (error) {
	        onRejected.call(this, error);
	        break;
	      }
	    }

	    try {
	      promise = dispatchRequest.call(this, newConfig);
	    } catch (error) {
	      return Promise.reject(error);
	    }

	    i = 0;
	    len = responseInterceptorChain.length;

	    while (i < len) {
	      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
	    }

	    return promise;
	  }

	  getUri(config) {
	    config = mergeConfig$1(this.defaults, config);
	    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
	    return buildURL(fullPath, config.params, config.paramsSerializer);
	  }
	}

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios$1.prototype[method] = function(url, config) {
	    return this.request(mergeConfig$1(config || {}, {
	      method,
	      url,
	      data: (config || {}).data
	    }));
	  };
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/

	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig$1(config || {}, {
	        method,
	        headers: isForm ? {
	          'Content-Type': 'multipart/form-data'
	        } : {},
	        url,
	        data
	      }));
	    };
	  }

	  Axios$1.prototype[method] = generateHTTPMethod();

	  Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
	});

	const Axios$2 = Axios$1;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @param {Function} executor The executor function.
	 *
	 * @returns {CancelToken}
	 */
	class CancelToken$1 {
	  constructor(executor) {
	    if (typeof executor !== 'function') {
	      throw new TypeError('executor must be a function.');
	    }

	    let resolvePromise;

	    this.promise = new Promise(function promiseExecutor(resolve) {
	      resolvePromise = resolve;
	    });

	    const token = this;

	    // eslint-disable-next-line func-names
	    this.promise.then(cancel => {
	      if (!token._listeners) return;

	      let i = token._listeners.length;

	      while (i-- > 0) {
	        token._listeners[i](cancel);
	      }
	      token._listeners = null;
	    });

	    // eslint-disable-next-line func-names
	    this.promise.then = onfulfilled => {
	      let _resolve;
	      // eslint-disable-next-line func-names
	      const promise = new Promise(resolve => {
	        token.subscribe(resolve);
	        _resolve = resolve;
	      }).then(onfulfilled);

	      promise.cancel = function reject() {
	        token.unsubscribe(_resolve);
	      };

	      return promise;
	    };

	    executor(function cancel(message, config, request) {
	      if (token.reason) {
	        // Cancellation has already been requested
	        return;
	      }

	      token.reason = new CanceledError$1(message, config, request);
	      resolvePromise(token.reason);
	    });
	  }

	  /**
	   * Throws a `CanceledError` if cancellation has been requested.
	   */
	  throwIfRequested() {
	    if (this.reason) {
	      throw this.reason;
	    }
	  }

	  /**
	   * Subscribe to the cancel signal
	   */

	  subscribe(listener) {
	    if (this.reason) {
	      listener(this.reason);
	      return;
	    }

	    if (this._listeners) {
	      this._listeners.push(listener);
	    } else {
	      this._listeners = [listener];
	    }
	  }

	  /**
	   * Unsubscribe from the cancel signal
	   */

	  unsubscribe(listener) {
	    if (!this._listeners) {
	      return;
	    }
	    const index = this._listeners.indexOf(listener);
	    if (index !== -1) {
	      this._listeners.splice(index, 1);
	    }
	  }

	  toAbortSignal() {
	    const controller = new AbortController();

	    const abort = (err) => {
	      controller.abort(err);
	    };

	    this.subscribe(abort);

	    controller.signal.unsubscribe = () => this.unsubscribe(abort);

	    return controller.signal;
	  }

	  /**
	   * Returns an object that contains a new `CancelToken` and a function that, when called,
	   * cancels the `CancelToken`.
	   */
	  static source() {
	    let cancel;
	    const token = new CancelToken$1(function executor(c) {
	      cancel = c;
	    });
	    return {
	      token,
	      cancel
	    };
	  }
	}

	const CancelToken$2 = CancelToken$1;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 *
	 * @returns {Function}
	 */
	function spread$1(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	}

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 *
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	function isAxiosError$1(payload) {
	  return utils$1.isObject(payload) && (payload.isAxiosError === true);
	}

	const HttpStatusCode$1 = {
	  Continue: 100,
	  SwitchingProtocols: 101,
	  Processing: 102,
	  EarlyHints: 103,
	  Ok: 200,
	  Created: 201,
	  Accepted: 202,
	  NonAuthoritativeInformation: 203,
	  NoContent: 204,
	  ResetContent: 205,
	  PartialContent: 206,
	  MultiStatus: 207,
	  AlreadyReported: 208,
	  ImUsed: 226,
	  MultipleChoices: 300,
	  MovedPermanently: 301,
	  Found: 302,
	  SeeOther: 303,
	  NotModified: 304,
	  UseProxy: 305,
	  Unused: 306,
	  TemporaryRedirect: 307,
	  PermanentRedirect: 308,
	  BadRequest: 400,
	  Unauthorized: 401,
	  PaymentRequired: 402,
	  Forbidden: 403,
	  NotFound: 404,
	  MethodNotAllowed: 405,
	  NotAcceptable: 406,
	  ProxyAuthenticationRequired: 407,
	  RequestTimeout: 408,
	  Conflict: 409,
	  Gone: 410,
	  LengthRequired: 411,
	  PreconditionFailed: 412,
	  PayloadTooLarge: 413,
	  UriTooLong: 414,
	  UnsupportedMediaType: 415,
	  RangeNotSatisfiable: 416,
	  ExpectationFailed: 417,
	  ImATeapot: 418,
	  MisdirectedRequest: 421,
	  UnprocessableEntity: 422,
	  Locked: 423,
	  FailedDependency: 424,
	  TooEarly: 425,
	  UpgradeRequired: 426,
	  PreconditionRequired: 428,
	  TooManyRequests: 429,
	  RequestHeaderFieldsTooLarge: 431,
	  UnavailableForLegalReasons: 451,
	  InternalServerError: 500,
	  NotImplemented: 501,
	  BadGateway: 502,
	  ServiceUnavailable: 503,
	  GatewayTimeout: 504,
	  HttpVersionNotSupported: 505,
	  VariantAlsoNegotiates: 506,
	  InsufficientStorage: 507,
	  LoopDetected: 508,
	  NotExtended: 510,
	  NetworkAuthenticationRequired: 511,
	};

	Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
	  HttpStatusCode$1[value] = key;
	});

	const HttpStatusCode$2 = HttpStatusCode$1;

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 *
	 * @returns {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  const context = new Axios$2(defaultConfig);
	  const instance = bind(Axios$2.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$1.extend(instance, Axios$2.prototype, context, {allOwnKeys: true});

	  // Copy context to instance
	  utils$1.extend(instance, context, null, {allOwnKeys: true});

	  // Factory for creating new instances
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
	  };

	  return instance;
	}

	// Create the default instance to be exported
	const axios$1 = createInstance(defaults$1);

	// Expose Axios class to allow class inheritance
	axios$1.Axios = Axios$2;

	// Expose Cancel & CancelToken
	axios$1.CanceledError = CanceledError$1;
	axios$1.CancelToken = CancelToken$2;
	axios$1.isCancel = isCancel$1;
	axios$1.VERSION = VERSION$1;
	axios$1.toFormData = toFormData$1;

	// Expose AxiosError class
	axios$1.AxiosError = AxiosError$1;

	// alias for CanceledError for backward compatibility
	axios$1.Cancel = axios$1.CanceledError;

	// Expose all/spread
	axios$1.all = function all(promises) {
	  return Promise.all(promises);
	};

	axios$1.spread = spread$1;

	// Expose isAxiosError
	axios$1.isAxiosError = isAxiosError$1;

	// Expose mergeConfig
	axios$1.mergeConfig = mergeConfig$1;

	axios$1.AxiosHeaders = AxiosHeaders$2;

	axios$1.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

	axios$1.getAdapter = adapters.getAdapter;

	axios$1.HttpStatusCode = HttpStatusCode$2;

	axios$1.default = axios$1;

	// this module should only have a default export
	const axios$1$1 = axios$1;

	// This module is intended to unwrap Axios default export as named.
	// Keep top-level export same with static properties
	// so that it can keep same with es module or cjs
	const {
	  Axios,
	  AxiosError,
	  CanceledError,
	  isCancel,
	  CancelToken,
	  VERSION,
	  all,
	  Cancel,
	  isAxiosError,
	  spread,
	  toFormData,
	  AxiosHeaders,
	  HttpStatusCode,
	  formToJSON,
	  getAdapter,
	  mergeConfig
	} = axios$1$1;

	function decodeJWT(token) {
	    if (typeof token !== 'string') {
	        return undefined;
	    }
	    try {
	        if (typeof window === 'undefined') {
	            return JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
	        }
	        else {
	            const base64Url = token.split('.')[1];
	            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
	            const jsonPayload = decodeURIComponent(window
	                .atob(base64)
	                .split('')
	                .map(function (c) {
	                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	            })
	                .join(''));
	            return JSON.parse(jsonPayload);
	        }
	    }
	    catch (_e) {
	        return undefined;
	    }
	}

	const axiosGlobal = ((axios$1$1 === null || axios$1$1 === void 0 ? void 0 : axios$1$1.default) || axios$1$1);
	const axios = axiosGlobal.create();
	const DEFAULT_API_URI = 'https://api.integration.app';
	const DEFAULT_UI_URI = 'https://ui.integration.app';
	const REFETCH_EXPIRATION_THRESHOLD = 10 * 1000;
	function decodeToken(token) {
	    const payload = decodeJWT(token);
	    if (!payload) {
	        throw new Error('Access token should be a valid JWT token.');
	    }
	    return payload;
	}
	class IntegrationAppApiClient {
	    constructor({ uiUri, apiUri, accessToken, token, fetchToken, fetchCredentials, credentials, } = {}) {
	        this.apiUri = apiUri !== null && apiUri !== void 0 ? apiUri : DEFAULT_API_URI;
	        this.uiUri = uiUri !== null && uiUri !== void 0 ? uiUri : DEFAULT_UI_URI;
	        this.token = token !== null && token !== void 0 ? token : accessToken;
	        this.fetchToken = fetchToken;
	        if (fetchCredentials) {
	            void fetchCredentials().then((c) => this.setCredentials(c));
	        }
	        else if (credentials) {
	            void this.setCredentials(credentials);
	        }
	    }
	    async setCredentials(credentials) {
	        return this.patch('/self', { credentials });
	    }
	    async getToken() {
	        if (this.fetchToken) {
	            if (!this.token) {
	                this.token = await this.fetchToken();
	            }
	            else {
	                const payload = decodeToken(this.token);
	                if (payload.exp) {
	                    const willExpireSoon = new Date(payload.exp * 1000).getTime() - new Date().getTime() <
	                        REFETCH_EXPIRATION_THRESHOLD;
	                    if (willExpireSoon) {
	                        this.token = await this.fetchToken();
	                    }
	                }
	            }
	        }
	        if (!this.token) {
	            throw new Error('Access token is not provided.');
	        }
	        decodeToken(this.token);
	        return this.token;
	    }
	    async get(uri, queryParams, options) {
	        if (queryParams) {
	            uri += `${uri.includes('?') ? '&' : '?'}${new URLSearchParams(omitBy(queryParams, isEmptyValue)).toString()}`;
	        }
	        return this.makeApiRequest('GET', { ...(options !== null && options !== void 0 ? options : {}), url: uri });
	    }
	    async post(uri, data, options) {
	        return this.makeApiRequest('POST', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
	    }
	    async put(uri, data, options) {
	        return this.makeApiRequest('PUT', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
	    }
	    async patch(uri, data, options) {
	        return this.makeApiRequest('PATCH', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
	    }
	    async delete(uri, data, options) {
	        return this.makeApiRequest('DELETE', { ...(options !== null && options !== void 0 ? options : {}), url: uri, data });
	    }
	    async getEmbedUri(page, params) {
	        var _a;
	        const paramsWithToken = { token: await this.getToken(), ...(params !== null && params !== void 0 ? params : {}) };
	        const queryParams = qs.stringify(paramsWithToken);
	        const baseUriWithoutSlash = (_a = this.uiUri) === null || _a === void 0 ? void 0 : _a.replace(/\/$/, '');
	        const pageWithoutSlash = page.replace(/^\//, '');
	        return `${baseUriWithoutSlash}/embed/${pageWithoutSlash}${queryParams ? `?${queryParams}` : ''}`;
	    }
	    async makeApiRequest(method, params = {}) {
	        const token = await this.getToken();
	        params.method = method;
	        params.baseURL = this.apiUri;
	        params.headers = {
	            ...(params.headers || {}),
	            Authorization: `Bearer ${token}`,
	        };
	        params.withCredentials = false;
	        let response;
	        try {
	            response = await axios.request(params);
	        }
	        catch (err) {
	            this.handleRequestError(err);
	        }
	        return response.data;
	    }
	    handleRequestError(err) {
	        var _a, _b;
	        if (axiosGlobal.isAxiosError(err) && ((_b = (_a = err.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.type)) {
	            const error = getErrorFromData(err.response.data);
	            if (error)
	                throw error;
	        }
	        throw err;
	    }
	}

	class AppDataSchemasAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'app-data-schemas');
	    }
	}
	class AppDataSchemaAccessor extends ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'app-data-schema',
	            selector: idOrKey,
	        });
	    }
	}
	class AppDataSchemaInstancesAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'app-data-schema-instances');
	    }
	}
	class AppDataSchemaInstanceAccessor extends ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'app-data-schema-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async setup() {
	        await this.client.post(this.getPath('setup'));
	    }
	}

	class AppEventTypesAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'app-event-types');
	    }
	}
	class AppEventTypeAccessor extends ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'app-event-type',
	            selector: idOrKey,
	        });
	    }
	}
	class AppEventSubscriptionsAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'app-event-subscriptions');
	    }
	}
	class AppEventSubscriptionAccessor extends ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'app-event-subscription',
	            selector,
	        });
	    }
	    async subscribe() {
	        return this.options.client.post(this.getPath('subscribe'));
	    }
	}
	class AppEventsAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'app-events');
	    }
	}

	class SelfAccessor {
	    constructor(client) {
	        this.client = client;
	    }
	    async get() {
	        return this.client.get('self');
	    }
	    async patch(data) {
	        return this.client.patch('self', data);
	    }
	}

	var ConnectionType;
	(function (ConnectionType) {
	    ConnectionType["IFRAME"] = "iframe";
	    ConnectionType["POPUP"] = "popup";
	    ConnectionType["REDIRECT"] = "redirect";
	})(ConnectionType || (ConnectionType = {}));
	async function createOrUpdateConnection(options) {
	    const { connectionId, integrationId, name, parameters, allowMultipleConnections, authOptionKey, connectorSpec, apiUri, token, redirectUri, } = options !== null && options !== void 0 ? options : {};
	    const connectionType = getConnectionType({
	        connectorSpec,
	        authOptionKey,
	        redirectUri,
	    });
	    const popupPath = connectionId
	        ? `connection-popup?connectionId=${connectionId}`
	        : `connection-popup?integrationId=${integrationId}`;
	    return new Promise((resolve, reject) => {
	        const connectionUrl = urljoin(apiUri, popupPath);
	        const requestId = (Math.random() + 1).toString(36).substring(0, 12);
	        const payload = {
	            token,
	            connectionParameters: parameters,
	            name,
	            authOptionKey,
	            allowMultipleConnections,
	            requestId,
	            redirectUri,
	        };
	        const listenerFunc = async (event) => {
	            var _a;
	            const message = event.data || {};
	            if (message.source == 'integration.app' &&
	                (message.requestId == requestId || !message.requestId)) {
	                cleanup();
	                if (message.type == 'newConnectionCreated') {
	                    resolve(message.connection);
	                }
	                else if (message.type == 'newConnectionCancel') {
	                    resolve(undefined);
	                }
	                else if (message.type == 'newConnectionFailure') {
	                    const error = new IntegrationAppError((_a = message.errorData) !== null && _a !== void 0 ? _a : message.error);
	                    reject(error);
	                }
	            }
	        };
	        let cancelCheckInterval;
	        function cleanup() {
	            clearInterval(cancelCheckInterval);
	            window.removeEventListener('message', listenerFunc);
	        }
	        const targetElementId = `connection-request-${requestId}`;
	        try {
	            window.addEventListener('message', listenerFunc);
	            const form = document.createElement('form');
	            form.method = 'POST';
	            form.action = connectionUrl;
	            form.target = targetElementId;
	            const input = document.createElement('input');
	            input.type = 'hidden';
	            input.name = 'payload';
	            input.value = JSON.stringify(payload);
	            form.appendChild(input);
	            document.body.appendChild(form);
	            if (connectionType === ConnectionType.IFRAME) {
	                const iframeElement = document.createElement('iframe');
	                iframeElement.id = targetElementId;
	                iframeElement.name = targetElementId;
	                iframeElement.style.position = 'absolute';
	                iframeElement.style.top = '-100';
	                iframeElement.style.left = '-100';
	                iframeElement.style.width = '1';
	                iframeElement.style.height = '1';
	                iframeElement.style.border = 'none';
	                iframeElement.style.backgroundColor = 'transparent';
	                document.body.appendChild(iframeElement);
	                form.submit();
	                document.body.removeChild(form);
	            }
	            if (connectionType === ConnectionType.REDIRECT) {
	                form.target = '_self';
	                form.submit();
	                document.body.removeChild(form);
	            }
	            if (connectionType === ConnectionType.POPUP) {
	                const width = Math.min(Math.round(screen.width * 0.7), 1000);
	                const height = Math.min(Math.round(screen.height * 0.6), 800);
	                const left = Math.round((screen.width - width) / 2);
	                const top = Math.round((screen.height - height) / 2);
	                let popup;
	                setTimeout(() => {
	                    popup = window.open('', targetElementId, `popup,width=${width},height=${height},left=${left},top=${top}`);
	                    form.submit();
	                    document.body.removeChild(form);
	                }, 0);
	                setTimeout(() => {
	                    if (!popup) {
	                        cleanup();
	                        reject({
	                            message: 'Popup has been blocked.',
	                        });
	                    }
	                }, 1000);
	                cancelCheckInterval = setInterval(() => {
	                    if (popup === null || popup === void 0 ? void 0 : popup.closed) {
	                        cleanup();
	                        resolve(null);
	                    }
	                }, 1000);
	            }
	        }
	        catch (e) {
	            reject(e);
	        }
	    });
	}
	const getConnectionType = ({ connectorSpec, authOptionKey, redirectUri, }) => {
	    var _a, _b;
	    const authSpec = authOptionKey
	        ? (_b = (_a = connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b[authOptionKey]
	        : connectorSpec === null || connectorSpec === void 0 ? void 0 : connectorSpec.auth;
	    if ((authSpec === null || authSpec === void 0 ? void 0 : authSpec.type) === 'client-credentials') {
	        return ConnectionType.IFRAME;
	    }
	    if (redirectUri) {
	        return ConnectionType.REDIRECT;
	    }
	    return ConnectionType.POPUP;
	};

	class DataSourcesAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'data-sources');
	    }
	}
	class DataSourceAccessor extends ElementAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            path: 'data-source',
	        });
	    }
	    async apply(integrationKeys) {
	        return await this.options.client.post(this.getPath('apply'), {
	            integrationKeys,
	        });
	    }
	    async reset() {
	        return await this.options.client.post(this.getPath('reset'));
	    }
	}
	class DataSourceInstancesAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'data-source-instances');
	    }
	}
	class DataSourceInstanceAccessor extends ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'data-source-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async setup() {
	        await this.client.post(this.getPath('setup'));
	    }
	    async reset() {
	        await this.client.post(this.getPath('reset'));
	    }
	    async openConfiguration({ onClose = () => { }, } = {}) {
	        const id = await this.getId();
	        const uri = await this.client.getEmbedUri(`data-source-instances/${id}/configuration`);
	        return openIframe(uri, {
	            onClose,
	        });
	    }
	    async unifiedFieldsToNative(unifiedFields) {
	        return this.client.post(this.getPath('unified-fields-to-native'), unifiedFields);
	    }
	    async getCollection() {
	        return this.client.get(this.getPath('collection'));
	    }
	    async listRecords(request = {}) {
	        return this.client.post(this.getPath('collection/list'), request);
	    }
	    async matchRecord(request) {
	        return this.client.post(this.getPath('collection/match'), request);
	    }
	    async searchRecords(request) {
	        return this.client.post(this.getPath('collection/search'), request);
	    }
	    async findRecordById(request) {
	        const data = typeof request === 'string' ? { id: request } : request;
	        return this.client.post(this.getPath('collection/find-by-id'), data);
	    }
	    async createRecord(request) {
	        return this.client.post(this.getPath('collection/create'), request);
	    }
	    async updateRecord(request) {
	        return this.client.post(this.getPath(`collection/update`), request);
	    }
	    async deleteRecord(request) {
	        const data = typeof request === 'string' ? { id: request } : request;
	        return this.client.post(this.getPath(`collection/delete`), data);
	    }
	    async findRecords(request = {}) {
	        return this.client.post(this.getPath('collection/find'), request);
	    }
	}
	class IntegrationLevelDataSourceAccessor extends IntegrationLevelElementAccessor {
	    constructor(client, integrationSelector, dataSourceSelector) {
	        super(client, integrationSelector, dataSourceSelector, 'data-sources');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	        this.dataSourceSelector = dataSourceSelector;
	    }
	}
	class IntegrationLevelDataSourcesListAccessor extends IntegrationLevelElementsListAccessor {
	    constructor(client, integrationSelector) {
	        super(client, integrationSelector, 'data-sources');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	    }
	}
	class ConnectionLevelDataSourceAccessor extends ConnectionLevelElementAccessor {
	    constructor(client, connectionSelector, dataSourceSelector, query) {
	        super(client, connectionSelector, dataSourceSelector, 'data-sources', query);
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	        this.dataSourceSelector = dataSourceSelector;
	        this.query = query;
	    }
	    async openConfiguration(options) {
	        var _a;
	        const instance = await this.get({ autoCreate: true });
	        const uri = await this.client.getEmbedUri(`data-source-instances/${instance.id}/configuration`);
	        const onClose = (_a = options === null || options === void 0 ? void 0 : options.onClose) !== null && _a !== void 0 ? _a : (() => { });
	        return openIframe(uri, { onClose });
	    }
	}
	class ConnectionLevelDataSourcesAccessor extends ConnectionLevelElementsListAccessor {
	    constructor(client, connectionSelector) {
	        super(client, connectionSelector, 'data-sources');
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	    }
	}

	var FlowNodeRunStatus;
	(function (FlowNodeRunStatus) {
	    FlowNodeRunStatus["COMPLETED"] = "completed";
	    FlowNodeRunStatus["FAILED"] = "failed";
	    FlowNodeRunStatus["SKIPPED"] = "skipped";
	})(FlowNodeRunStatus || (FlowNodeRunStatus = {}));

	class FlowRunsAccessor {
	    constructor(client) {
	        this.client = client;
	    }
	    async find(query) {
	        return this.client.get('/flow-runs', query);
	    }
	    async create(request) {
	        return this.client.post('/flow-runs', request);
	    }
	}
	class FlowRunAccessor {
	    constructor(client, id) {
	        this.client = client;
	        this.id = id;
	        this.baseUri = `/flow-runs/${id}`;
	    }
	    async get() {
	        return this.client.get(this.baseUri);
	    }
	    async stop() {
	        await this.client.post(`${this.baseUri}/stop`);
	    }
	    async getOutput() {
	        return this.client.get(`${this.baseUri}/output`);
	    }
	    async getNodeRuns(nodeKey, parameters) {
	        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/runs/${qs.stringify(parameters)}`);
	    }
	    async getNodeRun(nodeKey, runId) {
	        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/runs/${runId}`);
	    }
	    async getNodeOutputs(nodeKey, parameters) {
	        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/outputs?${qs.stringify(parameters)}`);
	    }
	    async getNodeOutput(nodeKey, outputId) {
	        return this.client.get(`${this.baseUri}/nodes/${nodeKey}/output/${outputId}`);
	    }
	    async repeat() {
	        const flowRun = await this.get();
	        if (flowRun.state === FlowRunState.RUNNING) {
	            throw new BadRequestError('Cannot repeat a running flow run.');
	        }
	        const flowInstanceAccessor = new FlowInstanceAccessor(this.client, flowRun.flowInstanceId);
	        return flowInstanceAccessor.startRun({
	            nodeKey: flowRun.startNodeKey,
	            input: flowRun.input,
	        });
	    }
	}

	var FlowRunState;
	(function (FlowRunState) {
	    FlowRunState["QUEUED"] = "queued";
	    FlowRunState["RUNNING"] = "running";
	    FlowRunState["COMPLETED"] = "completed";
	    FlowRunState["STOPPED"] = "stopped";
	    FlowRunState["FAILED"] = "failed";
	})(FlowRunState || (FlowRunState = {}));
	var FlowRunNodeState;
	(function (FlowRunNodeState) {
	    FlowRunNodeState["RUNNING"] = "running";
	    FlowRunNodeState["COMPLETED"] = "completed";
	    FlowRunNodeState["STOPPED"] = "stopped";
	    FlowRunNodeState["FAILED"] = "failed";
	})(FlowRunNodeState || (FlowRunNodeState = {}));
	var FlowRunLaunchedByTrigger;
	(function (FlowRunLaunchedByTrigger) {
	    FlowRunLaunchedByTrigger["ApiTrigger"] = "api-trigger";
	    FlowRunLaunchedByTrigger["ScheduleTrigger"] = "schedule-trigger";
	    FlowRunLaunchedByTrigger["AppEventTrigger"] = "app-event-trigger";
	    FlowRunLaunchedByTrigger["DataSourceTrigger"] = "data-source-trigger";
	    FlowRunLaunchedByTrigger["ExternalEvent"] = "external-event";
	})(FlowRunLaunchedByTrigger || (FlowRunLaunchedByTrigger = {}));

	const MAX_POLLING_ERRORS = 10;
	class FlowsAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'flows');
	    }
	}
	class FlowAccessor extends ElementAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            path: 'flow',
	        });
	    }
	    async apply(integrationKeys) {
	        return await this.options.client.post(this.getPath('apply'), {
	            integrationKeys,
	        });
	    }
	    async reset() {
	        return await this.options.client.post(this.getPath('reset'));
	    }
	}
	class FlowInstancesAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'flow-instances');
	    }
	    async create(data) {
	        return this.client.post('/flow-instances', data);
	    }
	}
	class FlowInstanceAccessor extends ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            instancePath: 'flow-instance',
	            type: WorkspaceElementType.FlowInstance,
	        });
	        this.client = client;
	        this.selector = selector;
	    }
	    async enable() {
	        return this.patch({ enabled: true });
	    }
	    async disable() {
	        return this.patch({ enabled: false });
	    }
	    async updateToLatestFlow() {
	        const id = await this.getId();
	        return this.client.post(`/flow-instances/${id}/update-to-latest-flow`);
	    }
	    async setup() {
	        const id = await this.getId();
	        return this.client.post(`/flow-instances/${id}/setup`);
	    }
	    async reset(options) {
	        const id = await this.getId();
	        return this.client.post(`/flow-instances/${id}/reset`, options);
	    }
	    async openConfiguration({ nodeKey, onClose = () => { }, } = {}) {
	        const id = await this.getId();
	        const uri = await this.client.getEmbedUri(`flow-instances/${id}/configuration`, {
	            nodeKey,
	        });
	        return openIframe(uri, {
	            onClose,
	        });
	    }
	    async openEditor({ onClose = () => { } } = {}) {
	        const id = await this.getId();
	        const uri = await this.client.getEmbedUri(`flow-instances/${id}/editor`);
	        return openIframe(uri, {
	            onClose,
	        });
	    }
	    async startRun(options = {}) {
	        const id = await this.getId();
	        const flowRunsAccessor = new FlowRunsAccessor(this.client);
	        const flowRun = await flowRunsAccessor.create({
	            flowInstanceId: id,
	            nodeKey: options.nodeKey,
	            input: options.input,
	        });
	        return flowRun;
	    }
	    async run(options = {}) {
	        function onUpdate(flowRun) {
	            var _a;
	            (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, flowRun);
	        }
	        const flowRun = await this.startRun(options);
	        onUpdate(flowRun);
	        let checkFlowRunInterval;
	        function cleanup() {
	            if (checkFlowRunInterval) {
	                clearInterval(checkFlowRunInterval);
	            }
	        }
	        return new Promise((resolve, reject) => {
	            const handleFlowRunUpdate = async (flowRun) => {
	                var _a, _b;
	                onUpdate(flowRun);
	                if (flowRun.state === FlowRunState.COMPLETED) {
	                    cleanup();
	                    resolve(flowRun);
	                }
	                else if (flowRun.state === FlowRunState.FAILED) {
	                    cleanup();
	                    reject(new Error(`Flow run ${flowRun.id} failed: ${(_b = (_a = flowRun.errors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.message}`));
	                }
	            };
	            const fetchFlowRun = async () => {
	                const flowRunAccessor = new FlowRunAccessor(this.client, flowRun.id);
	                await handleFlowRunUpdate(await flowRunAccessor.get());
	            };
	            let pollingFlowRun = false;
	            let errors = 0;
	            checkFlowRunInterval = setInterval(async () => {
	                if (!pollingFlowRun) {
	                    pollingFlowRun = true;
	                    try {
	                        await fetchFlowRun();
	                        errors = 0;
	                    }
	                    finally {
	                        errors += 1;
	                        if (errors > MAX_POLLING_ERRORS) {
	                            cleanup();
	                            reject(new Error(`Got ${errors} errors while polling flow run ${flowRun.id} state - aborting`));
	                        }
	                        pollingFlowRun = false;
	                    }
	                }
	            }, 1000);
	        });
	    }
	}
	class IntegrationLevelFlowAccessor extends IntegrationLevelElementAccessor {
	    constructor(client, integrationSelector, flowSelector) {
	        super(client, integrationSelector, flowSelector, 'flows');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	        this.flowSelector = flowSelector;
	    }
	}
	class IntegrationLevelFlowsListAccessor extends IntegrationLevelElementsListAccessor {
	    constructor(client, integrationSelector) {
	        super(client, integrationSelector, 'flows');
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	    }
	}
	class ConnectionLevelFlowAccessor extends ConnectionLevelElementAccessor {
	    constructor(client, connectionSelector, flowSelector, query) {
	        super(client, connectionSelector, flowSelector, 'flows', query);
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	        this.flowSelector = flowSelector;
	        this.query = query;
	    }
	    async enable() {
	        return this.patch({ enabled: true });
	    }
	    async disable() {
	        return this.patch({ enabled: false });
	    }
	    async run(options) {
	        return await this.client.post(this.uri('/run'), options);
	    }
	    async openConfiguration(options) {
	        var _a;
	        const instance = await this.get({ autoCreate: true });
	        const uri = await this.client.getEmbedUri(`flow-instances/${instance.id}/configuration`, {
	            nodeKey: options === null || options === void 0 ? void 0 : options.nodeKey,
	        });
	        const onClose = (_a = options === null || options === void 0 ? void 0 : options.onClose) !== null && _a !== void 0 ? _a : (() => { });
	        return openIframe(uri, { onClose });
	    }
	    async openEditor(options) {
	        var _a;
	        const instance = await this.get({ autoCreate: true });
	        const uri = await this.client.getEmbedUri(`flow-instances/${instance.id}/editor`);
	        const onClose = (_a = options === null || options === void 0 ? void 0 : options.onClose) !== null && _a !== void 0 ? _a : (() => { });
	        return openIframe(uri, { onClose });
	    }
	}
	class ConnectionLevelFlowsAccessor extends ConnectionLevelElementsListAccessor {
	    constructor(client, connectionSelector) {
	        super(client, connectionSelector, 'flows');
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	    }
	}

	class FlowNodeSpec {
	    constructor(args) {
	        Object.assign(this, args);
	    }
	}

	var ApiRequestToExternalApp = new FlowNodeSpec({
	    name: 'API Request to External App',
	    description: 'Send an arbitrary API request to the external application',
	    requiresIntegration: true,
	});

	var ApiRequestToYourApp = new FlowNodeSpec({
	    name: 'API Request to Your App',
	    description: 'Send an API request to my application',
	});

	var ApiTrigger = new FlowNodeSpec({
	    name: 'API Trigger',
	    description: 'Launch flow via API',
	    isTrigger: true,
	});

	var AppEventTrigger = new FlowNodeSpec({
	    name: 'App Event Trigger',
	    description: 'Trigger flow when a matching App Event is received',
	    isTrigger: true,
	});

	var connectorEventTrigger = new FlowNodeSpec({
	    name: 'Connector Event Trigger',
	    description: "Trigger flow on one of the events defined by the external app's connector.",
	    isTrigger: true,
	    requiresIntegration: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var CreateDataLink = new FlowNodeSpec({
	    name: 'Create Data Link',
	    description: 'Link records between your app and external app',
	});

	var CreateDataRecord = new FlowNodeSpec({
	    name: 'Create Data Record',
	    description: 'Create a new data record in a collection',
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.EXPORT,
	});

	var CustomHttpRequest = new FlowNodeSpec({
	    name: 'Custom HTTP Request',
	    description: 'Send an API request',
	});

	var DataRecordCreatedTrigger = new FlowNodeSpec({
	    name: 'Data Record Created Trigger',
	    description: 'Launch flow when a data record is created in a remote data collection',
	    isTrigger: true,
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var DataRecordDeletedTrigger = new FlowNodeSpec({
	    name: 'Data Record Deleted Trigger',
	    description: 'Launch flow when a data record is deleted in a remote data collection',
	    isTrigger: true,
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var DataRecordUpdatedTrigger = new FlowNodeSpec({
	    name: 'Data Record Updated Trigger',
	    description: 'Launch flow when a data record is updated in a remote data collection',
	    isTrigger: true,
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var DeleteDataLink = new FlowNodeSpec({
	    name: 'Delete Data Link',
	    description: 'Unlink records between your app and external app',
	});

	var DeleteDataRecord = new FlowNodeSpec({
	    name: 'Delete Data Record',
	    description: 'Delete a new data record from a collection using its id',
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.EXPORT,
	});

	var Filter = new FlowNodeSpec({
	    name: 'Filter',
	    description: 'Filter records that go forward through the flow',
	});

	var FindDataLink = new FlowNodeSpec({
	    name: 'Find Data Link',
	    description: 'Find a link between records in your app and external app',
	});

	var FindDataRecordById = new FlowNodeSpec({
	    name: 'Find Data Record By Id',
	    description: 'Find a single data record by id',
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var FindDataRecords = new FlowNodeSpec({
	    name: 'Find Data Records',
	    description: 'Find records in a data collection by their field values',
	    isDeprecated: true,
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var FindOrCreateDataRecord = new FlowNodeSpec({
	    name: 'Find or Create Data Record',
	    description: 'Find a matching data record or create a new one if nothing found.',
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.EXPORT,
	});

	var ForEach = new FlowNodeSpec({
	    name: 'For Each',
	    description: 'Execute one or more steps for each item on a list.',
	});

	var ForEachV2 = new FlowNodeSpec({
	    name: 'For Each',
	    description: 'Execute one or more steps for each item on a list.',
	    getSubFlowRootNodeKey: (node) => { var _a; return (_a = node.config) === null || _a === void 0 ? void 0 : _a.rootNodeKey; },
	});

	var IntegrationSpecificOperation = new FlowNodeSpec({
	    name: 'Integration-specific Operation',
	    description: 'Node that executes operation specific to an integration flow is created for.',
	    requiresIntegration: true,
	});

	var ListDataRecords = new FlowNodeSpec({
	    name: 'List Data Records',
	    description: 'List all records from a data collection with an optional filter',
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var LookupDataRecord = new FlowNodeSpec({
	    name: 'Lookup Data Record',
	    description: 'Find a one data record by its fields',
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.IMPORT,
	});

	var RunAction = new FlowNodeSpec({
	    name: 'Run Action',
	    description: 'Run prebuilt action.',
	});

	var RunJavascript = new FlowNodeSpec({
	    name: 'Run JavaScript',
	    description: 'Run custom JavaScript code',
	});

	var ScheduleTrigger = new FlowNodeSpec({
	    name: 'Schedule Trigger',
	    description: 'Run flow on schedule',
	    isTrigger: true,
	});

	var SearchDataRecords = new FlowNodeSpec({
	    name: 'Search Data Records',
	    description: 'Search records by query.',
	    direction: FieldMappingDirection.IMPORT,
	});

	var TransformData = new FlowNodeSpec({
	    name: 'Transform Data',
	    description: 'Create a data structure of any shape by combining and transforming inputs',
	    requiresDataSpec: false,
	});

	var UpdateDataRecord = new FlowNodeSpec({
	    name: 'Update Data Record',
	    description: 'Update a new data record in a collection using its id',
	    requiresDataSpec: true,
	    direction: FieldMappingDirection.EXPORT,
	});

	var FlowNodeType;
	(function (FlowNodeType) {
	    FlowNodeType["ApiTrigger"] = "api-trigger";
	    FlowNodeType["ScheduleTrigger"] = "schedule-trigger";
	    FlowNodeType["AppEventTrigger"] = "app-event-trigger";
	    FlowNodeType["DataRecordCreatedTrigger"] = "data-record-created-trigger";
	    FlowNodeType["DataRecordUpdatedTrigger"] = "data-record-updated-trigger";
	    FlowNodeType["DataRecordDeletedTrigger"] = "data-record-deleted-trigger";
	    FlowNodeType["ConnectorEventTrigger"] = "connector-event-trigger";
	    FlowNodeType["SearchDataRecords"] = "search-data-records";
	    FlowNodeType["ListDataRecords"] = "list-data-records";
	    FlowNodeType["FindOrCreateDataRecord"] = "find-or-create-data-record";
	    FlowNodeType["LookupDataRecord"] = "lookup-data-record";
	    FlowNodeType["FindDataRecordById"] = "find-data-record-by-id";
	    FlowNodeType["CreateDataRecord"] = "create-data-record";
	    FlowNodeType["UpdateDataRecord"] = "update-data-record";
	    FlowNodeType["DeleteDataRecord"] = "delete-data-record";
	    FlowNodeType["CreateDataLink"] = "create-data-link";
	    FlowNodeType["FindDataLink"] = "find-data-link";
	    FlowNodeType["DeleteDataLink"] = "delete-data-link";
	    FlowNodeType["TransformData"] = "transform-data";
	    FlowNodeType["Filter"] = "filter";
	    FlowNodeType["ForEachV2"] = "for-each-v2";
	    FlowNodeType["RunJavascript"] = "run-javascript";
	    FlowNodeType["IntegrationSpecificOperation"] = "integration-specific-operation";
	    FlowNodeType["ApiRequestToYourApp"] = "api-request-to-your-app";
	    FlowNodeType["ApiRequestToExernalApp"] = "api-request-to-external-app";
	    FlowNodeType["CustomHttpRequest"] = "custom-http-request";
	    FlowNodeType["RunAction"] = "run-action";
	    FlowNodeType["ApiRequest"] = "api-request";
	    FlowNodeType["CustomApiRequest"] = "custom-api-request";
	    FlowNodeType["HttpRequest"] = "http-request";
	    FlowNodeType["ForEach"] = "for-each";
	    FlowNodeType["FindDataRecords"] = "find-data-records";
	})(FlowNodeType || (FlowNodeType = {}));
	({
	    [FlowNodeType.ApiTrigger]: ApiTrigger,
	    [FlowNodeType.ScheduleTrigger]: ScheduleTrigger,
	    [FlowNodeType.AppEventTrigger]: AppEventTrigger,
	    [FlowNodeType.ConnectorEventTrigger]: connectorEventTrigger,
	    [FlowNodeType.DataRecordCreatedTrigger]: DataRecordCreatedTrigger,
	    [FlowNodeType.DataRecordUpdatedTrigger]: DataRecordUpdatedTrigger,
	    [FlowNodeType.DataRecordDeletedTrigger]: DataRecordDeletedTrigger,
	    [FlowNodeType.SearchDataRecords]: SearchDataRecords,
	    [FlowNodeType.ListDataRecords]: ListDataRecords,
	    [FlowNodeType.LookupDataRecord]: LookupDataRecord,
	    [FlowNodeType.FindOrCreateDataRecord]: FindOrCreateDataRecord,
	    [FlowNodeType.FindDataRecords]: {
	        ...FindDataRecords},
	    [FlowNodeType.FindDataRecordById]: FindDataRecordById,
	    [FlowNodeType.CreateDataRecord]: CreateDataRecord,
	    [FlowNodeType.UpdateDataRecord]: UpdateDataRecord,
	    [FlowNodeType.DeleteDataRecord]: DeleteDataRecord,
	    [FlowNodeType.TransformData]: TransformData,
	    [FlowNodeType.Filter]: Filter,
	    [FlowNodeType.CreateDataLink]: CreateDataLink,
	    [FlowNodeType.FindDataLink]: FindDataLink,
	    [FlowNodeType.DeleteDataLink]: DeleteDataLink,
	    [FlowNodeType.ForEach]: {
	        ...ForEach},
	    [FlowNodeType.ForEachV2]: ForEachV2,
	    [FlowNodeType.RunJavascript]: RunJavascript,
	    [FlowNodeType.IntegrationSpecificOperation]: IntegrationSpecificOperation,
	    [FlowNodeType.ApiRequestToYourApp]: ApiRequestToYourApp,
	    [FlowNodeType.HttpRequest]: {
	        ...ApiRequestToYourApp},
	    [FlowNodeType.ApiRequestToExernalApp]: ApiRequestToExternalApp,
	    [FlowNodeType.CustomApiRequest]: {
	        ...ApiRequestToExternalApp},
	    [FlowNodeType.CustomHttpRequest]: CustomHttpRequest,
	    [FlowNodeType.ApiRequest]: {
	        ...CustomHttpRequest},
	    [FlowNodeType.RunAction]: RunAction,
	});

	var FlowInstanceNodeState;
	(function (FlowInstanceNodeState) {
	    FlowInstanceNodeState["SETTING_UP"] = "SETTING_UP";
	    FlowInstanceNodeState["SETUP_FAILED"] = "SETUP_FAILED";
	    FlowInstanceNodeState["READY"] = "READY";
	})(FlowInstanceNodeState || (FlowInstanceNodeState = {}));

	class ConnectionsAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'connections');
	    }
	    create(data) {
	        return this.client.post('/connections', data);
	    }
	}
	class ConnectionAccessor {
	    constructor(client, connectionSelector) {
	        this.client = client;
	        this.connectionSelector = connectionSelector;
	    }
	    get actions() {
	        return new ConnectionLevelActionsAccessor(this.client, this.connectionSelector);
	    }
	    action(actionSelector, query) {
	        return new ConnectionLevelActionAccessor(this.client, this.connectionSelector, actionSelector, query !== null && query !== void 0 ? query : {});
	    }
	    get flows() {
	        return new ConnectionLevelFlowsAccessor(this.client, this.connectionSelector);
	    }
	    flow(flowSelector, query) {
	        return new ConnectionLevelFlowAccessor(this.client, this.connectionSelector, flowSelector, query !== null && query !== void 0 ? query : {});
	    }
	    get dataSources() {
	        return new ConnectionLevelDataSourcesAccessor(this.client, this.connectionSelector);
	    }
	    dataSource(dataSourceSelector, query) {
	        return new ConnectionLevelDataSourceAccessor(this.client, this.connectionSelector, dataSourceSelector, query !== null && query !== void 0 ? query : {});
	    }
	    get fieldMappings() {
	        return new ConnectionLevelFieldMappingsAccessor(this.client, this.connectionSelector);
	    }
	    fieldMapping(fieldMappingSelector, query) {
	        return new ConnectionLevelFieldMappingAccessor(this.client, this.connectionSelector, fieldMappingSelector, query !== null && query !== void 0 ? query : {});
	    }
	    async get(query = { includeSecrets: false }) {
	        return this.client.get(`/connections/${this.connectionSelector}`, query);
	    }
	    async patch(data) {
	        return this.client.patch(`/connections/${this.connectionSelector}`, data);
	    }
	    async put(data) {
	        return this.client.put(`/connections/${this.connectionSelector}`, data);
	    }
	    async archive() {
	        return this.client.delete(`/connections/${this.connectionSelector}`);
	    }
	    async request(path, data = null) {
	        const pathWithoutSlash = path.startsWith('/') ? path.slice(1) : path;
	        return this.client.post(`/connections/${this.connectionSelector}/api/${pathWithoutSlash}`, data);
	    }
	    get proxy() {
	        return new ConnectionProxy(this);
	    }
	    operation(key) {
	        return new ConnectionOperationAccessor(this.client, this, key);
	    }
	    dataCollection(key, parameters) {
	        return new ConnectionDataCollectionAccessor(this.client, this, key, parameters);
	    }
	    dataDirectory(key, parameters) {
	        return new ConnectionDataDirectoryAccessor(this.client, this, key, parameters);
	    }
	    async reconnect({ parameters, authOptionKey, } = {}) {
	        const connection = await this.get();
	        const connectorSpec = await this.client.get(`/integrations/${connection.integrationId}/connector-spec`);
	        return createOrUpdateConnection({
	            connectionId: connection.id,
	            connectorSpec,
	            parameters,
	            authOptionKey,
	            apiUri: this.client.apiUri,
	            token: await this.client.getToken(),
	        });
	    }
	    async openReconnectUI({} = {}) {
	        const uri = await this.client.getEmbedUri(`connections/${this.connectionSelector}/refresh`);
	        return new Promise((resolve) => {
	            void openIframe(uri, {
	                onClose: () => resolve(null),
	                onSuccess: (connection) => resolve(connection),
	            });
	        });
	    }
	    async refreshCredentials() {
	        return this.client.post(`connections/${this.connectionSelector}/refresh-credentials`);
	    }
	    getPath(subpath, query) {
	        const queryString = new URLSearchParams(omitBy(query !== null && query !== void 0 ? query : {}, isEmptyValue)).toString();
	        return (urljoin(`/connections/${this.connectionSelector}`, subpath !== null && subpath !== void 0 ? subpath : '') +
	            (queryString ? `?${queryString}` : ''));
	    }
	}
	class ConnectionOperationAccessor {
	    constructor(client, connectionAccessor, key) {
	        this.client = client;
	        this.connectionAccessor = connectionAccessor;
	        this.key = key;
	    }
	    async get() {
	        return this.client.get(this.connectionAccessor.getPath(`operations/${this.key}`));
	    }
	    async run(request) {
	        return this.client.post(this.connectionAccessor.getPath(`operations/${this.key}/run`), request);
	    }
	}
	class ConnectionDataDirectoryAccessor {
	    constructor(client, connectionAccessor, key, parameters) {
	        this.client = client;
	        this.connectionAccessor = connectionAccessor;
	        this.key = key;
	        this.parameters = parameters;
	    }
	    async list(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/list`, this.parameters), request);
	    }
	}
	class ConnectionDataCollectionAccessor {
	    constructor(client, connectionAccessor, key, parameters) {
	        this.client = client;
	        this.connectionAccessor = connectionAccessor;
	        this.key = key;
	        this.parameters = parameters;
	    }
	    async get() {
	        return this.client.get(this.connectionAccessor.getPath(`data/${this.key}`, this.parameters));
	    }
	    async findById(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/find-by-id`, this.parameters), request);
	    }
	    async list(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/list`, this.parameters), request);
	    }
	    async search(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/search`, this.parameters), request);
	    }
	    async match(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/match`, this.parameters), request);
	    }
	    async create(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/create`, this.parameters), request);
	    }
	    async update(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/update`, this.parameters), request);
	    }
	    async delete(request) {
	        return this.client.post(this.connectionAccessor.getPath(`data/${this.key}/delete`, this.parameters), request);
	    }
	}
	class ConnectionProxy {
	    constructor(connection) {
	        this.connection = connection;
	    }
	    async get(path) {
	        return this.connection.client.get(this.getProxyPath(path));
	    }
	    async post(path, data) {
	        return this.connection.client.post(this.getProxyPath(path), data);
	    }
	    async put(path, data) {
	        return this.connection.client.put(this.getProxyPath(path), data);
	    }
	    async patch(path, data) {
	        return this.connection.client.patch(this.getProxyPath(path), data);
	    }
	    async delete(path) {
	        return this.connection.client.delete(this.getProxyPath(path));
	    }
	    getProxyPath(path) {
	        return urljoin(`/connections/${this.connection.connectionSelector}/proxy`, path);
	    }
	}

	class DataLinkTablesAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'data-link-tables');
	    }
	}
	class DataLinkTableAccessor extends ElementAccessor {
	    constructor(client, idOrKey) {
	        super({
	            client,
	            path: 'data-link-table',
	            selector: idOrKey,
	        });
	    }
	}
	class DataLinkTableInstancesAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'data-link-table-instances');
	    }
	}
	class DataLinkTableInstanceAccessor extends ElementInstanceAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            instancePath: 'data-link-table-instance',
	            selector,
	        });
	        this.client = client;
	    }
	    async findLinks(query) {
	        const queryString = query ? qs.stringify(query) : '';
	        return this.client.get(this.getPath('links') + (queryString ? `&${queryString}` : ''));
	    }
	    async createLink(data) {
	        return this.client.post(this.getPath('links'), data);
	    }
	    async deleteLink(data) {
	        return this.client.delete(this.getPath('links'), data);
	    }
	}

	var DataLinkDirection;
	(function (DataLinkDirection) {
	    DataLinkDirection["IMPORT"] = "import";
	    DataLinkDirection["EXPORT"] = "export";
	    DataLinkDirection["BOTH"] = "both";
	})(DataLinkDirection || (DataLinkDirection = {}));

	var ExternalEventType;
	(function (ExternalEventType) {
	    ExternalEventType["DataRecordCreated"] = "data-record-created";
	    ExternalEventType["DataRecordUpdated"] = "data-record-updated";
	    ExternalEventType["DataRecordDeleted"] = "data-record-deleted";
	    ExternalEventType["ConnectorEvent"] = "connector-event";
	})(ExternalEventType || (ExternalEventType = {}));
	var ExternalEventSubscriptionStatus;
	(function (ExternalEventSubscriptionStatus) {
	    ExternalEventSubscriptionStatus["Subscribed"] = "subscribed";
	    ExternalEventSubscriptionStatus["Unsubscribed"] = "unsubscribed";
	    ExternalEventSubscriptionStatus["Error"] = "error";
	})(ExternalEventSubscriptionStatus || (ExternalEventSubscriptionStatus = {}));
	var ExternalEventPullStatus;
	(function (ExternalEventPullStatus) {
	    ExternalEventPullStatus["RUNNING"] = "running";
	    ExternalEventPullStatus["SUCCESS"] = "success";
	    ExternalEventPullStatus["ERROR"] = "error";
	    ExternalEventPullStatus["QUEUED"] = "queued";
	})(ExternalEventPullStatus || (ExternalEventPullStatus = {}));
	var IncomingWebhooksState;
	(function (IncomingWebhooksState) {
	    IncomingWebhooksState["QUEUED"] = "queued";
	    IncomingWebhooksState["RUNNING"] = "running";
	    IncomingWebhooksState["SUCCESS"] = "success";
	    IncomingWebhooksState["ERROR"] = "error";
	})(IncomingWebhooksState || (IncomingWebhooksState = {}));
	var ExternalEventSubscriptionType;
	(function (ExternalEventSubscriptionType) {
	    ExternalEventSubscriptionType["DataRecordCreated"] = "data-record-created";
	    ExternalEventSubscriptionType["DataRecordUpdated"] = "data-record-updated";
	    ExternalEventSubscriptionType["DataRecordDeleted"] = "data-record-deleted";
	    ExternalEventSubscriptionType["ConnectorEvent"] = "connector-event";
	})(ExternalEventSubscriptionType || (ExternalEventSubscriptionType = {}));

	class ExternalEventSubscriptionsAccessor extends ElementInstanceListAccessor {
	    constructor(client) {
	        super(client, 'external-event-subscriptions');
	    }
	}
	class ExternalEventSubscriptionAccessor {
	    constructor(client, id) {
	        this.client = client;
	        this.id = id;
	    }
	    async get() {
	        return this.client.get(this.getPath());
	    }
	    async setup() {
	        await this.client.post(this.getPath('setup'));
	    }
	    async subscribe() {
	        await this.client.post(this.getPath('subscribe'));
	    }
	    async unsubscribe() {
	        await this.client.post(this.getPath('unsubscribe'));
	    }
	    async resubscribe() {
	        await this.client.post(this.getPath('resubscribe'));
	    }
	    async pullEvents() {
	        await this.client.post(this.getPath('pull-events'));
	    }
	    getPath(operation = '') {
	        return `external-event-subscriptions/${this.id}${operation ? '/' + operation : ''}`;
	    }
	}

	class IntegrationsAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'integrations');
	    }
	}
	class IntegrationAccessor extends ElementAccessor {
	    constructor(client, integrationSelector) {
	        super({
	            client,
	            path: 'integration',
	            selector: integrationSelector,
	        });
	        this.client = client;
	        this.integrationSelector = integrationSelector;
	    }
	    get actions() {
	        return new IntegrationLevelActionsListAccessor(this.client, this.integrationSelector);
	    }
	    action(actionSelector) {
	        return new IntegrationLevelActionAccessor(this.client, this.integrationSelector, actionSelector);
	    }
	    get flows() {
	        return new IntegrationLevelFlowsListAccessor(this.client, this.integrationSelector);
	    }
	    flow(flowSelector) {
	        return new IntegrationLevelFlowAccessor(this.client, this.integrationSelector, flowSelector);
	    }
	    get dataSources() {
	        return new IntegrationLevelDataSourcesListAccessor(this.client, this.integrationSelector);
	    }
	    dataSource(dataSourceSelector) {
	        return new IntegrationLevelDataSourceAccessor(this.client, this.integrationSelector, dataSourceSelector);
	    }
	    get fieldMappings() {
	        return new IntegrationLevelFieldMappingsListAccessor(this.client, this.integrationSelector);
	    }
	    fieldMapping(fieldMappingSelector) {
	        return new IntegrationLevelFieldMappingAccessor(this.client, this.integrationSelector, fieldMappingSelector);
	    }
	    async setup() {
	        return this.client.post(`/integrations/${this.integrationSelector}/setup`);
	    }
	    async resetParameters() {
	        return this.client.post(`/integrations/${this.integrationSelector}/reset-parameters`);
	    }
	    async getConnectorSpec() {
	        return this.client.get(`/integrations/${this.integrationSelector}/connector-spec`);
	    }
	    async open({ onClose = () => { }, } = {}) {
	        const integration = await this.get();
	        const uri = await this.client.getEmbedUri(`integrations/${integration.id}`);
	        return openIframe(uri, {
	            onClose,
	        });
	    }
	    async openNewConnection({ allowMultipleConnections, name, } = {}) {
	        const uri = await this.client.getEmbedUri(`integrations/${this.integrationSelector}/connect`, {
	            allowMultipleConnections: allowMultipleConnections ? '1' : '',
	            name,
	        });
	        return new Promise((resolve) => {
	            return openIframe(uri, {
	                onClose: () => resolve(null),
	                onSuccess: (connection) => resolve(connection),
	            });
	        });
	    }
	    async connect({ name, parameters, authOptionKey, allowMultipleConnections, redirectUri, sameWindow, } = {}) {
	        const integration = await this.get();
	        const connectorSpec = await this.getConnectorSpec();
	        return createOrUpdateConnection({
	            integrationId: integration.id,
	            connectorSpec,
	            name,
	            parameters,
	            authOptionKey,
	            allowMultipleConnections,
	            apiUri: this.client.apiUri,
	            token: await this.client.getToken(),
	            redirectUri: sameWindow ? redirectUri : undefined,
	        });
	    }
	    async createConnection({ parameters, name, }) {
	        return this.connect({ parameters, name });
	    }
	    async disconnect() {
	        return this.client.post(`/integrations/${this.integrationSelector}/disconnect`);
	    }
	    async getOperations() {
	        return this.client.get(this.getPath('operations'));
	    }
	    async getOperation(key) {
	        return this.client.get(this.getPath(`operations/${key}`));
	    }
	    async getDataCollections() {
	        return this.client.get(this.getPath('data'));
	    }
	    async getDataCollection(key) {
	        return this.client.get(this.getPath(`data/${key}`));
	    }
	    async getDataLocations() {
	        return this.client.get(this.getPath('data'));
	    }
	    async getDataLocation(key) {
	        return this.client.get(this.getPath(`data/${key}`));
	    }
	}

	class ScenariosAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'scenarios');
	    }
	}
	class ScenarioAccessor extends ElementAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            path: 'scenario',
	        });
	    }
	}

	class ScreensAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'screens');
	    }
	}
	class ScreenAccessor extends ElementAccessor {
	    constructor(client, selector) {
	        super({
	            client,
	            selector,
	            path: 'screen',
	        });
	    }
	}

	class CustomersAccessor extends ElementListAccessor {
	    constructor(client) {
	        super(client, 'customers');
	    }
	}
	class CustomerAccessor extends ElementAccessor {
	    constructor(client, selector) {
	        super({
	            path: 'customer',
	            client,
	            selector,
	        });
	    }
	}

	class IntegrationAppClient extends IntegrationAppApiClient {
	    constructor(options) {
	        super(options);
	    }
	    get self() {
	        return new SelfAccessor(this);
	    }
	    get flows() {
	        return new FlowsAccessor(this);
	    }
	    async open({ onClose = () => { }, } = {}) {
	        const uri = await this.getEmbedUri('main', {});
	        return openIframe(uri, {
	            onClose,
	        });
	    }
	    action(selector) {
	        return new ActionAccessor(this, selector);
	    }
	    get actions() {
	        return new ActionsAccessor(this);
	    }
	    screen(selector) {
	        return new ScreenAccessor(this, selector);
	    }
	    get screens() {
	        return new ScreensAccessor(this);
	    }
	    actionInstance(selector) {
	        return new ActionInstanceAccessor(this, selector);
	    }
	    get actionInstances() {
	        return new ActionInstancesAccessor(this);
	    }
	    flow(selector) {
	        return new FlowAccessor(this, selector);
	    }
	    get flowInstances() {
	        return new FlowInstancesAccessor(this);
	    }
	    flowInstance(selector) {
	        return new FlowInstanceAccessor(this, selector);
	    }
	    get dataSourceInstances() {
	        return new DataSourceInstancesAccessor(this);
	    }
	    get dataSources() {
	        return new DataSourcesAccessor(this);
	    }
	    dataSource(selector) {
	        return new DataSourceAccessor(this, selector);
	    }
	    dataSourceInstance(selector) {
	        return new DataSourceInstanceAccessor(this, selector);
	    }
	    get fieldMappings() {
	        return new FieldMappingsAccessor(this);
	    }
	    fieldMapping(selector) {
	        return new FieldMappingAccessor(this, selector);
	    }
	    get fieldMappingInstances() {
	        return new FieldMappingInstancesAccessor(this);
	    }
	    fieldMappingInstance(selector) {
	        return new FieldMappingInstanceAccessor(this, selector);
	    }
	    get dataLinkTables() {
	        return new DataLinkTablesAccessor(this);
	    }
	    dataLinkTable(idOrKey) {
	        return new DataLinkTableAccessor(this, idOrKey);
	    }
	    get dataLinkTableInstances() {
	        return new DataLinkTableInstancesAccessor(this);
	    }
	    dataLinkTableInstance(selector) {
	        return new DataLinkTableInstanceAccessor(this, selector);
	    }
	    get integrations() {
	        return new IntegrationsAccessor(this);
	    }
	    externalEventSubscriptions() {
	        return new ExternalEventSubscriptionsAccessor(this);
	    }
	    externalEventSubscription(id) {
	        return new ExternalEventSubscriptionAccessor(this, id);
	    }
	    integration(identifier) {
	        return new IntegrationAccessor(this, identifier);
	    }
	    get connections() {
	        return new ConnectionsAccessor(this);
	    }
	    connection(connectionSelector) {
	        return new ConnectionAccessor(this, connectionSelector);
	    }
	    get appEventTypes() {
	        return new AppEventTypesAccessor(this);
	    }
	    appEventType(id) {
	        return new AppEventTypeAccessor(this, id);
	    }
	    get appEventSubscriptions() {
	        return new AppEventSubscriptionsAccessor(this);
	    }
	    appEventSubscription(selector) {
	        return new AppEventSubscriptionAccessor(this, selector);
	    }
	    get appEvents() {
	        return new AppEventsAccessor(this);
	    }
	    get flowRuns() {
	        return new FlowRunsAccessor(this);
	    }
	    flowRun(id) {
	        return new FlowRunAccessor(this, id);
	    }
	    get appDataSchemas() {
	        return new AppDataSchemasAccessor(this);
	    }
	    appDataSchema(id) {
	        return new AppDataSchemaAccessor(this, id);
	    }
	    get appDataSchemaInstances() {
	        return new AppDataSchemaInstancesAccessor(this);
	    }
	    appDataSchemaInstance(selector) {
	        return new AppDataSchemaInstanceAccessor(this, selector);
	    }
	    customer(selector) {
	        return new CustomerAccessor(this, selector);
	    }
	    get customers() {
	        return new CustomersAccessor(this);
	    }
	    scenario(selector) {
	        return new ScenarioAccessor(this, selector);
	    }
	    get scenarios() {
	        return new ScenariosAccessor(this);
	    }
	    async connectionRequest(connectionId, uri, data) {
	        return this.post(`connections/${connectionId}/execute-request`, {
	            key: uri,
	            payload: data,
	        });
	    }
	}

	return IntegrationAppClient;

}));
//# sourceMappingURL=bundle.js.map
